<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Spring-Security源码解析与实战（持续更新） | 淡云月来去</title><meta name="author" content="wzy"><meta name="copyright" content="wzy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Spring-Security源码解析与实战">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring-Security源码解析与实战（持续更新）">
<meta property="og:url" content="https://featherbrainna.github.io/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/index.html">
<meta property="og:site_name" content="淡云月来去">
<meta property="og:description" content="Spring-Security源码解析与实战">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://featherbrainna.github.io/img/butterfly.png">
<meta property="article:published_time" content="2024-02-25T15:50:53.000Z">
<meta property="article:modified_time" content="2024-02-25T16:04:30.149Z">
<meta property="article:author" content="wzy">
<meta property="article:tag" content="Spring Security">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://featherbrainna.github.io/img/butterfly.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://featherbrainna.github.io/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: wzy","link":"链接: ","source":"来源: 淡云月来去","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring-Security源码解析与实战（持续更新）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-26 00:04:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/butterfly.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">淡云月来去</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring-Security源码解析与实战（持续更新）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-25T15:50:53.000Z" title="发表于 2024-02-25 23:50:53">2024-02-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-25T16:04:30.149Z" title="更新于 2024-02-26 00:04:30">2024-02-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Spring-Security/">Spring Security</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring-Security源码解析与实战（持续更新）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Spring Security是一个提供了<strong>认证、授权、常见攻击保护</strong>的框架。适用于非响应式、响应式编程的项目。是基于 <strong>Spring AOP</strong> 和 <strong>Servlet 过滤器</strong>的安全框架，提供全面的安全性解决方案。</p>
<p>Spring Security 中<a target="_blank" rel="noopener" href="https://www.javaboy.org/2020/0617/authorize-springsecurity.html">四种常见的权限控制方式</a>。</p>
<ul>
<li>表达式控制 URL 路径权限</li>
<li>表达式控制方法权限</li>
<li>使用过滤注解</li>
<li>动态权限</li>
</ul>
<h1 id="一、过滤器解析"><a href="#一、过滤器解析" class="headerlink" title="一、过滤器解析"></a>一、过滤器解析</h1><p>过滤器链<strong>采用的是责任链的设计模式</strong>，它有一条很长的过滤器链。</p>
<h2 id="1-ChannelProcessingFilter"><a href="#1-ChannelProcessingFilter" class="headerlink" title="1.ChannelProcessingFilter"></a>1.ChannelProcessingFilter</h2><p>通常是用来过滤哪些请求必须用 https 协议， 哪些请求必须用 http协议， 哪些请求随便用哪个协议都行。</p>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) req;</span><br><span class="line">   <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) res;</span><br><span class="line">   <span class="type">FilterInvocation</span> <span class="variable">filterInvocation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterInvocation</span>(request, response, chain);</span><br><span class="line">   Collection&lt;ConfigAttribute&gt; attributes = <span class="built_in">this</span>.securityMetadataSource.getAttributes(filterInvocation);</span><br><span class="line">   <span class="keyword">if</span> (attributes != <span class="literal">null</span>) &#123;</span><br><span class="line">      。。。日志</span><br><span class="line">      <span class="built_in">this</span>.channelDecisionManager.decide(filterInvocation, attributes);</span><br><span class="line">      <span class="keyword">if</span> (filterInvocation.getResponse().isCommitted()) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-WebAsyncManagerIntegrationFilter"><a href="#2-WebAsyncManagerIntegrationFilter" class="headerlink" title="2.WebAsyncManagerIntegrationFilter"></a>2.WebAsyncManagerIntegrationFilter</h2><p>用于<strong>集成 SecurityContext 到Spring异步执行机制中</strong>。通过 SecurityContextCallableProcessingInterceptor.beforeConcurrentHandling()就可以将 SecurityContext 传递给异步线程。</p>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><br><span class="line">      <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">   <span class="comment">//1.获取 WebAsyncManager异步管理器</span></span><br><span class="line">   <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">   <span class="comment">//2.从异步管理器获取过滤器对应的SecurityContextCallableProcessingInterceptor</span></span><br><span class="line">   <span class="comment">// 检查异步管理器是否设置了此过滤器对应的SecurityContextCallableProcessingInterceptor，如果没有设置则会进行设置</span></span><br><span class="line">   <span class="type">SecurityContextCallableProcessingInterceptor</span> <span class="variable">securityProcessingInterceptor</span> <span class="operator">=</span> (SecurityContextCallableProcessingInterceptor) asyncManager</span><br><span class="line">         .getCallableInterceptor(CALLABLE_INTERCEPTOR_KEY);</span><br><span class="line">   <span class="comment">//3.如果为空，将新的 SecurityContextCallableProcessingInterceptor注册进去</span></span><br><span class="line">   <span class="keyword">if</span> (securityProcessingInterceptor == <span class="literal">null</span>) &#123;</span><br><span class="line">      asyncManager.registerCallableInterceptor(CALLABLE_INTERCEPTOR_KEY,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SecurityContextCallableProcessingInterceptor</span>());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//4.执行下一个过滤器 </span></span><br><span class="line">   filterChain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-SecurityContextPersistenceFilter"><a href="#3-SecurityContextPersistenceFilter" class="headerlink" title="3.SecurityContextPersistenceFilter"></a>3.SecurityContextPersistenceFilter</h2><p>主要<strong>控制 SecurityContext 的在一次请求中的生命周期</strong> 。请求来临时，创建SecurityContext 安全上下文信息，请求结束时清空 SecurityContextHolder 。</p>
<blockquote>
<p>请求 / 线程 &lt; 会话 &lt; 应用</p>
</blockquote>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="comment">//1.如果过滤器执行过一次则跳过此过滤器</span></span><br><span class="line">   <span class="keyword">if</span> (request.getAttribute(FILTER_APPLIED) != <span class="literal">null</span>) &#123;</span><br><span class="line">      chain.doFilter(request, response);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.设置请求属性 &quot;__spring_security_scpf_applied&quot; 为 true </span></span><br><span class="line">   request.setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">   。。。创建session</span><br><span class="line">   <span class="type">HttpRequestResponseHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpRequestResponseHolder</span>(request, response);</span><br><span class="line">   <span class="comment">//3.从 SecurityContextRepository 加载 SecurityContext，默认为HttpSessionSecurityContextRepository</span></span><br><span class="line">   <span class="comment">//	如果SecurityContextRepository没有则创建一个新的。（从会话中获取SecurityContext供当前线程使用）</span></span><br><span class="line">   <span class="type">SecurityContext</span> <span class="variable">contextBeforeChainExecution</span> <span class="operator">=</span> <span class="built_in">this</span>.repo.loadContext(holder);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//4.设置 SecurityContext 到 SecurityContextHolder（设置ThreadLocal）</span></span><br><span class="line">      SecurityContextHolder.setContext(contextBeforeChainExecution);</span><br><span class="line">      。。。日志</span><br><span class="line">      <span class="comment">//5.继续执行下一个过滤器</span></span><br><span class="line">      chain.doFilter(holder.getRequest(), holder.getResponse());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//6.将SecurityContext保存到repo，并清空当前SecurityContextHolder（清理ThreadLocal）</span></span><br><span class="line">      <span class="type">SecurityContext</span> <span class="variable">contextAfterChainExecution</span> <span class="operator">=</span> SecurityContextHolder.getContext();</span><br><span class="line">      SecurityContextHolder.clearContext();</span><br><span class="line">      <span class="built_in">this</span>.repo.saveContext(contextAfterChainExecution, holder.getRequest(), holder.getResponse());</span><br><span class="line">      <span class="comment">//7.移除请求属性</span></span><br><span class="line">      request.removeAttribute(FILTER_APPLIED);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结以上出现的部件概念，如下：</p>
<ul>
<li><strong>SecurityContextRepository</strong>：负责<strong>保证在一个用户级会话的过程中，维护住相关的安全上下文信息</strong>。这个问题主要发生在web应用中，由于http的无状态性，所以每次request都需要重复加载安全上下文信息。默认情况下，将基于HTTP Session来完成这方面的工作。</li>
<li><strong>SecurityContext</strong>：安全上下文信息。</li>
<li><strong>SecurityContextHolder</strong>：<strong>维护一个线程的SecurityContext</strong>，用户请求处理过程中的各种程序调用能够使用到SecurityContext。默认使用线程变量机制，对于Web应用比较合适。如果是swing程序等，可以换用文件机制。</li>
</ul>
<blockquote>
<p>实现每次请求/每个线程设置 SecurityContextHolder 的 SecurityContext，并在结束后清理SecurityContextHolder 。</p>
</blockquote>
<h2 id="4-HeaderWriterFilter"><a href="#4-HeaderWriterFilter" class="headerlink" title="4.HeaderWriterFilter"></a>4.HeaderWriterFilter</h2><p>用于添加响应头，比如 X-Frame-Options（防止点击劫持） , X-XSSProtection（防止xss注入脚本攻击）， X-Content-Type-Options（防止基于 MIME 类型混淆的攻击）。</p>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><br><span class="line">      <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">   <span class="comment">//1.查看过滤器属性为true(默认为false)，则在之前添加响应头 </span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.shouldWriteHeadersEagerly) &#123;</span><br><span class="line">      doHeadersBefore(request, response, filterChain);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//2.过滤器属性为false，则在之后添加响应头（这里使用了装饰者模式增强功能）</span></span><br><span class="line">      doHeadersAfter(request, response, filterChain);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doHeadersAfter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">//1.装饰 Response、Request</span></span><br><span class="line">    <span class="type">HeaderWriterResponse</span> <span class="variable">headerWriterResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeaderWriterResponse</span>(request, response);</span><br><span class="line">    <span class="type">HeaderWriterRequest</span> <span class="variable">headerWriterRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeaderWriterRequest</span>(request, headerWriterResponse);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//2.执行下一个过滤器</span></span><br><span class="line">        filterChain.doFilter(headerWriterRequest, headerWriterResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3.调用装饰后的响应对象方法写响应头</span></span><br><span class="line">        headerWriterResponse.writeHeaders();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真正的写响应头方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">writeHeaders</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">//调用过滤器属性 headerWriters来写响应头（过滤器属性在HeadersConfigurer中注入）</span></span><br><span class="line">    <span class="keyword">for</span> (HeaderWriter writer : <span class="built_in">this</span>.headerWriters) &#123;</span><br><span class="line">        writer.writeHeaders(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有如下 headerWriters 对象</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HeaderWriter&gt; <span class="title function_">getHeaderWriters</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;HeaderWriter&gt; writers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.contentTypeOptions.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.xssProtection.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.cacheControl.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.hsts.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.frameOptions.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.hpkp.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.contentSecurityPolicy.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.referrerPolicy.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.featurePolicy.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.permissionsPolicy.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.crossOriginOpenerPolicy.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.crossOriginEmbedderPolicy.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.crossOriginResourcePolicy.writer);</span><br><span class="line">    writers.addAll(<span class="built_in">this</span>.headerWriters);</span><br><span class="line">    <span class="keyword">return</span> writers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-CorsFilter"><a href="#5-CorsFilter" class="headerlink" title="5.CorsFilter"></a>5.CorsFilter</h2><p>跨域相关的过滤器。</p>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">      FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">   <span class="comment">//1.从configSource属性获取 CorsConfiguration对象	 </span></span><br><span class="line">   <span class="type">CorsConfiguration</span> <span class="variable">corsConfiguration</span> <span class="operator">=</span> <span class="built_in">this</span>.configSource.getCorsConfiguration(request);</span><br><span class="line">   <span class="comment">//2.使用 processor属性处理跨域</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">isValid</span> <span class="operator">=</span> <span class="built_in">this</span>.processor.processRequest(corsConfiguration, request, response);</span><br><span class="line">   <span class="comment">//3.一些跨域请求如option请求处理直接返回</span></span><br><span class="line">   <span class="keyword">if</span> (!isValid || CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//4.继续下一个过滤器 </span></span><br><span class="line">   filterChain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-LogoutFilter"><a href="#6-LogoutFilter" class="headerlink" title="6.LogoutFilter"></a>6.LogoutFilter</h2><p>注销过滤器，<strong>专门用于处理注销请求</strong>，默认处理的请求路径为/logout，否则则跳过此过滤器。</p>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="comment">//1.根据请求和过滤器属性来决定是否进行注销过滤，如果是则执行过滤 </span></span><br><span class="line">   <span class="keyword">if</span> (requiresLogout(request, response)) &#123;</span><br><span class="line">      <span class="comment">//2.获取认证对象 </span></span><br><span class="line">      <span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">      <span class="comment">//3.处理注销 </span></span><br><span class="line">      <span class="built_in">this</span>.handler.logout(request, response, auth);</span><br><span class="line">      <span class="comment">//4.注销成功后处理 </span></span><br><span class="line">      <span class="built_in">this</span>.logoutSuccessHandler.onLogoutSuccess(request, response, auth);</span><br><span class="line">      <span class="comment">//5.返回 </span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.无需过滤的请求，执行下一个过滤器</span></span><br><span class="line">   chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">requiresLogout</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">//根据请求路径来匹配，若匹配则返回true</span></span><br><span class="line">    <span class="comment">// 先委托给AntPathRequestMatcher.matches(request)(处理类型匹配)，再委托给 SpringAntMatcher.matches(url)，	 //	最后委托给AntPathMatcher.match(String pattern, String path)（处理路径匹配）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.logoutRequestMatcher.matches(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    。。。日志</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-ConcurrentSessionFilter"><a href="#7-ConcurrentSessionFilter" class="headerlink" title="7.ConcurrentSessionFilter"></a>7.ConcurrentSessionFilter</h2><p>用于同步SessionRegistry中注册的SessionInformation状态。1.从SessionRegistry获取 SessionInformation并检查是否过期2.每次请求就更新sessioninformation的时间。SessionRegistry默认使用内存对象 <code>SessionRegistryImpl</code> ，它是一个监听器监听session相关的事件然后注册到其内部。</p>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="comment">//1.获取session对象</span></span><br><span class="line">   <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(<span class="literal">false</span>);</span><br><span class="line">   <span class="comment">//2.如果没有session就跳过此过滤器 （如禁用了session）</span></span><br><span class="line">   <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//3.从内存sessionRegistry中获取 SessionInformation</span></span><br><span class="line">      <span class="type">SessionInformation</span> <span class="variable">info</span> <span class="operator">=</span> <span class="built_in">this</span>.sessionRegistry.getSessionInformation(session.getId());</span><br><span class="line">      <span class="comment">//4.如果非空进行更新 </span></span><br><span class="line">      <span class="keyword">if</span> (info != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">//5.如果过期，执行登出</span></span><br><span class="line">         <span class="keyword">if</span> (info.isExpired()) &#123;</span><br><span class="line">            。。。日志</span><br><span class="line">            doLogout(request, response);</span><br><span class="line">            。。。发布登出事件</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//6.更新 SessionInformation时间</span></span><br><span class="line">         <span class="built_in">this</span>.sessionRegistry.refreshLastRequest(info.getSessionId());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//7.执行下一个过滤器</span></span><br><span class="line">   chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-UsernamePasswordAuthenticationFilter"><a href="#8-UsernamePasswordAuthenticationFilter" class="headerlink" title="8.UsernamePasswordAuthenticationFilter"></a>8.UsernamePasswordAuthenticationFilter</h2><p>处理<strong>用户以及密码认证</strong>的核心过滤器。认证请求提交的username 和 password 被封装成 <code>UsernamePasswordAuthenticationToken</code> 进行一系列的认证。 <code>UsernamePasswordAuthenticationToken</code> 实际上就是 <code>Authentication</code> 类型。</p>
<p>过滤器<strong>默认只会处理 <code>/login POST</code> 请求</strong>，可以配置请求路径。</p>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   doFilter((HttpServletRequest) request, (HttpServletResponse) response, chain);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">	<span class="comment">//1.不需要认证直接跳过过滤器（按请求路径和类型匹配）</span></span><br><span class="line">    <span class="keyword">if</span> (!requiresAuthentication(request, response)) &#123;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//2.进行认证</span></span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authenticationResult</span> <span class="operator">=</span> attemptAuthentication(request, response);</span><br><span class="line">        <span class="keyword">if</span> (authenticationResult == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        。。。</span><br><span class="line">        <span class="comment">//3.是否支持成功后继续执行过滤链，如果支持认证成功，继续下一个过滤</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.continueChainBeforeSuccessfulAuthentication) &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.认证成功后处理</span></span><br><span class="line">        successfulAuthentication(request, response, chain, authenticationResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;</span><br><span class="line">        <span class="comment">//5.异常后处理</span></span><br><span class="line">        unsuccessfulAuthentication(request, response, failed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AuthenticationException ex) &#123;</span><br><span class="line">        <span class="comment">//5.认证失败后处理</span></span><br><span class="line">        unsuccessfulAuthentication(request, response, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-1-doFilter方法"><a href="#4-1-doFilter方法" class="headerlink" title="4.1.doFilter方法"></a>4.1.doFilter方法</h3><p>AbstractAuthenticationProcessingFilter类有过滤器方法doFilter来过滤处理post方式的/login请求。</p>
<p>方法来源：由UsernamePasswordAuthenticationFilter组件直接调用，但本类没有此方法，调用继承的父类AbstractAuthenticationProcessingFilter方法。</p>
<p>方法逻辑：判断是否需要过滤、尝试认证、设置会话、认证成功处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractAuthenticationProcessingFilter类doFilter方法源码解析</span></span><br><span class="line"><span class="comment">//外部过滤器调用的方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">		doFilter((HttpServletRequest) request, (HttpServletResponse) response, chain);<span class="comment">//方法重载调用私有doFilter方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内部真正调用重载方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">//1.判断是否需要过滤器处理，不需要跳过此过滤器。判断依据封装在requiresAuthentication，依据方法路径和类型判断。</span></span><br><span class="line">    <span class="keyword">if</span> (!requiresAuthentication(request, response)) &#123;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.尝试认证</span></span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">authenticationResult</span> <span class="operator">=</span> attemptAuthentication(request, response);</span><br><span class="line">    <span class="keyword">if</span> (authenticationResult == <span class="literal">null</span>) &#123;<span class="comment">//认证返回为null中止过滤链返回</span></span><br><span class="line">        <span class="comment">// return immediately as subclass has indicated that it hasn&#x27;t completed</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.认证成功后依据会话策略设置会话。在CompositeSessionAuthenticationStrategy中处理会话</span></span><br><span class="line">    <span class="built_in">this</span>.sessionStrategy.onAuthentication(authenticationResult, request, response);</span><br><span class="line">    <span class="comment">// Authentication success</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.continueChainBeforeSuccessfulAuthentication) &#123;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.认证成功处理</span></span><br><span class="line">    successfulAuthentication(request, response, chain, authenticationResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用的比较重要的方法：</p>
<ul>
<li>attemptAuthentication</li>
<li>successfulAuthentication</li>
</ul>
<h3 id="4-2-attemptAuthentication方法"><a href="#4-2-attemptAuthentication方法" class="headerlink" title="4.2.attemptAuthentication方法"></a>4.2.attemptAuthentication方法</h3><p>UsernamePasswordAuthenticationFilter类通过attemptAuthentication方法来尝试认证，本质是认证前的一些处理并委托给authenticationManager进行认证。</p>
<p>方法来源：UsernamePasswordAuthenticationFilter类的doFilter调用。</p>
<p>方法逻辑：只处理post的认证请求，从请求中解析出用户名和密码，并使用UsernamePasswordAuthenticationToken类封装作为认证令牌，传入认证令牌并委托<strong>authenticationManager</strong>的authenticate方法进行认证。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UsernamePasswordAuthenticationFilter类attemptAuthentication方法源码解析</span></span><br><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span><span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    <span class="comment">//1.只处理post请求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.postOnly &amp;&amp; !request.getMethod().equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationServiceException</span>(<span class="string">&quot;Authentication method not supported: &quot;</span> + request.getMethod());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.解析用户名和密码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> obtainUsername(request);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> obtainPassword(request);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//3.把用户名密码封装成UsernamePasswordAuthenticationToken认证令牌</span></span><br><span class="line">    <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(username, password);</span><br><span class="line">    <span class="comment">//4.为令牌设置Details</span></span><br><span class="line">    setDetails(request, authRequest);</span><br><span class="line">    <span class="comment">//5.委托给AuthenticationManager认证处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-ProviderManager类authenticate方法"><a href="#4-3-ProviderManager类authenticate方法" class="headerlink" title="4.3.ProviderManager类authenticate方法"></a>4.3.ProviderManager类authenticate方法</h3><p>ProviderManager类是==AuthenticationManager接口==的默认实现类，通过authenticate方法来实现多种认证方式尝试认证。</p>
<p>方法来源：来源于ProviderManager类，但UsernamePasswordAuthenticationFilter类attemptAuthentication方法是通过AuthenticationManager接口调用authenticate方法，故是通过<strong>多态</strong>实现了源于ProviderManager类的authenticate方法的调用。</p>
<p>方法逻辑：遍历所有的AuthenticationProvider进行认证provider.authenticate(authentication)。其中默认包含DaoAuthhenticationProvider组件。ProviderManager中管理了诸多用于认证的AuthenticationProvider组件。<strong>依据认证令牌的类型来使用不同的AuthenticationProvider（认证登录真正的逻辑）</strong>。这样spring security就通过ProviderManager扩展了登录认证的方式，具有良好的扩展性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ProviderManager类的authenticate方法</span></span><br><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    <span class="comment">//1.记录authentication认证令牌类的类型</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Authentication</span>&gt; toTest = authentication.getClass();</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">parentResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//2.依据令牌类型，遍历AuthenticationProvider来进行认证处理</span></span><br><span class="line">    <span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line">        <span class="comment">//3.判断是否能处理该类型令牌</span></span><br><span class="line">        <span class="keyword">if</span> (!provider.supports(toTest)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.委托DaoAuthenticationProvider来处理认证</span></span><br><span class="line">        result = provider.authenticate(authentication);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;<span class="comment">//认证成功复制details给result，并退出遍历循环</span></span><br><span class="line">            copyDetails(authentication, result);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父AuthenticationManager尝试机制</span></span><br><span class="line">     <span class="keyword">if</span> (result == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">         parentResult = <span class="built_in">this</span>.parent.authenticate(authentication);</span><br><span class="line">         result = parentResult;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//5.返回认证主体。去除密码信息</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.eraseCredentialsAfterAuthentication &amp;&amp; (result <span class="keyword">instanceof</span> CredentialsContainer)) &#123;</span><br><span class="line">            ((CredentialsContainer) result).eraseCredentials();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.没有获得认证后的主体，抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> lastException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-AbstractUserDetailsAuthenticationProvider类authenticate方法"><a href="#4-4-AbstractUserDetailsAuthenticationProvider类authenticate方法" class="headerlink" title="4.4.AbstractUserDetailsAuthenticationProvider类authenticate方法"></a>4.4.AbstractUserDetailsAuthenticationProvider类authenticate方法</h3><p>AbstractUserDetailsAuthenticationProvider类authenticate方法功能是登录认证使用数据库来认证用户名和密码。</p>
<p>方法来源：直接调用者是DaoAuthhenticationProvider组件。其继承了AbstractUserDetailsAuthenticationProvider，由于没有authenticate方法在本类中所以使用继承的父类authenticate方法。</p>
<p>方法逻辑：先从令牌中提取username，然后提供了用户信息本地缓存机制，然后查询数据库，然后检查查询到的结果（检查用户状态、检查密码、检查密码状态），然后添加缓存，然后按需求返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractUserDetailsAuthenticationProvider类authenticate方法源码解析</span></span><br><span class="line"><span class="comment">//其本质上充当/login的service层，实现了查询数据库用户信息、校验密码、返回</span></span><br><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> determineUsername(authentication);<span class="comment">//1.提取username</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">cacheWasUsed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> <span class="built_in">this</span>.userCache.getUserFromCache(username);<span class="comment">//2.查缓存</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheWasUsed = <span class="literal">false</span>;</span><br><span class="line">        user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);<span class="comment">//3.查数据库</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.preAuthenticationChecks.check(user);<span class="comment">//4.前置认证检查，检查用户状态信息（包括锁定状态、可用状态、过期状态），检查失败会递归调用retrieveUser然后再前置检查。</span></span><br><span class="line">    additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);<span class="comment">//4.密码检查</span></span><br><span class="line">    <span class="built_in">this</span>.postAuthenticationChecks.check(user);<span class="comment">//4.后置认证检查，检查密码过期状态。</span></span><br><span class="line">    <span class="keyword">if</span> (!cacheWasUsed) &#123;</span><br><span class="line">			<span class="built_in">this</span>.userCache.putUserInCache(user);<span class="comment">//5.添加缓存用户信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">principalToReturn</span> <span class="operator">=</span> user;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.forcePrincipalAsString) &#123;</span><br><span class="line">        principalToReturn = user.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);<span class="comment">//6.依据用户信息等封装合法的主体信息结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用的重要方法：</p>
<ul>
<li>retrieveUser</li>
<li>preAuthenticationChecks.check</li>
<li>additionalAuthenticationChecks</li>
<li>postAuthenticationChecks.check</li>
<li>createSuccessAuthentication</li>
</ul>
<h3 id="4-5-retrieveUser方法"><a href="#4-5-retrieveUser方法" class="headerlink" title="4.5.retrieveUser方法"></a>4.5.retrieveUser方法</h3><p>DaoAuthhenticationProvider中提供了查询数据库的方法retrieveUser。</p>
<p>方法来源：DaoAuthhenticationProvider组件。由AbstractUserDetailsAuthenticationProvider类authenticate方法调用。</p>
<p>方法逻辑：定时攻击保护、委托给<strong>UserDetailsService组件进行数据库查询</strong>包括用户信息和用户权限、用户名是否存在检查。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DaoAuthhenticationProvider类retrieveUser方法源码解析</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> UserDetails <span class="title function_">retrieveUser</span><span class="params">(String username, UsernamePasswordAuthenticationToken authentication)</span></span><br><span class="line">			<span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    prepareTimingAttackProtection();<span class="comment">//1.定时攻击保护</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="type">UserDetails</span> <span class="variable">loadedUser</span> <span class="operator">=</span> <span class="built_in">this</span>.getUserDetailsService().loadUserByUsername(username);<span class="comment">//2.委托给UserDetailsService组件进行数据库查询用户信息，包括用户信息和用户权限</span></span><br><span class="line">			<span class="keyword">if</span> (loadedUser == <span class="literal">null</span>) &#123;<span class="comment">//3.用户名是否存在检查</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalAuthenticationServiceException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> loadedUser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-createSuccessAuthentication方法"><a href="#4-6-createSuccessAuthentication方法" class="headerlink" title="4.6.createSuccessAuthentication方法"></a>4.6.createSuccessAuthentication方法</h3><p>DaoAuthhenticationProvider中提供了依据查询结果封装为Authentication认证后主体的方法createSuccessAuthentication。</p>
<p>方法来源：直接来源DaoAuthhenticationProvider，但同时方法本身调用了父类AbstractUserDetailsAuthenticationProvider的createSuccessAuthentication来最终生成Authentication。由（被）AbstractUserDetailsAuthenticationProvider类authenticate方法调用。</p>
<p>方法逻辑：1.依据查询到的userDetail创建认证后主体。2.设置认证后主体details。3.返回认证后主体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DaoAuthhenticationProvider类createSuccessAuthentication方法源码解析</span></span><br><span class="line"><span class="keyword">protected</span> Authentication <span class="title function_">createSuccessAuthentication</span><span class="params">(Object principal, Authentication authentication,UserDetails user)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">super</span>.createSuccessAuthentication(principal, authentication, user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AbstractUserDetailsAuthenticationProvider类createSuccessAuthentication方法源码解析</span></span><br><span class="line"><span class="keyword">protected</span> Authentication <span class="title function_">createSuccessAuthentication</span><span class="params">(Object principal, Authentication authentication,UserDetails user)</span> &#123;</span><br><span class="line">		<span class="comment">// Ensure we return the original credentials the user supplied,</span></span><br><span class="line">		<span class="comment">// so subsequent attempts are successful even with encoded passwords.</span></span><br><span class="line">		<span class="comment">// Also ensure we return the original getDetails(), so that future</span></span><br><span class="line">		<span class="comment">// authentication events after cache expiry contain the details</span></span><br><span class="line">    <span class="comment">//1.依据查询到的userDetail创建认证后主体。</span></span><br><span class="line">    <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(principal,</span><br><span class="line">            authentication.getCredentials(), <span class="built_in">this</span>.authoritiesMapper.mapAuthorities(user.getAuthorities()));</span><br><span class="line">    <span class="comment">//2.设置认证后主体details</span></span><br><span class="line">    result.setDetails(authentication.getDetails());</span><br><span class="line">    <span class="built_in">this</span>.logger.debug(<span class="string">&quot;Authenticated user&quot;</span>);</span><br><span class="line">    <span class="comment">//3.返回</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-7-successfulAuthentication方法"><a href="#4-7-successfulAuthentication方法" class="headerlink" title="4.7.successfulAuthentication方法"></a>4.7.successfulAuthentication方法</h3><p>AbstractAuthenticationProcessingFilter类有方法successfulAuthentication来处理认证成功。</p>
<p>方法来源：AbstractAuthenticationProcessingFilter类。由AbstractAuthenticationProcessingFilter类的doFilter方法调用。</p>
<p>方法逻辑：1.初始化设置SecurityContextHolder和SecurityContext。2.通知rememberMeServices服务认证成功。3.发布认证成功消息。4.委托给AuthenticationSuccessHandler来处理认证成功。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractAuthenticationProcessingFilter类successfulAuthentication方法源码分析。</span></span><br><span class="line"><span class="comment">//默认初始化的认证成功处理器为SavedRequestAwareAuthenticationSuccessHandler</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">AuthenticationSuccessHandler</span> <span class="variable">successHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SavedRequestAwareAuthenticationSuccessHandler</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">successfulAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain,Authentication authResult)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">//1.初始化设置SecurityContextHolder和SecurityContext，将认证后主体保存到SecurityContextHolder中的SecurityContext中。</span></span><br><span class="line">	<span class="type">SecurityContext</span> <span class="variable">context</span> <span class="operator">=</span> SecurityContextHolder.createEmptyContext();</span><br><span class="line">    context.setAuthentication(authResult);</span><br><span class="line">    SecurityContextHolder.setContext(context);</span><br><span class="line">   <span class="comment">//。。。</span></span><br><span class="line">    <span class="comment">//2.通知rememberMeServices服务认证成功</span></span><br><span class="line">    <span class="built_in">this</span>.rememberMeServices.loginSuccess(request, response, authResult);</span><br><span class="line">    <span class="comment">//3.发布认证成功消息</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.eventPublisher != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">InteractiveAuthenticationSuccessEvent</span>(authResult, <span class="built_in">this</span>.getClass()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.委托给AuthenticationSuccessHandler来处理认证成功。</span></span><br><span class="line">    <span class="built_in">this</span>.successHandler.onAuthenticationSuccess(request, response, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-8-子类onAuthenticationSuccess方法"><a href="#4-8-子类onAuthenticationSuccess方法" class="headerlink" title="4.8.子类onAuthenticationSuccess方法"></a>4.8.子类onAuthenticationSuccess方法</h3><p>SavedRequestAwareAuthenticationSuccessHandler类有方法onAuthenticationSuccess来处理认证成功。具体处理的是解析<strong>重定向到哪个url</strong>。即：认证后重定向到认证前url问题。</p>
<p>方法来源：SavedRequestAwareAuthenticationSuccessHandler类。由AbstractAuthenticationProcessingFilter类successfulAuthentication方法调用。</p>
<p>方法逻辑：1.获取对应认证请求缓存的认证前请求（即要访问的未认证请求）。2.没有缓存，调用父类方法返回配置的重定向url。3.是否配置重定向url在请求参数中或配置使用默认重定向url。调用父类方法返回配置的重定向url。4.获取缓存的重定向地址。5.重定向。总结：若从认证页面进行认证，则直接依据配置的默认重定向地址进行重定向；从未认证页面进行认证，则会重定向到未认证页面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SavedRequestAwareAuthenticationSuccessHandler类onAuthenticationSuccess方法源码解析</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response,Authentication authentication)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//1.获取对应认证请求缓存的认证前请求（即要访问的未认证请求）。</span></span><br><span class="line">    <span class="type">SavedRequest</span> <span class="variable">savedRequest</span> <span class="operator">=</span> <span class="built_in">this</span>.requestCache.getRequest(request, response);</span><br><span class="line">    <span class="comment">//2.没有缓存，调用父类方法返回配置的重定向url。</span></span><br><span class="line">    <span class="keyword">if</span> (savedRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">super</span>.onAuthenticationSuccess(request, response, authentication);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.是否配置重定向url在请求参数中或配置使用默认重定向url。调用父类方法返回配置的重定向url。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">targetUrlParameter</span> <span class="operator">=</span> getTargetUrlParameter();</span><br><span class="line">    <span class="keyword">if</span> (isAlwaysUseDefaultTargetUrl()</span><br><span class="line">            || (targetUrlParameter != <span class="literal">null</span> &amp;&amp; StringUtils.hasText(request.getParameter(targetUrlParameter)))) &#123;</span><br><span class="line">        <span class="built_in">this</span>.requestCache.removeRequest(request, response);</span><br><span class="line">        <span class="built_in">super</span>.onAuthenticationSuccess(request, response, authentication);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    clearAuthenticationAttributes(request);</span><br><span class="line">    <span class="comment">// Use the DefaultSavedRequest URL</span></span><br><span class="line">    <span class="comment">//4.获取缓存的重定向地址。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">targetUrl</span> <span class="operator">=</span> savedRequest.getRedirectUrl();</span><br><span class="line">    <span class="comment">//5.重定向。</span></span><br><span class="line">    getRedirectStrategy().sendRedirect(request, response, targetUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-9-父类onAuthenticationSuccess方法"><a href="#4-9-父类onAuthenticationSuccess方法" class="headerlink" title="4.9.父类onAuthenticationSuccess方法"></a>4.9.父类onAuthenticationSuccess方法</h3><p>父类onAuthenticationSuccess方法源码解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleUrlAuthenticationSuccessHandler类onAuthenticationSuccess方法源码解析</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleUrlAuthenticationSuccessHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstractAuthenticationTargetUrlRequestHandler</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationSuccessHandler</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response,Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//处理认证成功</span></span><br><span class="line">		handle(request, response, authentication);</span><br><span class="line">		clearAuthenticationAttributes(request);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractAuthenticationTargetUrlRequestHandler类haanle方法源码解析</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">//1.确定重新url</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">targetUrl</span> <span class="operator">=</span> determineTargetUrl(request, response, authentication);</span><br><span class="line">   <span class="comment">//。。。</span></span><br><span class="line">    <span class="comment">//2.重定向到目标url</span></span><br><span class="line">    <span class="built_in">this</span>.redirectStrategy.sendRedirect(request, response, targetUrl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AbstractAuthenticationTargetUrlRequestHandler类determineTargetUrl方法源码解析</span></span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">determineTargetUrl</span><span class="params">(HttpServletRequest request, HttpServletResponse response,Authentication authentication)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> determineTargetUrl(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">determineTargetUrl</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">//1.检查配置一直使用默认重定向地址，直接返回默认重定向地址</span></span><br><span class="line">    <span class="keyword">if</span> (isAlwaysUseDefaultTargetUrl()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.defaultTargetUrl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check for the parameter and use that if available</span></span><br><span class="line">    <span class="comment">//2.检查配置请求参数中获取重定向地址，则返回请求参数中的重定向地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">targetUrl</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.targetUrlParameter != <span class="literal">null</span>) &#123;</span><br><span class="line">        targetUrl = request.getParameter(<span class="built_in">this</span>.targetUrlParameter);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(targetUrl)) &#123;</span><br><span class="line">            <span class="keyword">return</span> targetUrl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.检查配置请求头Referer获取重定向地址</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.useReferer &amp;&amp; !StringUtils.hasLength(targetUrl)) &#123;</span><br><span class="line">        targetUrl = request.getHeader(<span class="string">&quot;Referer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.没有获取到重定向地址，直接复制默认重定向地址</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(targetUrl)) &#123;</span><br><span class="line">        targetUrl = <span class="built_in">this</span>.defaultTargetUrl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.返回</span></span><br><span class="line">    <span class="keyword">return</span> targetUrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-10-详细的认证流程时序图"><a href="#4-10-详细的认证流程时序图" class="headerlink" title="4.10.详细的认证流程时序图"></a>4.10.详细的认证流程时序图</h3><p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/springsecurity%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90.png" alt="springsecurity认证过程分析"></p>
<blockquote>
<p>HttpSecurity.formLogin()注入过滤器，实现了指定路径认证过滤其它路径跳过此过滤器。</p>
</blockquote>
<h2 id="9-RequestCacheAwareFilter"><a href="#9-RequestCacheAwareFilter" class="headerlink" title="9.RequestCacheAwareFilter"></a>9.RequestCacheAwareFilter</h2><p>用于<strong>缓存未认证成功的请求</strong>。且<a target="_blank" rel="noopener" href="https://juejin.cn/post/7273758446113128502#heading-1">默认只能缓存 GET 类型请求</a>，在异常处理过滤器中执行缓存，在账号密码登录过滤器认证成功时使用缓存重定向到缓存的请求。</p>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="comment">//1.从缓存中获取 与当前请求匹配的保存的 wrappedSavedRequest</span></span><br><span class="line">   <span class="type">HttpServletRequest</span> <span class="variable">wrappedSavedRequest</span> <span class="operator">=</span> <span class="built_in">this</span>.requestCache.getMatchingRequest((HttpServletRequest) request, (HttpServletResponse) response);</span><br><span class="line">   <span class="comment">//2.如果获取不到，则该过滤器无效；如果获取到了则执行缓存的请求 </span></span><br><span class="line">   chain.doFilter((wrappedSavedRequest != <span class="literal">null</span>) ? wrappedSavedRequest : request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="10-SecurityContextHolderAwareRequestFilter"><a href="#10-SecurityContextHolderAwareRequestFilter" class="headerlink" title="10.SecurityContextHolderAwareRequestFilter"></a>10.SecurityContextHolderAwareRequestFilter</h2><p>包装原始请求和响应对象生成一个新的请求对象。<strong>增强了请求对象的能力</strong>、增加了功能。</p>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="comment">//调用 HttpServlet3RequestFactory对象 包装请求和响应为 Servlet3SecurityContextHolderAwareRequestWrapper</span></span><br><span class="line">   chain.doFilter(<span class="built_in">this</span>.requestFactory.create((HttpServletRequest) req, (HttpServletResponse) res), res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//过滤器属性初始化完成后自动执行的方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="built_in">super</span>.afterPropertiesSet();</span><br><span class="line">    updateFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置过滤器的 requestFactory对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">rolePrefix</span> <span class="operator">=</span> <span class="built_in">this</span>.rolePrefix;</span><br><span class="line">    <span class="built_in">this</span>.requestFactory = createServlet3Factory(rolePrefix);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//底层创建的 HttpServlet3RequestFactory对象</span></span><br><span class="line"><span class="keyword">private</span> HttpServletRequestFactory <span class="title function_">createServlet3Factory</span><span class="params">(String rolePrefix)</span> &#123;</span><br><span class="line">    <span class="type">HttpServlet3RequestFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpServlet3RequestFactory</span>(rolePrefix);</span><br><span class="line">    factory.setTrustResolver(<span class="built_in">this</span>.trustResolver);</span><br><span class="line">    factory.setAuthenticationEntryPoint(<span class="built_in">this</span>.authenticationEntryPoint);</span><br><span class="line">    factory.setAuthenticationManager(<span class="built_in">this</span>.authenticationManager);</span><br><span class="line">    factory.setLogoutHandlers(<span class="built_in">this</span>.logoutHandlers);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-RememberMeAuthenticationFilter"><a href="#11-RememberMeAuthenticationFilter" class="headerlink" title="11.RememberMeAuthenticationFilter"></a>11.RememberMeAuthenticationFilter</h2><p>记住我认证过滤器。</p>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="comment">//1.如果已经认证成功，则跳过此过滤器 </span></span><br><span class="line">   <span class="keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() != <span class="literal">null</span>) &#123;</span><br><span class="line">      。。。日志</span><br><span class="line">      chain.doFilter(request, response);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.调用 rememberMeServices获取 Authentication待认证&quot;token&quot;对象</span></span><br><span class="line">   <span class="type">Authentication</span> <span class="variable">rememberMeAuth</span> <span class="operator">=</span> <span class="built_in">this</span>.rememberMeServices.autoLogin(request, response);</span><br><span class="line">   <span class="comment">//3.非空执行rememberMe认证</span></span><br><span class="line">   <span class="keyword">if</span> (rememberMeAuth != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//认证 </span></span><br><span class="line">         rememberMeAuth = <span class="built_in">this</span>.authenticationManager.authenticate(rememberMeAuth);</span><br><span class="line">         <span class="type">SecurityContext</span> <span class="variable">context</span> <span class="operator">=</span> SecurityContextHolder.createEmptyContext();</span><br><span class="line">         context.setAuthentication(rememberMeAuth);</span><br><span class="line">         SecurityContextHolder.setContext(context);</span><br><span class="line">         <span class="comment">//认证成功处理</span></span><br><span class="line">         onSuccessfulAuthentication(request, response, rememberMeAuth);</span><br><span class="line">         。。。日志</span><br><span class="line">         <span class="built_in">this</span>.securityContextRepository.saveContext(context, request, response);</span><br><span class="line">         。。。发布事件</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">this</span>.successHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//认证成功处理 </span></span><br><span class="line">            <span class="built_in">this</span>.successHandler.onAuthenticationSuccess(request, response, rememberMeAuth);</span><br><span class="line">            <span class="comment">//4.返回 </span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (AuthenticationException ex) &#123;</span><br><span class="line">         。。。日志</span><br><span class="line">         <span class="comment">//认证失败处理    </span></span><br><span class="line">         <span class="built_in">this</span>.rememberMeServices.loginFail(request, response);</span><br><span class="line">         onUnsuccessfulAuthentication(request, response, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//4.执行下一个过滤器 </span></span><br><span class="line">   chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>已认证跳过，rememberMeServices.autoLogin(request, response)返回空跳过，否组执行rememberMe认证。</p>
</blockquote>
<h2 id="12-AnonymousAuthenticationFilter"><a href="#12-AnonymousAuthenticationFilter" class="headerlink" title="12.AnonymousAuthenticationFilter"></a>12.AnonymousAuthenticationFilter</h2><p>匿名登录认证过滤器，未认证设置一个匿名认证对象到SecurityContextHolder。</p>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="comment">//1.如果没有经过认证，创建一个匿名的Authentication认证对象设置到SecurityContextHolder。</span></span><br><span class="line">   <span class="keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> createAuthentication((HttpServletRequest) req);</span><br><span class="line">      <span class="type">SecurityContext</span> <span class="variable">context</span> <span class="operator">=</span> SecurityContextHolder.createEmptyContext();</span><br><span class="line">      context.setAuthentication(authentication);</span><br><span class="line">      SecurityContextHolder.setContext(context);</span><br><span class="line">      。。。日志</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      。。。日志</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.继续下一个过滤器</span></span><br><span class="line">   chain.doFilter(req, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="13-SessionManagementFilter"><a href="#13-SessionManagementFilter" class="headerlink" title="13.SessionManagementFilter"></a>13.SessionManagementFilter</h2><p>Session 管理器过滤器，内部维护了一个SessionAuthenticationStrategy 用于管理 Session。</p>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="comment">//1.如果已被调用过跳过过滤器 </span></span><br><span class="line">   <span class="keyword">if</span> (request.getAttribute(FILTER_APPLIED) != <span class="literal">null</span>) &#123;</span><br><span class="line">      chain.doFilter(request, response);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.设置请求属性已调用 </span></span><br><span class="line">   request.setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">   <span class="comment">//3.如果 securityContextRepository 没有该请求对应的 securityContext，就需要进行处理</span></span><br><span class="line">   <span class="keyword">if</span> (!<span class="built_in">this</span>.securityContextRepository.containsContext(request)) &#123;</span><br><span class="line">      <span class="comment">//4.获取已认证的Authentication对象 </span></span><br><span class="line">      <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">      <span class="comment">//5.如果已认证，会话认证策略对象 进行相关处理（比如同一用户并发的会话/同时登录会话处理、比如会话对象是否存在、比如更		  //  改会话sessionid）</span></span><br><span class="line">       <span class="keyword">if</span> (authentication != <span class="literal">null</span> &amp;&amp; !<span class="built_in">this</span>.trustResolver.isAnonymous(authentication)) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//会话处理 </span></span><br><span class="line">            <span class="built_in">this</span>.sessionAuthenticationStrategy.onAuthentication(authentication, request, response);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (SessionAuthenticationException ex) &#123;</span><br><span class="line">            <span class="comment">//会话拒绝了认证对象，处理认证失败</span></span><br><span class="line">            SecurityContextHolder.clearContext();</span><br><span class="line">            <span class="built_in">this</span>.failureHandler.onAuthenticationFailure(request, response, ex);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//存储 SecurityContext 到securityContextRepository</span></span><br><span class="line">         <span class="built_in">this</span>.securityContextRepository.saveContext(SecurityContextHolder.getContext(), request, response);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//5.如果会话失效，则 会话失效策略对象 执行失效逻辑</span></span><br><span class="line">         <span class="keyword">if</span> (request.getRequestedSessionId() != <span class="literal">null</span> &amp;&amp; !request.isRequestedSessionIdValid()) &#123;</span><br><span class="line">            。。。日志</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.invalidSessionStrategy != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="built_in">this</span>.invalidSessionStrategy.onInvalidSessionDetected(request, response);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//4.执行下一个过滤器 </span></span><br><span class="line">   chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对会话相关进行处理。只有当前请求没有存储 securityContext 时才会进行会话处理。<strong>即是否存储好 securityContext 到会话级别标志着会话是否进行了处理</strong>。</p>
<p>认证会话处理可以包括许多内容：如更改会话id防止攻击、检查会话对象是否存在、同一用户多个会话处理等等。</p>
</blockquote>
<h2 id="14-ExceptionTranslationFilter"><a href="#14-ExceptionTranslationFilter" class="headerlink" title="14.ExceptionTranslationFilter"></a>14.ExceptionTranslationFilter</h2><p>主要来<strong>捕获异常进行合理的处理</strong>，传输异常事件。</p>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//1.继续执行下一个过滤器</span></span><br><span class="line">      chain.doFilter(request, response);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">   	  。。。</span><br><span class="line">      <span class="comment">//2.处理异常</span></span><br><span class="line">   	  handleSpringSecurityException(request, response, chain, securityException);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleSpringSecurityException</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">        FilterChain chain, RuntimeException exception)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">//1.如果是未认证异常，委托给handleAuthenticationException</span></span><br><span class="line">    <span class="comment">// AuthenticationEntryPoint组件处理</span></span><br><span class="line">    <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> AuthenticationException) &#123;</span><br><span class="line">        handleAuthenticationException(request, response, chain, (AuthenticationException) exception);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.如果是权限异常，委托给handleAccessDeniedException</span></span><br><span class="line">    <span class="comment">// AccessDeniedHandler组件处理</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> AccessDeniedException) &#123;</span><br><span class="line">        handleAccessDeniedException(request, response, chain, (AccessDeniedException) exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>合理的异常响应返回需要我们配置AuthenticationEntryPoint、AccessDeniedHandler组件。</p>
</blockquote>
<h2 id="15-FilterSecurityInterceptor（重点）"><a href="#15-FilterSecurityInterceptor（重点）" class="headerlink" title="15.FilterSecurityInterceptor（重点）"></a>15.FilterSecurityInterceptor（重点）</h2><p><strong>过滤web请求并在拒绝请求时抛出异常</strong>。这个<strong>过滤器</strong>决定了访问特定<strong>路径</strong>应该具备的权限，如果要实现动态权限控制就必须研究该类 。<strong>只处理过滤器层面的权限控制，并不处理注解AOP层面的权限控制</strong>。</p>
<p>其主要过程为：拦截<code>Authentication</code>对”secured object”的访问，依据“<strong>安全元信息属性</strong>”列表来决定<code>Authentication</code>对象是否可以访问”secured object”。</p>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   invoke(<span class="keyword">new</span> <span class="title class_">FilterInvocation</span>(request, response, chain));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(FilterInvocation filterInvocation)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">//1.不是第一次执行，跳过此过滤器</span></span><br><span class="line">    <span class="keyword">if</span> (isApplied(filterInvocation) &amp;&amp; <span class="built_in">this</span>.observeOncePerRequest) &#123;</span><br><span class="line">        filterInvocation.getChain().doFilter(filterInvocation.getRequest(), filterInvocation.getResponse());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.第一次执行，设置请求属性 __spring_security_filterSecurityInterceptor_filterApplied 为true</span></span><br><span class="line">    <span class="keyword">if</span> (filterInvocation.getRequest() != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.observeOncePerRequest) &#123;</span><br><span class="line">        filterInvocation.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.委托 beforeInvocation 执行“鉴权”过滤逻辑</span></span><br><span class="line">    <span class="type">InterceptorStatusToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="built_in">super</span>.beforeInvocation(filterInvocation);</span><br><span class="line">    <span class="comment">//4.过滤结束，执行下一个过滤器</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        filterInvocation.getChain().doFilter(filterInvocation.getRequest(), filterInvocation.getResponse());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//5.请求调用结束后执行</span></span><br><span class="line">        <span class="built_in">super</span>.finallyInvocation(token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.请求调用完成后执行</span></span><br><span class="line">    <span class="built_in">super</span>.afterInvocation(token, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>AbstractSecurityInterceptor</code>中已经规划了安全控制过程的抽象</strong>，<code>FilterSecurityInterceptor</code>是针对<strong>web request</strong>的基于filter技术实现，<code>MethodSecurityInterceptor</code>和<code>AspectJMethodSecurityInterceptor</code>是针对<strong>method invocation</strong>的基于两种java aop技术实现。</p>
<p>组件关系类图如下：</p>
<p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20240224223030340.png" alt="image-20240224223030340"></p>
<p><strong><code>AbstractSecurityInterceptor</code>中的抽象过程基本如下</strong>：</p>
<ol>
<li>寻找关联当前“secure object”的配置属性（“configuration attributes”）</li>
<li><strong>把<code>authentication</code>\secure object\configuration attributes提交给<code>AccessDecisionManager</code>.decide()</strong></li>
<li>可以在此机会对Authentication对象进行变更</li>
<li>如果授权成功，则允许请求\调用继续往下进行</li>
<li>如果配置了<code>AfterInvocaitonManager</code>，那么就调用该管理器的相关操作</li>
</ol>
<p><strong>而 AccessDecisionManager.decide()又委托给多个Voter去vote()，然后AccessDecisionManager综合意见返回。</strong></p>
<p>AccessDecisionManager有一个抽象实现类AbstractAccessDecisionManager，这个抽象实现面向了一种vote机制，其中维护了一个vote器列表。</p>
<p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20240224225955647.png" alt="image-20240224225955647"></p>
<p><code>AbstractAccessDecisionManager</code>的子类专注于一件事情：从它的vote器们的vote结果中决定，是否最终给予授权。不同的子类实现了不同的决策策略：</p>
<ol>
<li><code>AffirmativeBased</code>：任何一个vote器给予ACCESS_GRANTED，那么最终结果就给予授权；否则不授权；</li>
<li><code>ConsensusBased</code>：按少数服从多数策略，给予授权决定；</li>
<li><code>UnanimousBased</code>：一Piao否决制。</li>
<li>注意全部弃权票委托给抽象类方法checkAllowIfAllAbstainDecisions()来处理。</li>
</ol>
<h3 id="10-1-doFilter方法"><a href="#10-1-doFilter方法" class="headerlink" title="10.1.doFilter方法"></a>10.1.doFilter方法</h3><p>FilterSecurityInterceptor类方法doFilter来实现过滤处理。</p>
<p>方法来源：FilterSecurityInterceptor类</p>
<p>方法逻辑：封装一下方法参数为FilterInvocation转发给本类invoke方法处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FilterSecurityInterceptor类doFilter方法源码分析</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">		invoke(<span class="keyword">new</span> <span class="title class_">FilterInvocation</span>(request, response, chain));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-2-invoke方法"><a href="#10-2-invoke方法" class="headerlink" title="10.2.invoke方法"></a>10.2.invoke方法</h3><p>FilterSecurityInterceptor类方法invoke来实现过滤处理。</p>
<p>方法来源：FilterSecurityInterceptor类</p>
<p>方法逻辑：1.检查是否已经经过安全校验（对于该用户的该请求）2.设置请求属性已安全校验3.过滤器访问控制前处理（即处理其它后续过滤器前<strong>该过滤器的前处理</strong>）4.放行给下一个过滤器处理5.请求调用后处理6.过滤器后处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FilterSecurityInterceptor类invoke方法源码分析</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(FilterInvocation filterInvocation)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">	<span class="comment">//1.检查是否已经经过安全校验（对于该用户的该请求）</span></span><br><span class="line">    <span class="keyword">if</span> (isApplied(filterInvocation) &amp;&amp; <span class="built_in">this</span>.observeOncePerRequest) &#123;</span><br><span class="line">        filterInvocation.getChain().doFilter(filterInvocation.getRequest(), filterInvocation.getResponse());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.设置请求属性已安全校验</span></span><br><span class="line">    <span class="keyword">if</span> (filterInvocation.getRequest() != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.observeOncePerRequest) &#123;</span><br><span class="line">        filterInvocation.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.过滤器访问控制前处理</span></span><br><span class="line">    <span class="type">InterceptorStatusToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="built_in">super</span>.beforeInvocation(filterInvocation);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//4.放行给下一个过滤器处理</span></span><br><span class="line">        filterInvocation.getChain().doFilter(filterInvocation.getRequest(), filterInvocation.getResponse());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">    	<span class="comment">//5.请求调用后处理，由于位于finally代码块，即使请求调用异常该方法仍然执行。</span></span><br><span class="line">        <span class="built_in">super</span>.finallyInvocation(token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.过滤器后处理</span></span><br><span class="line">    <span class="built_in">super</span>.afterInvocation(token, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用的重要方法：</p>
<ul>
<li>beforeInvocation</li>
<li>finallyInvocation</li>
<li>afterInvocation</li>
</ul>
<h3 id="10-3-beforeInvocation方法-鉴权核心"><a href="#10-3-beforeInvocation方法-鉴权核心" class="headerlink" title="10.3.beforeInvocation方法(鉴权核心)"></a>10.3.beforeInvocation方法(鉴权核心)</h3><p>AbstractSecurityInterceptor类beforeInvocation方法来进行安全检查校验权限。</p>
<p>方法来源：FilterSecurityInterceptor类的父类AbstractSecurityInterceptor。直接由FilterSecurityInterceptor调用super.beforeInvocation来调用父类的方法。</p>
<p>方法逻辑：1.查询获取配置的匹配该请求的权限规则2.无权限规则，则返回null3.校验是否已经认证，未认证抛出异常4.从SecurityContextHolder获取认证主体5.尝试授权6.返回一个封装SecurityContext、请求的安全规则、请求的InterceptorStatusToken</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractSecurityInterceptor类beforeInvocation方法源码分析</span></span><br><span class="line"><span class="keyword">protected</span> InterceptorStatusToken <span class="title function_">beforeInvocation</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="comment">//1.从DefaultFilterInvocationSecurityMetadataSource中查询获取配置的匹配该请求的权限规则</span></span><br><span class="line">	Collection&lt;ConfigAttribute&gt; attributes = <span class="built_in">this</span>.obtainSecurityMetadataSource().getAttributes(object);</span><br><span class="line">    <span class="comment">//2.无权限规则，则返回null</span></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(attributes)) &#123;</span><br><span class="line">        publishEvent(<span class="keyword">new</span> <span class="title class_">PublicInvocationEvent</span>(object));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// no further work post-invocation</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.校验是否已经认证，未认证抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() == <span class="literal">null</span>) &#123;</span><br><span class="line">credentialsNotFound(<span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;AbstractSecurityInterceptor.authenticationNotFound&quot;</span>,<span class="string">&quot;An Authentication object was not found in the SecurityContext&quot;</span>), object, attributes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.从SecurityContextHolder获取认证主体</span></span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">authenticated</span> <span class="operator">=</span> authenticateIfRequired();</span><br><span class="line">    <span class="comment">//5.尝试授权</span></span><br><span class="line">    attemptAuthorization(object, attributes, authenticated);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.publishAuthorizationSuccess) &#123;<span class="comment">//发布授权成功</span></span><br><span class="line">        publishEvent(<span class="keyword">new</span> <span class="title class_">AuthorizedEvent</span>(object, attributes, authenticated));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//默认runAsManager什么都不做返回null,可以自定义runAsManager</span></span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">runAs</span> <span class="operator">=</span> <span class="built_in">this</span>.runAsManager.buildRunAs(authenticated, object, attributes);</span><br><span class="line">    <span class="keyword">if</span> (runAs != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">SecurityContext</span> <span class="variable">origCtx</span> <span class="operator">=</span> SecurityContextHolder.getContext();</span><br><span class="line">        <span class="type">SecurityContext</span> <span class="variable">newCtx</span> <span class="operator">=</span> SecurityContextHolder.createEmptyContext();</span><br><span class="line">        newCtx.setAuthentication(runAs);</span><br><span class="line">        SecurityContextHolder.setContext(newCtx);</span><br><span class="line">        <span class="comment">// need to revert to token.Authenticated post-invocation</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InterceptorStatusToken</span>(origCtx, <span class="literal">true</span>, attributes, object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.返回一个封装SecurityContext、请求的安全规则、请求的InterceptorStatusToken</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InterceptorStatusToken</span>(SecurityContextHolder.getContext(), <span class="literal">false</span>, attributes, object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用的重要方法：</p>
<ul>
<li>getAttributes</li>
<li>attemptAuthorization</li>
</ul>
<h3 id="10-4-getAttributes方法"><a href="#10-4-getAttributes方法" class="headerlink" title="10.4.getAttributes方法"></a>10.4.getAttributes方法</h3><p>DefaultFilterInvocationSecurityMetadataSource类方法getAttributes来获取配置的该请求映射的安全规则集合。</p>
<p>方法来源：直接来源于DefaultFilterInvocationSecurityMetadataSource类。但由AbstractSecurityInterceptor类beforeInvocation方法调用，且调用时是基于<strong>SecurityMetadataSource接口</strong>调用具有<strong>多态</strong>的特性。默认使用该DefaultFilterInvocationSecurityMetadataSource类。</p>
<p>方法逻辑：1.获取请求2.遍历requestMap（代码生成）获取匹配该请求的权限规则3.没有相关权限规则返回null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultFilterInvocationSecurityMetadataSource类getAttributes方法源码解析</span></span><br><span class="line"><span class="keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="title function_">getAttributes</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="comment">//1.获取请求</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ((FilterInvocation) object).getRequest();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//2.遍历requestMap（代码生成）获取匹配该请求的安全规则</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;RequestMatcher, Collection&lt;ConfigAttribute&gt;&gt; entry : <span class="built_in">this</span>.requestMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getKey().matches(request)) &#123;</span><br><span class="line">            <span class="keyword">return</span> entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) &#123;<span class="comment">//日志打印不匹配的信息</span></span><br><span class="line">                <span class="built_in">this</span>.logger.trace(LogMessage.format(<span class="string">&quot;Did not match request to %s - %s (%d/%d)&quot;</span>, entry.getKey(),</span><br><span class="line">                        entry.getValue(), ++count, <span class="built_in">this</span>.requestMap.size()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.没有相关安全规则返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-5attemptAuthorization方法"><a href="#10-5attemptAuthorization方法" class="headerlink" title="10.5attemptAuthorization方法"></a>10.5attemptAuthorization方法</h3><p>AbstractSecurityInterceptor类方法attemptAuthorization来委托accessDecisionManager进行<strong>权限检查</strong>，即比对用户拥有的权限和访问该方法需要符合的安全规则。<strong>无权限就抛异常结束过滤器的处理</strong>。</p>
<p>方法来源：AbstractSecurityInterceptor类，由AbstractSecurityInterceptor类beforeInvocation方法调用。</p>
<p>方法逻辑：1.委托accessDecisionManager进行授权决策，无法授权就抛出异常2.异常时打印日志3.异常时发布授权失败消息4.再次抛出原异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractSecurityInterceptor类attemptAuthorization方法源码解析</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">attemptAuthorization</span><span class="params">(Object object, Collection&lt;ConfigAttribute&gt; attributes,</span></span><br><span class="line"><span class="params">        Authentication authenticated)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.委托accessDecisionManager进行授权决策，无法授权就抛出异常</span></span><br><span class="line">        <span class="built_in">this</span>.accessDecisionManager.decide(authenticated, object, attributes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AccessDeniedException ex) &#123;</span><br><span class="line">        <span class="comment">//2.打印Trace日志</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.trace(LogMessage.format(<span class="string">&quot;Failed to authorize %s with attributes %s using %s&quot;</span>, object,</span><br><span class="line">                    attributes, <span class="built_in">this</span>.accessDecisionManager));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.打印Debug日志</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.debug(LogMessage.format(<span class="string">&quot;Failed to authorize %s with attributes %s&quot;</span>, object, attributes));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.发布授权失败消息</span></span><br><span class="line">        publishEvent(<span class="keyword">new</span> <span class="title class_">AuthorizationFailureEvent</span>(object, attributes, authenticated, ex));</span><br><span class="line">        <span class="comment">//4.再次抛出原异常</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-6-decide方法"><a href="#10-6-decide方法" class="headerlink" title="10.6.decide方法"></a>10.6.decide方法</h3><p>AffirmativeBased类方法decide来进行授权决策（几个投票者如何投票代表成功授权），即解析该主体对该请求的访问权限。而AffirmativeBased是一种解析策略。</p>
<p>方法来源：默认调用AffirmativeBased类的decide。但此方法是源于AbstractSecurityInterceptor的attemptAuthorization方法调用，调用也是基于<strong>AccessDecisionManager接口</strong>调用，即this.accessDecisionManager.decide。</p>
<p>方法逻辑：1.遍历所有DecisionVoters来让它们投票，一旦有人投赞成票则授权成功（即有一种类型的配置权限合法）2.没有赞成票时，否定票&gt;0，授权失败抛出异常3.所有人弃权，依据配置AllowIfAllAbstainDecisions来决定是否授权成功</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decide</span><span class="params">(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes)</span><span class="keyword">throws</span> AccessDeniedException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">deny</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1.遍历所有DecisionVoters来让它们投票，一旦有人投赞成票则授权成功</span></span><br><span class="line">    <span class="keyword">for</span> (AccessDecisionVoter voter : getDecisionVoters()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> voter.vote(authentication, object, configAttributes);<span class="comment">//重要调用方法</span></span><br><span class="line">        <span class="keyword">switch</span> (result) &#123;</span><br><span class="line">        <span class="keyword">case</span> AccessDecisionVoter.ACCESS_GRANTED:</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//授权成功</span></span><br><span class="line">        <span class="keyword">case</span> AccessDecisionVoter.ACCESS_DENIED:</span><br><span class="line">            deny++;<span class="comment">//计数否定票</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.没有赞成票时，否定票&gt;0，授权失败抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (deny &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccessDeniedException</span>(</span><br><span class="line">                <span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;AbstractAccessDecisionManager.accessDenied&quot;</span>, <span class="string">&quot;Access is denied&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//3.所有人弃权，依据配置AllowIfAllAbstainDecisions来决定是否授权成功</span></span><br><span class="line">    checkAllowIfAllAbstainDecisions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AffirmativeBased默认包括的所有voters</strong>:</p>
<ul>
<li>PreInvocationAuthorizationAdviceVoter</li>
<li>RoleVoter</li>
<li>AuthenticatedVoter</li>
</ul>
<p>重要调用方法：voter.vote</p>
<h3 id="10-7-vote方法"><a href="#10-7-vote方法" class="headerlink" title="10.7.vote方法"></a>10.7.vote方法</h3><p>WebExpressionVoter类方法vote会执行真正的权限投票（权限对比检查）。</p>
<p>注意：在<strong>WebSecurityConfigurerAdapter子类配置的权限规则</strong>会被封装为WebExpressionConfigAttribute由<strong>WebExpressionVoter</strong>来进行处理；<strong>注解配置的权限规则</strong>会被封装成PreInvocationAttribute由<strong>PreInvocationAuthorizationAdviceVoter</strong>来进行处理；带“ROLE_”前缀的会被<strong>RoleVoter</strong>进行处理。</p>
<p>方法来源：WebExpressionVoter类。由AffirmativeBased类的decide方法调用。基于接口AccessDecisionVoter调用。</p>
<p>方法逻辑：1.从权限规则集合中提取该投票者能处理的权限规则2.没找到符合的返回弃权（没有使用该方法配置权限）3.构造EL表达式上下文4.使用ExpressionUtils工具类来判断EL表达式的值5.EL表达式为true返回授权成功6.否则返回授权失败</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WebExpressionVoter类vote方法源代码分析</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">vote</span><span class="params">(Authentication authentication, FilterInvocation filterInvocation,</span></span><br><span class="line"><span class="params">			Collection&lt;ConfigAttribute&gt; attributes)</span> &#123;</span><br><span class="line">    <span class="comment">//1.从权限规则集合中提取该投票者能处理的权限规则，即获取http配置项</span></span><br><span class="line">    <span class="type">WebExpressionConfigAttribute</span> <span class="variable">webExpressionConfigAttribute</span> <span class="operator">=</span> findConfigAttribute(attributes);</span><br><span class="line">    <span class="comment">//2.没找到符合的返回弃权</span></span><br><span class="line">    <span class="keyword">if</span> (webExpressionConfigAttribute == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ACCESS_ABSTAIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.构造EL表达式上下文</span></span><br><span class="line">    <span class="type">EvaluationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> webExpressionConfigAttribute.postProcess(</span><br><span class="line">            <span class="built_in">this</span>.expressionHandler.createEvaluationContext(authentication, filterInvocation), filterInvocation);</span><br><span class="line">    <span class="comment">//4.使用ExpressionUtils工具类来判断EL表达式的值（这里是EL表达式的难点）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">granted</span> <span class="operator">=</span> ExpressionUtils.evaluateAsBoolean(webExpressionConfigAttribute.getAuthorizeExpression(), ctx);</span><br><span class="line">    <span class="comment">//5.EL表达式为true返回授权成功</span></span><br><span class="line">    <span class="keyword">if</span> (granted) &#123;</span><br><span class="line">        <span class="keyword">return</span> ACCESS_GRANTED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.否则返回授权失败</span></span><br><span class="line">    <span class="built_in">this</span>.logger.trace(<span class="string">&quot;Voted to deny authorization&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ACCESS_DENIED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> WebExpressionConfigAttribute <span class="title function_">findConfigAttribute</span><span class="params">(Collection&lt;ConfigAttribute&gt; attributes)</span> &#123;</span><br><span class="line">    <span class="comment">//遍历所有权限规则找第一个符合要求的，在一个地方重复配置会被第一个权限规则覆盖</span></span><br><span class="line">    <span class="keyword">for</span> (ConfigAttribute attribute : attributes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (attribute <span class="keyword">instanceof</span> WebExpressionConfigAttribute) &#123;</span><br><span class="line">            <span class="keyword">return</span> (WebExpressionConfigAttribute) attribute;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-8-finallyInvocation方法"><a href="#10-8-finallyInvocation方法" class="headerlink" title="10.8.finallyInvocation方法"></a>10.8.finallyInvocation方法</h3><p>AbstractSecurityInterceptor类方法finallyInvocation来处理是否更新SecurityContext。该方法只要通过了授权就会被调用，即使请求调用抛出了异常。</p>
<p>方法来源：AbstractSecurityInterceptor类，由FilterSecurityInterceptor调用super.beforeInvocation来调用父类的方法。</p>
<p>方法逻辑：授权后令牌不为null且isContextHolderRefreshRequired设置为true时更新ecurityContext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractSecurityInterceptor类finallyInvocation方法源码解析</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finallyInvocation</span><span class="params">(InterceptorStatusToken token)</span> &#123;</span><br><span class="line">    <span class="comment">//授权后令牌不为null且isContextHolderRefreshRequired设置为true时更新ecurityContext</span></span><br><span class="line">    <span class="keyword">if</span> (token != <span class="literal">null</span> &amp;&amp; token.isContextHolderRefreshRequired()) &#123;</span><br><span class="line">        SecurityContextHolder.setContext(token.getSecurityContext());</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.debug(LogMessage.of(</span><br><span class="line">                    () -&gt; <span class="string">&quot;Reverted to original authentication &quot;</span> + token.getSecurityContext().getAuthentication()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-9-afterInvocation方法"><a href="#10-9-afterInvocation方法" class="headerlink" title="10.9.afterInvocation方法"></a>10.9.afterInvocation方法</h3><p>AbstractSecurityInterceptor类方法afterInvocation来进行过滤器后处理。</p>
<p>方法来源：AbstractSecurityInterceptor类，由FilterSecurityInterceptor调用super.afterInvocation来调用父类的方法。</p>
<p>方法逻辑：1.若无需权限就直接返回null无处理2.清理SecurityContext3.若afterInvocationManager存在，委托afterInvocationManager进行过滤器后处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractSecurityInterceptor类afterInvocation方法源码解析</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">afterInvocation</span><span class="params">(InterceptorStatusToken token, Object returnedObject)</span> &#123;</span><br><span class="line">    <span class="comment">//1.若无需权限就直接返回null无处理</span></span><br><span class="line">    <span class="keyword">if</span> (token == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// public object</span></span><br><span class="line">        <span class="keyword">return</span> returnedObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.清理SecurityContext</span></span><br><span class="line">    finallyInvocation(token); <span class="comment">// continue to clean in this method for passivity</span></span><br><span class="line">    <span class="comment">//3.若afterInvocationManager存在，委托afterInvocationManager进行过滤器后处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.afterInvocationManager != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Attempt after invocation handling</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            returnedObject = <span class="built_in">this</span>.afterInvocationManager.decide(token.getSecurityContext().getAuthentication(),</span><br><span class="line">                    token.getSecureObject(), token.getAttributes(), returnedObject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AccessDeniedException ex) &#123;</span><br><span class="line">            publishEvent(<span class="keyword">new</span> <span class="title class_">AuthorizationFailureEvent</span>(token.getSecureObject(), token.getAttributes(),</span><br><span class="line">                    token.getSecurityContext().getAuthentication(), ex));</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回null或后处理结果</span></span><br><span class="line">    <span class="keyword">return</span> returnedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-10-详细的授权流程时序图"><a href="#10-10-详细的授权流程时序图" class="headerlink" title="10.10.详细的授权流程时序图"></a>10.10.详细的授权流程时序图</h3><p>![spring security授权过程分析](spring security授权过程分析.png)</p>
<blockquote>
<p>FilterSecurityInterceptor过滤器原理为servlet过滤器，实现了请求路径过滤器层面的权限控制，请求路径权限配置来源于Spring Security的配置类。</p>
</blockquote>
<h2 id="16-MethodSecurityInterceptor（重点）"><a href="#16-MethodSecurityInterceptor（重点）" class="headerlink" title="16.MethodSecurityInterceptor（重点）"></a>16.MethodSecurityInterceptor（重点）</h2><p><strong>拦截方法调用并在拒绝请求时抛出异常</strong>。这个<strong>拦截器</strong>决定了访问特定<strong>方法</strong>应具备的权限，如果要实现动态权限控制就必须研究该类。</p>
<p><strong>只处理注解AOP层面的权限控制，不处理过滤器层面的权限控制</strong>。</p>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">   <span class="comment">//1.委托 beforeInvocation 执行“鉴权”过滤逻辑</span></span><br><span class="line">   <span class="type">InterceptorStatusToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="built_in">super</span>.beforeInvocation(mi);</span><br><span class="line">   Object result;</span><br><span class="line">   <span class="comment">//2.执行方法调用</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      result = mi.proceed();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//3.方法调用结束后执行</span></span><br><span class="line">      <span class="built_in">super</span>.finallyInvocation(token);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//4.方法调用完成后执行 </span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">super</span>.afterInvocation(token, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 FilterSecurityInterceptor 继承的同一个父类 <code>AbstractSecurityInterceptor</code> 。其逻辑源码与 FilterSecurityInterceptor 几乎一样，但是其 <code>SecurityMetadataSource</code> 的真实类型与之不同，是 <code>MethodSecurityMetadataSource</code> 类型。类图如下：</p>
<p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20240224175844626.png" alt="image-20240224175844626"></p>
<p>即<strong>拦截器的权限数据源</strong>与FilterSecurityInterceptor 过滤器的数据源不同，<strong>拦截器的权限数据源来源于方法上的注解</strong>。总结拦截器数据源有如下<strong>四种</strong>：</p>
<p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20240224181132139.png" alt="image-20240224181132139"></p>
<p>而<strong>过滤器数据源</strong>只有<strong>一种</strong>：ExpressionBasedFilterInvocationSecurityMetadataSource</p>
<p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20240224181443840.png" alt="image-20240224181443840"></p>
<p>以上拦截器 <code>MethodSecurityInterceptor</code> 与 <code>MethodSecurityMetadataSource</code> 都是由 <code>GlobalMethodSecurityConfiguration</code> 配置类装配到IOC容器的。源码比较多，这里就不分析了还是比较简单。</p>
<blockquote>
<p>MethodSecurityInterceptor拦截器原理为AOP，实现了方法层面的权限控制，方法权限配置来源于注解和xml配置文件。</p>
</blockquote>
<h1 id="二、注解解析"><a href="#二、注解解析" class="headerlink" title="二、注解解析"></a>二、注解解析</h1><h2 id="1-EnableWebSecurity"><a href="#1-EnableWebSecurity" class="headerlink" title="1.EnableWebSecurity"></a>1.EnableWebSecurity</h2><p>在非<code>Springboot</code>的应用中，该注解<code>@EnableWebSecurity</code>需要开发人员自己引入以启用<code>Web</code>安全。</p>
<p><strong>在<code>Springboot</code>的应用中,开发人员没有必要再次引用该注解</strong>，<code>Springboot</code>的自动配置机制<code>WebSecurityEnablerConfiguration</code>已经引入了该注解。</p>
<p><code>@EnableWebSecurity</code>引入了WebSecurityConfiguration、<code>HttpSecurityConfiguration</code>、AuthenticationConfiguration的bean对象和SpringWebMvcImportSelector、OAuth2ImportSelector选择引入的bean对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Import(&#123; WebSecurityConfiguration.class, SpringWebMvcImportSelector.class, OAuth2ImportSelector.class,</span><br><span class="line">      HttpSecurityConfiguration.class &#125;)</span><br><span class="line">@EnableGlobalAuthentication</span><br></pre></td></tr></table></figure>

<p>其中 <code>HttpSecurityConfiguration</code> 的装配最重要，它帮我们装配了一个默认的 <code>HttpSecurity</code> 组件，这是配置Spring Security的关键组件。其中对 HttpSecurity 组件进行了默认的配置，<strong>配置开启了许多的过滤器组件</strong>，这些<strong>过滤器在 HttpSecurity .build() 时创建</strong>。</p>
<blockquote>
<p>springboot应用无需使用这个注解。它帮我们准备好了许多默认的过滤器组件，我们只需要httpSecurity.build()就可以使<strong>Http安全相关过滤器</strong>注入生效。它还帮我们调用了webSecurity.build()装配好了<strong>web安全相关的过滤器</strong>。</p>
<p>注意：<strong>先执行httpSecurity.build()再执行webSecurity.build()。webSecurity层次更高。</strong></p>
</blockquote>
<h1 id="三、组件解析"><a href="#三、组件解析" class="headerlink" title="三、组件解析"></a>三、组件解析</h1><h2 id="1-DelegatingFilterProxy"><a href="#1-DelegatingFilterProxy" class="headerlink" title="1.DelegatingFilterProxy"></a>1.DelegatingFilterProxy</h2><p><strong>用于给Servlet Filter做代理</strong>(代理方)，代理到 spring bean（被代理方），这样可以将spring bean中的过滤器通过 <code>DelegatingFilterProxy</code> 来注册到servlet容器的过滤器中。</p>
<p><code>DelegatingFilterProxy</code> 是由 <code>DelegatingFilterProxyRegistrationBean</code> 来创建的，并将其注册到 Servlet 容器中。而这个注册bean是由 <code>SecurityFilterAutoConfiguration</code> 自动配置类装配的。</p>
<p>所以依赖关系如下：<code>DelegatingFilterProxy</code>  –&gt;  <code>DelegatingFilterProxyRegistrationBean</code> –&gt;  <code>SecurityFilterAutoConfiguration</code></p>
<p><strong>DelegatingFilterProxy</strong>：用于给Servlet Filter做代理。代理的 targetBeanName 名字为 “springSecurityFilterChain”。</p>
<p><strong>DelegatingFilterProxyRegistrationBean</strong>：用于注册 Servlet filter。</p>
<p><strong>SecurityFilterAutoConfiguration</strong>：用于装配 DelegatingFilterProxyRegistrationBean 到 IOC容器。</p>
<h2 id="2-FilterChainProxy"><a href="#2-FilterChainProxy" class="headerlink" title="2. FilterChainProxy"></a>2. FilterChainProxy</h2><p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20240225140054659.png" alt="image-20240225140054659"></p>
<p>是一个代理类，代理了 <code>List&lt;SecurityFilterChain&gt; filterChains</code> 多个 <code>SecurityFilterChain</code> 。同时这个对象被注入到DelegatingFilterProxy对象。</p>
<p><strong>FilterChainProxy由 WebSecurity.buid() 创建出来</strong>。并<strong>由 <code>WebSecurityConfiguration</code> 配置类来控制这个构建过程</strong>。这个组件会将程序中所有由 httpSecurity.build() 构建的 SecurityFilterChain 全部重新整合构建为 <code>FilterChainProxy</code>。</p>
<blockquote>
<p><strong>The WebSecurity is created by WebSecurityConfiguration to create the FilterChainProxy</strong> known as the Spring Security Filter Chain (<strong>springSecurityFilterChain</strong>). The springSecurityFilterChain is the Filter that the DelegatingFilterProxy delegates to.</p>
<p>所以 <strong>WebSecurityConfiguration 组件控制了 FilterChainProxy 的创建过程！</strong></p>
</blockquote>
<h2 id="3-SecurityFilterChain"><a href="#3-SecurityFilterChain" class="headerlink" title="3.SecurityFilterChain"></a>3.SecurityFilterChain</h2><p>是一个过滤器链，其中又包含多个过滤器对象。并被 <code>FilterChainProxy</code> 所使用。</p>
<p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20240225155634811.png" alt="image-20240225155634811"></p>
<p><strong>SecurityFilterChain由 http.build()创建出来</strong>。当然 webSecurity在构建 FilterChainProxy 过程中也会创建SecurityFilterChain。但这里主要是指我们自定义的配置类控制 HttpSecurity 创建 SecurityFilterChain。</p>
<p>我们可以对 <strong>HttpSecurity 调用 requestMatcher() 方法控制此过滤链匹配的路径</strong>，但<strong>默认是匹配所有路径</strong>。</p>
<blockquote>
<p>HttpSecurityConfiguration创建了默认的 HttpSecurity 组件，但并没有通过HttpSecurity创建SecurityFilterChain。</p>
<p>所以我们自己配置的组件控制了 SecurityFilterChain 的创建过程。</p>
</blockquote>
<h2 id="4-WebSecurityConfiguration和WebSecurity"><a href="#4-WebSecurityConfiguration和WebSecurity" class="headerlink" title="4.WebSecurityConfiguration和WebSecurity"></a>4.WebSecurityConfiguration和WebSecurity</h2><p>WebSecurityConfiguration 是 Spring Security的配置类。</p>
<ol>
<li><strong>注入了</strong>容器中<strong>所有的 SecurityFilterChain 组件</strong></li>
<li>使用ObjectPostProcessor组件<strong>创建了 webSecurity 组件</strong></li>
<li>使用 webSecurity组件和所有的 SecurityFilterChain 组件 <strong>创建了 FilterChainProxy</strong>。</li>
</ol>
<p><strong>WebSecurity组件实现了具体构建 FilterChainProxy的逻辑。</strong></p>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)</span></span><br><span class="line"><span class="keyword">public</span> Filter <span class="title function_">springSecurityFilterChain</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">hasConfigurers</span> <span class="operator">=</span> <span class="built_in">this</span>.webSecurityConfigurers != <span class="literal">null</span> &amp;&amp; !<span class="built_in">this</span>.webSecurityConfigurers.isEmpty();</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">hasFilterChain</span> <span class="operator">=</span> !<span class="built_in">this</span>.securityFilterChains.isEmpty();</span><br><span class="line">   。。。</span><br><span class="line">   <span class="keyword">if</span> (!hasConfigurers &amp;&amp; !hasFilterChain) &#123;</span><br><span class="line">      <span class="type">WebSecurityConfigurerAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="built_in">this</span>.objectObjectPostProcessor</span><br><span class="line">            .postProcess(<span class="keyword">new</span> <span class="title class_">WebSecurityConfigurerAdapter</span>() &#123;</span><br><span class="line">            &#125;);</span><br><span class="line">      <span class="built_in">this</span>.webSecurity.apply(adapter);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//1.遍历所有的过滤器链 </span></span><br><span class="line">   <span class="keyword">for</span> (SecurityFilterChain securityFilterChain : <span class="built_in">this</span>.securityFilterChains) &#123;</span><br><span class="line">      <span class="comment">//2.将过滤器链添加到 webSecurity，准备重新整合构建</span></span><br><span class="line">      <span class="built_in">this</span>.webSecurity.addSecurityFilterChainBuilder(() -&gt; securityFilterChain);</span><br><span class="line">      <span class="comment">//遍历过滤器，将 FilterSecurityInterceptor 过滤器设置到 webSecurity属性中</span></span><br><span class="line">      <span class="keyword">for</span> (Filter filter : securityFilterChain.getFilters()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (filter <span class="keyword">instanceof</span> FilterSecurityInterceptor) &#123;</span><br><span class="line">            <span class="built_in">this</span>.webSecurity.securityInterceptor((FilterSecurityInterceptor) filter);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (WebSecurityCustomizer customizer : <span class="built_in">this</span>.webSecurityCustomizers) &#123;</span><br><span class="line">      customizer.customize(<span class="built_in">this</span>.webSecurity);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3.整合构建，最终会创建出 FilterChainProxy 对象。</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.webSecurity.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-HttpSecurityConfiguration和HttpSecurity"><a href="#5-HttpSecurityConfiguration和HttpSecurity" class="headerlink" title="5.HttpSecurityConfiguration和HttpSecurity"></a>5.HttpSecurityConfiguration和HttpSecurity</h2><p>HttpSecurityConfiguration是 Spring Security的配置类。主要就<strong>创建了 HttpSecurity 组件</strong>。内部<strong>对HttpSecurity进行了一些默认配置，配置了默认的过滤器链在构建时生效</strong>。</p>
<p><strong>HttpSecurity组件实现了具体构建 SecurityFilterChain/DefaultSecurityFilterChain 的逻辑。</strong>还具有许多方法可以灵活的配置过滤器和权限规则。</p>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(HTTPSECURITY_BEAN_NAME)</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">HttpSecurity <span class="title function_">httpSecurity</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   。。。</span><br><span class="line">   <span class="comment">//1.创建了 HttpSecurity对象    </span></span><br><span class="line">   <span class="type">HttpSecurity</span> <span class="variable">http</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpSecurity</span>(<span class="built_in">this</span>.objectPostProcessor, authenticationBuilder, createSharedObjects());</span><br><span class="line">   <span class="comment">//2.配置了 HttpSecurity对象</span></span><br><span class="line">   http</span><br><span class="line">      .csrf(withDefaults()) <span class="comment">//csrf过滤器</span></span><br><span class="line">      .addFilter(<span class="keyword">new</span> <span class="title class_">WebAsyncManagerIntegrationFilter</span>()) <span class="comment">//WebAsyncManagerIntegrationFilter过滤器</span></span><br><span class="line">      .exceptionHandling(withDefaults()) <span class="comment">//ExceptionTranslationFilter</span></span><br><span class="line">      .headers(withDefaults()) <span class="comment">//HeaderWriterFilter</span></span><br><span class="line">      .sessionManagement(withDefaults()) <span class="comment">//SessionManagementFilter、ConcurrentSessionFilter</span></span><br><span class="line">      .securityContext(withDefaults()) <span class="comment">//SecurityContextPersistenceFilter</span></span><br><span class="line">      .requestCache(withDefaults()) <span class="comment">//RequestCacheAwareFilter</span></span><br><span class="line">      .anonymous(withDefaults()) <span class="comment">//AnonymousAuthenticationFilter</span></span><br><span class="line">      .servletApi(withDefaults()) <span class="comment">//SecurityContextHolderAwareRequestFilter</span></span><br><span class="line">      .apply(<span class="keyword">new</span> <span class="title class_">DefaultLoginPageConfigurer</span>&lt;&gt;()); </span><br><span class="line">   http.logout(withDefaults()); <span class="comment">//LogoutFilter</span></span><br><span class="line">   applyDefaultConfigurers(http);</span><br><span class="line">   <span class="keyword">return</span> http;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="6-SecurityAutoConfiguration"><a href="#6-SecurityAutoConfiguration" class="headerlink" title="6.SecurityAutoConfiguration"></a>6.SecurityAutoConfiguration</h2><p><strong>是 Spring Boot 的自动配置类</strong>。为我们引入了组件 <code>SpringBootWebSecurityConfiguration</code> 和 <code>SecurityDataConfiguration</code> ，还引入了 <code>DefaultAuthenticationEventPublisher</code> 认证事件发布组件。</p>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfiguration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DefaultAuthenticationEventPublisher.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(SecurityProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; SpringBootWebSecurityConfiguration.class, SecurityDataConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean(AuthenticationEventPublisher.class)</span></span><br><span class="line">   <span class="keyword">public</span> DefaultAuthenticationEventPublisher <span class="title function_">authenticationEventPublisher</span><span class="params">(ApplicationEventPublisher publisher)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultAuthenticationEventPublisher</span>(publisher);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-SpringBootWebSecurityConfiguration"><a href="#7-SpringBootWebSecurityConfiguration" class="headerlink" title="7.SpringBootWebSecurityConfiguration"></a>7.SpringBootWebSecurityConfiguration</h2><p><strong>是 Spring Boot 的自动配置类</strong>。</p>
<ol>
<li>如果我们没有配置 SecurityFilterChain 组件，会为我们<strong>默认配置一个 <code>SecurityFilterChain</code> 组件</strong>，否则就不配置。</li>
<li><strong>配置一个 ErrorPageSecurityFilter 过滤器</strong>到 servlet filter 中。</li>
<li><strong>使用注解 @EnableWebSecurity</strong>。</li>
</ol>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnDefaultWebSecurity</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SecurityFilterChainConfiguration</span> &#123;</span><br><span class="line">	<span class="comment">//默认提供的 SecurityFilterChain</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@Order(SecurityProperties.BASIC_AUTH_ORDER)</span></span><br><span class="line">   SecurityFilterChain <span class="title function_">defaultSecurityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      http.authorizeRequests().anyRequest().authenticated();</span><br><span class="line">      http.formLogin();</span><br><span class="line">      http.httpBasic();</span><br><span class="line">      <span class="keyword">return</span> http.build();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="8-SecurityFilterAutoConfiguration"><a href="#8-SecurityFilterAutoConfiguration" class="headerlink" title="8.SecurityFilterAutoConfiguration"></a>8.SecurityFilterAutoConfiguration</h2><p><strong>是 Spring Boot 的自动配置类</strong>。用于注册过滤链集合到 servlet filter中。</p>
<p>实际上为我们装配了一个组件 <code>DelegatingFilterProxyRegistrationBean</code> 来用于注册过滤器。</p>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(name = DEFAULT_FILTER_NAME)</span></span><br><span class="line"><span class="keyword">public</span> DelegatingFilterProxyRegistrationBean <span class="title function_">securityFilterChainRegistration</span><span class="params">(</span></span><br><span class="line"><span class="params">      SecurityProperties securityProperties)</span> &#123;</span><br><span class="line">   <span class="type">DelegatingFilterProxyRegistrationBean</span> <span class="variable">registration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegatingFilterProxyRegistrationBean</span>(</span><br><span class="line">         DEFAULT_FILTER_NAME);</span><br><span class="line">   registration.setOrder(securityProperties.getFilter().getOrder());</span><br><span class="line">   registration.setDispatcherTypes(getDispatcherTypes(securityProperties));</span><br><span class="line">   <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="四、无配置引入"><a href="#四、无配置引入" class="headerlink" title="四、无配置引入"></a>四、无配置引入</h1><h2 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h2><ol>
<li>引入依赖，版本由spring boot版本管理。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.引入后就可以立即启动。</p>
<p>此时默认所有路径都需要认证，都会经过<code>UsernamePasswordAuthenticationFilter</code>过滤器，默认有登录页面。</p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>以上效果是<strong>Spring Boot自动装配</strong>导致的，自动装配的配置类为<code>org.springframework.boot.autoconfigure.security.servlet.SpringBootWebSecurityConfiguration</code>。默认情况下它会创建一个<code>SecurityFilterChain</code>过滤链组件。组件<code>SecurityFilterChain</code>依赖于<code>HttpSecurity</code>组件。</p>
<p>源码分析如下：</p>
<p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20240223160414470.png" alt="image-20240223160414470"></p>
<p>代码 <code>http.authorizeRequests().anyRequest().authenticated();</code> 配置了<strong>所有请求都需要认证</strong>。</p>
<p>代码 <code>http.formLogin();</code> 配置了将FormLoginConfigurer加入HttpSecurity，请求经过 <code>UsernamePasswordAuthenticationFilter</code> 过滤器来进行认证，同时由于未配置登录页路径会**使用默认登录页”/login”**。</p>
<p>代码 <code>http.httpBasic();</code> 配置了将HttpBasicConfigurer加入HttpSecurity，请求经过 <code>BasicAuthenticationFilter</code> 过滤器来进行<strong>HTTP Basic认证</strong>。</p>
<p>代码 <code>http.build();</code> 根据以上代码来<strong>装配spring security的过滤链并返回SecurityFilterChain组件</strong>。</p>
<p>默认情况下，Spring Boot <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/servlet/UserDetailsServiceAutoConfiguration.java">UserDetailsServiceAutoConfiguration</a> 自动化配置类，会创建一个<strong>内存级别</strong>的 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-security/blob/master/core/src/main/java/org/springframework/security/provisioning/InMemoryUserDetailsManager.java">InMemoryUserDetailsManager</a> Bean 对象，提供认证的用户信息。</p>
<blockquote>
<p> 以上我们分析了默认的SecurityFilterChain组件，这是Spring Boot默认为我们装配的。实际上我们需要自己配置一个SecurityFilterChain 组件或者 WebSecurityConfigurerAdapter 组件来覆盖此默认装配的组件。</p>
</blockquote>
<hr>
<h1 id="五、配置引入"><a href="#五、配置引入" class="headerlink" title="五、配置引入"></a>五、配置引入</h1><h2 id="代码实践-1"><a href="#代码实践-1" class="headerlink" title="代码实践"></a>代码实践</h2><ol>
<li>引入依赖，版本由spring boot版本管理。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.配置组件。</p>
<p><strong>配置Spring Security需要的组件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityComponentConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义的认证失败处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationEntryPoint <span class="title function_">authenticationEntryPoint</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AuthenticationEntryPointImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义的权限不够处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AccessDeniedHandler <span class="title function_">accessDeniedHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AccessDeniedHandlerImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义的认证过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TokenAuthenticationFilter <span class="title function_">tokenAuthenticationFilter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TokenAuthenticationFilter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意在自定我们自己的Spring Security过滤器时，最好<strong>不要将过滤器注入IOC容器中</strong>，如果注入后spring boot会再次将此过滤器注册到servelet容器中，导致过滤器执行两次，如果我们一定要注入到IOC容器中我们可以控制spring boot不要注册此过滤器到servlet容器，代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> FilterRegistrationBean&lt;TenantFilter&gt; <span class="title function_">tenantFilterRegistration</span><span class="params">(TenantFilter filter)</span> &#123;</span><br><span class="line">    FilterRegistrationBean&lt;TenantFilter&gt; registration = <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>&lt;&gt;(filter);</span><br><span class="line">    <span class="comment">//不要注册此过滤器到servlet容器！！！</span></span><br><span class="line">    registration.setEnabled(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置Spring Security自身过滤器组件、添加过滤器组件、自身url的访问控制</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AccessDeniedHandler accessDeniedHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationEntryPoint authenticationEntryPoint;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TokenAuthenticationFilter tokenAuthenticationFilter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity httpSecurity)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.配置过滤器</span></span><br><span class="line">        httpSecurity</span><br><span class="line">                <span class="comment">// 开启跨域</span></span><br><span class="line">                .cors().and()</span><br><span class="line">                <span class="comment">// CSRF 禁用，因为不使用 Session</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">// 配置会话。基于 token 机制，所以不需要 Session，且一个用户只能有一个会话</span></span><br><span class="line">                .sessionManagement().maximumSessions(<span class="number">1</span>).expiredUrl(<span class="string">&quot;/auth/logion&quot;</span>).and()</span><br><span class="line">                                    .sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()</span><br><span class="line">                <span class="comment">// 配置响应头header。</span></span><br><span class="line">                .headers().frameOptions().disable().and()</span><br><span class="line">                <span class="comment">// 配置异常过滤器</span></span><br><span class="line">                .exceptionHandling().authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">                                    .accessDeniedHandler(accessDeniedHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.添加过滤器</span></span><br><span class="line">        httpSecurity.addFilterBefore(tokenAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得 @PermitAll 带来的 URL 列表，免登录</span></span><br><span class="line">        Multimap&lt;HttpMethod, String&gt; permitAllUrls = getPermitAllUrlsFromAnnotations();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.配置基于url的访问控制</span></span><br><span class="line">        httpSecurity</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 静态资源，可匿名访问</span></span><br><span class="line">                .antMatchers(HttpMethod.GET, <span class="string">&quot;/*.html&quot;</span>, <span class="string">&quot;/**/*.html&quot;</span>, <span class="string">&quot;/**/*.css&quot;</span>, <span class="string">&quot;/**/*.js&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">// 设置 @PermitAll 无需认证</span></span><br><span class="line">                .antMatchers(HttpMethod.GET, permitAllUrls.get(HttpMethod.GET).toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>])).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.POST, permitAllUrls.get(HttpMethod.POST).toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>])).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.PUT, permitAllUrls.get(HttpMethod.PUT).toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>])).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.DELETE, permitAllUrls.get(HttpMethod.DELETE).toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>])).permitAll()</span><br><span class="line">                <span class="comment">// 设置aj验证码的cotroller请求无需认证</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/captcha/get&quot;</span>, <span class="string">&quot;/captcha/check&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">// 兜底规则，必须认证</span></span><br><span class="line">                .and().authorizeRequests()</span><br><span class="line">                        .anyRequest().authenticated();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> httpSecurity.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过<span class="doctag">@PermitAlll</span>注解获取被注解的url集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Multimap&lt;HttpMethod, String&gt; <span class="title function_">getPermitAllUrlsFromAnnotations</span><span class="params">()</span> &#123;</span><br><span class="line">        Multimap&lt;HttpMethod, String&gt; result = HashMultimap.create();</span><br><span class="line">        <span class="comment">// 获得接口对应的 HandlerMethod 集合</span></span><br><span class="line">        <span class="type">RequestMappingHandlerMapping</span> <span class="variable">requestMappingHandlerMapping</span> <span class="operator">=</span> (RequestMappingHandlerMapping)</span><br><span class="line">                applicationContext.getBean(<span class="string">&quot;requestMappingHandlerMapping&quot;</span>);</span><br><span class="line">        Map&lt;RequestMappingInfo, HandlerMethod&gt; handlerMethodMap = requestMappingHandlerMapping.getHandlerMethods();</span><br><span class="line">        <span class="comment">// 获得有 @PermitAll 注解的接口</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;RequestMappingInfo, HandlerMethod&gt; entry : handlerMethodMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (!handlerMethod.hasMethodAnnotation(PermitAll.class)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (entry.getKey().getPatternsCondition() == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;String&gt; urls = entry.getKey().getPatternsCondition().getPatterns();</span><br><span class="line">            <span class="comment">// 特殊：使用 @RequestMapping 注解，并且未写 method 属性，此时认为都需要免登录</span></span><br><span class="line">            Set&lt;RequestMethod&gt; methods = entry.getKey().getMethodsCondition().getMethods();</span><br><span class="line">            <span class="keyword">if</span> (CollUtil.isEmpty(methods)) &#123;</span><br><span class="line">                result.putAll(HttpMethod.GET, urls);</span><br><span class="line">                result.putAll(HttpMethod.POST, urls);</span><br><span class="line">                result.putAll(HttpMethod.PUT, urls);</span><br><span class="line">                result.putAll(HttpMethod.DELETE, urls);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据请求方法，添加到 result 结果</span></span><br><span class="line">            entry.getKey().getMethodsCondition().getMethods().forEach(requestMethod -&gt; &#123;</span><br><span class="line">                <span class="keyword">switch</span> (requestMethod) &#123;</span><br><span class="line">                    <span class="keyword">case</span> GET:</span><br><span class="line">                        result.putAll(HttpMethod.GET, urls);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> POST:</span><br><span class="line">                        result.putAll(HttpMethod.POST, urls);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> PUT:</span><br><span class="line">                        result.putAll(HttpMethod.PUT, urls);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> DELETE:</span><br><span class="line">                        result.putAll(HttpMethod.DELETE, urls);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="六、还未完成，持续更新"><a href="#六、还未完成，持续更新" class="headerlink" title="六、还未完成，持续更新"></a>六、还未完成，持续更新</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://featherbrainna.github.io">wzy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://featherbrainna.github.io/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/">https://featherbrainna.github.io/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://featherbrainna.github.io" target="_blank">淡云月来去</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring-Security/">Spring Security</a></div><div class="post_share"><div class="social-share" data-image="/./img/butterfly.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2024/02/14/%E5%85%B3%E4%BA%8E%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF%E9%82%A3%E4%BA%9B%E4%BA%8B/"><img class="prev-cover" src="/./img/bg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">关于部署上线那些事</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">wzy</div><div class="author-info__description">java知识分享、个人博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/featherbrainna"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/featherbrainna" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:578996401@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=or3qBLP2W6fec06prAHhrNj-ldIc-qHH&amp;noverify=0&amp;personal_qrcode_source=4" target="_blank" title=""><i class="fa-brands fa-qq"></i></a><a class="social-icon" href="https://weibo.com/u/6536962254" target="_blank" title=""><i class="fa-brands fa-weibo"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8%E8%A7%A3%E6%9E%90"><span class="toc-text">一、过滤器解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-ChannelProcessingFilter"><span class="toc-text">1.ChannelProcessingFilter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-WebAsyncManagerIntegrationFilter"><span class="toc-text">2.WebAsyncManagerIntegrationFilter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-SecurityContextPersistenceFilter"><span class="toc-text">3.SecurityContextPersistenceFilter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-HeaderWriterFilter"><span class="toc-text">4.HeaderWriterFilter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-CorsFilter"><span class="toc-text">5.CorsFilter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-LogoutFilter"><span class="toc-text">6.LogoutFilter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-ConcurrentSessionFilter"><span class="toc-text">7.ConcurrentSessionFilter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-UsernamePasswordAuthenticationFilter"><span class="toc-text">8.UsernamePasswordAuthenticationFilter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-doFilter%E6%96%B9%E6%B3%95"><span class="toc-text">4.1.doFilter方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-attemptAuthentication%E6%96%B9%E6%B3%95"><span class="toc-text">4.2.attemptAuthentication方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-ProviderManager%E7%B1%BBauthenticate%E6%96%B9%E6%B3%95"><span class="toc-text">4.3.ProviderManager类authenticate方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-AbstractUserDetailsAuthenticationProvider%E7%B1%BBauthenticate%E6%96%B9%E6%B3%95"><span class="toc-text">4.4.AbstractUserDetailsAuthenticationProvider类authenticate方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-retrieveUser%E6%96%B9%E6%B3%95"><span class="toc-text">4.5.retrieveUser方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-createSuccessAuthentication%E6%96%B9%E6%B3%95"><span class="toc-text">4.6.createSuccessAuthentication方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-successfulAuthentication%E6%96%B9%E6%B3%95"><span class="toc-text">4.7.successfulAuthentication方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-%E5%AD%90%E7%B1%BBonAuthenticationSuccess%E6%96%B9%E6%B3%95"><span class="toc-text">4.8.子类onAuthenticationSuccess方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-%E7%88%B6%E7%B1%BBonAuthenticationSuccess%E6%96%B9%E6%B3%95"><span class="toc-text">4.9.父类onAuthenticationSuccess方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-%E8%AF%A6%E7%BB%86%E7%9A%84%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E6%97%B6%E5%BA%8F%E5%9B%BE"><span class="toc-text">4.10.详细的认证流程时序图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-RequestCacheAwareFilter"><span class="toc-text">9.RequestCacheAwareFilter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-SecurityContextHolderAwareRequestFilter"><span class="toc-text">10.SecurityContextHolderAwareRequestFilter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-RememberMeAuthenticationFilter"><span class="toc-text">11.RememberMeAuthenticationFilter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-AnonymousAuthenticationFilter"><span class="toc-text">12.AnonymousAuthenticationFilter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-SessionManagementFilter"><span class="toc-text">13.SessionManagementFilter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-ExceptionTranslationFilter"><span class="toc-text">14.ExceptionTranslationFilter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-FilterSecurityInterceptor%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">15.FilterSecurityInterceptor（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-doFilter%E6%96%B9%E6%B3%95"><span class="toc-text">10.1.doFilter方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-invoke%E6%96%B9%E6%B3%95"><span class="toc-text">10.2.invoke方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-beforeInvocation%E6%96%B9%E6%B3%95-%E9%89%B4%E6%9D%83%E6%A0%B8%E5%BF%83"><span class="toc-text">10.3.beforeInvocation方法(鉴权核心)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-getAttributes%E6%96%B9%E6%B3%95"><span class="toc-text">10.4.getAttributes方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5attemptAuthorization%E6%96%B9%E6%B3%95"><span class="toc-text">10.5attemptAuthorization方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6-decide%E6%96%B9%E6%B3%95"><span class="toc-text">10.6.decide方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-vote%E6%96%B9%E6%B3%95"><span class="toc-text">10.7.vote方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-8-finallyInvocation%E6%96%B9%E6%B3%95"><span class="toc-text">10.8.finallyInvocation方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-9-afterInvocation%E6%96%B9%E6%B3%95"><span class="toc-text">10.9.afterInvocation方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-10-%E8%AF%A6%E7%BB%86%E7%9A%84%E6%8E%88%E6%9D%83%E6%B5%81%E7%A8%8B%E6%97%B6%E5%BA%8F%E5%9B%BE"><span class="toc-text">10.10.详细的授权流程时序图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-MethodSecurityInterceptor%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">16.MethodSecurityInterceptor（重点）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90"><span class="toc-text">二、注解解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-EnableWebSecurity"><span class="toc-text">1.EnableWebSecurity</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BB%84%E4%BB%B6%E8%A7%A3%E6%9E%90"><span class="toc-text">三、组件解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-DelegatingFilterProxy"><span class="toc-text">1.DelegatingFilterProxy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-FilterChainProxy"><span class="toc-text">2. FilterChainProxy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-SecurityFilterChain"><span class="toc-text">3.SecurityFilterChain</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-WebSecurityConfiguration%E5%92%8CWebSecurity"><span class="toc-text">4.WebSecurityConfiguration和WebSecurity</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-HttpSecurityConfiguration%E5%92%8CHttpSecurity"><span class="toc-text">5.HttpSecurityConfiguration和HttpSecurity</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-SecurityAutoConfiguration"><span class="toc-text">6.SecurityAutoConfiguration</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-SpringBootWebSecurityConfiguration"><span class="toc-text">7.SpringBootWebSecurityConfiguration</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-SecurityFilterAutoConfiguration"><span class="toc-text">8.SecurityFilterAutoConfiguration</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%97%A0%E9%85%8D%E7%BD%AE%E5%BC%95%E5%85%A5"><span class="toc-text">四、无配置引入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5"><span class="toc-text">代码实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">源码解析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%85%8D%E7%BD%AE%E5%BC%95%E5%85%A5"><span class="toc-text">五、配置引入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5-1"><span class="toc-text">代码实践</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E8%BF%98%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%8C%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0"><span class="toc-text">六、还未完成，持续更新</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/" title="Spring-Security源码解析与实战（持续更新）"><img src="/./img/butterfly.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring-Security源码解析与实战（持续更新）"/></a><div class="content"><a class="title" href="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/" title="Spring-Security源码解析与实战（持续更新）">Spring-Security源码解析与实战（持续更新）</a><time datetime="2024-02-25T15:50:53.000Z" title="发表于 2024-02-25 23:50:53">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/14/%E5%85%B3%E4%BA%8E%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF%E9%82%A3%E4%BA%9B%E4%BA%8B/" title="关于部署上线那些事"><img src="/./img/bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于部署上线那些事"/></a><div class="content"><a class="title" href="/2024/02/14/%E5%85%B3%E4%BA%8E%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF%E9%82%A3%E4%BA%9B%E4%BA%8B/" title="关于部署上线那些事">关于部署上线那些事</a><time datetime="2024-02-14T09:16:00.000Z" title="发表于 2024-02-14 17:16:00">2024-02-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/14/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0~%EF%BC%89/" title="异常及其解决方案汇总（持续更新~）"><img src="/./img/summary.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="异常及其解决方案汇总（持续更新~）"/></a><div class="content"><a class="title" href="/2024/02/14/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0~%EF%BC%89/" title="异常及其解决方案汇总（持续更新~）">异常及其解决方案汇总（持续更新~）</a><time datetime="2024-02-14T08:16:00.000Z" title="发表于 2024-02-14 16:16:00">2024-02-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/06/Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%88%E5%9F%BA%E4%BA%8EVirtualBox%EF%BC%89/" title="Linux虚拟机的创建（基于VirtualBox）"><img src="/./img/linux.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux虚拟机的创建（基于VirtualBox）"/></a><div class="content"><a class="title" href="/2023/01/06/Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%88%E5%9F%BA%E4%BA%8EVirtualBox%EF%BC%89/" title="Linux虚拟机的创建（基于VirtualBox）">Linux虚拟机的创建（基于VirtualBox）</a><time datetime="2023-01-06T11:34:00.000Z" title="发表于 2023-01-06 19:34:00">2023-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/06/Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%88%E5%9F%BA%E4%BA%8EVMware%EF%BC%89/" title="Linux虚拟机的创建（基于VMware）"><img src="/./img/linux.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux虚拟机的创建（基于VMware）"/></a><div class="content"><a class="title" href="/2023/01/06/Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%88%E5%9F%BA%E4%BA%8EVMware%EF%BC%89/" title="Linux虚拟机的创建（基于VMware）">Linux虚拟机的创建（基于VMware）</a><time datetime="2023-01-05T17:16:00.000Z" title="发表于 2023-01-06 01:16:00">2023-01-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/./img/butterfly.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By wzy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://featherbrainna.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'GbOYbdcEvuOxM7YfTqwXQ664-gzGzoHsz',
      appKey: 'vCrYp5O8ZWaOdSx4suuhZrkb',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://featherbrainna.github.io/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/'
    this.page.identifier = '/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/'
    this.page.title = 'Spring-Security源码解析与实战（持续更新）'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script>window.$crisp = [];
window.CRISP_WEBSITE_ID = "2e53c9c7-c85c-4d34-94a3-80c801a15ca1";
(function () {
  d = document;
  s = d.createElement("script");
  s.src = "https://client.crisp.chat/l.js";
  s.async = 1;
  d.getElementsByTagName("head")[0].appendChild(s);
})();
$crisp.push(["safe", true])

if (true) {
  $crisp.push(["do", "chat:hide"])
  $crisp.push(["on", "chat:closed", function() {
    $crisp.push(["do", "chat:hide"])
  }])
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      $crisp.push(["do", "chat:show"])
      $crisp.push(["do", "chat:open"])

    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      $crisp.push(["do", "chat:hide"])
    }
    function chatBtnShow () {
      $crisp.push(["do", "chat:show"])
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>