<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Spring-MVC组件分析 | 淡云月来去</title><meta name="author" content="wzy"><meta name="copyright" content="wzy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Spring MVC组件分析">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring-MVC组件分析">
<meta property="og:url" content="https://featherbrainna.github.io/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="淡云月来去">
<meta property="og:description" content="Spring MVC组件分析">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://featherbrainna.github.io/img/springMVC.png">
<meta property="article:published_time" content="2024-04-21T01:42:38.000Z">
<meta property="article:modified_time" content="2024-04-21T01:54:07.305Z">
<meta property="article:author" content="wzy">
<meta property="article:tag" content="Spring MVC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://featherbrainna.github.io/img/springMVC.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://featherbrainna.github.io/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: wzy","link":"链接: ","source":"来源: 淡云月来去","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring-MVC组件分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-21 09:54:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/springMVC.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">淡云月来去</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring-MVC组件分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-21T01:42:38.000Z" title="发表于 2024-04-21 09:42:38">2024-04-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-21T01:54:07.305Z" title="更新于 2024-04-21 09:54:07">2024-04-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Spring-MVC/">Spring MVC</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">22.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>91分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring-MVC组件分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-组件概览"><a href="#1-组件概览" class="headerlink" title="1.组件概览"></a>1.组件概览</h2><p>这里的组件指的是DispatcherServlet中直接初始化的那九个组件，不同的组件内部还会用到一些子组件。</p>
<h3 id="1-1HandlerMapping"><a href="#1-1HandlerMapping" class="headerlink" title="1.1HandlerMapping"></a>1.1HandlerMapping</h3><p>作用：根据request找到相应的处理器Handler和Interceptors。</p>
<p>可以<strong>实现Order接口以控制遍历HandlerMapping的顺序</strong>，越小越先使用优先级越高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerMapping</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">usesPathPatterns</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//1.根据请求获取HandlerExecutionChain</span></span><br><span class="line">    HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2HandlerAdapter"><a href="#1-2HandlerAdapter" class="headerlink" title="1.2HandlerAdapter"></a>1.2HandlerAdapter</h3><p>作用：调用handler来真正处理请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">//1.根据handler判断本对象是否支持使用该handler处理</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span>;</span><br><span class="line">    <span class="comment">//2.使用handler进行处理</span></span><br><span class="line">    ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="comment">//3.获取资源的Last-Modified（资源最后一次的修改时间）</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>视图名称是handler处理器返回的，或者RequestToViewNameTranslator获取的默认视图名。</p>
</blockquote>
<h3 id="1-3HandlerExceptionResolver"><a href="#1-3HandlerExceptionResolver" class="headerlink" title="1.3HandlerExceptionResolver"></a>1.3HandlerExceptionResolver</h3><p>作用：请求处理过程出现异常后，由此组件进行处理。只用于解析对请求做处理过程中的异常，而渲染环节产生的异常不归它管。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line">    <span class="comment">//根据异常解析处理异常</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">	ModelAndView <span class="title function_">resolveException</span><span class="params">(</span></span><br><span class="line"><span class="params">			HttpServletRequest request, HttpServletResponse response, <span class="meta">@Nullable</span> Object handler, Exception ex)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4ViewResolver"><a href="#1-4ViewResolver" class="headerlink" title="1.4ViewResolver"></a>1.4ViewResolver</h3><p>作用：将String类型的视图名和Locale解析为View类型的视图，找到渲染所需要的模板和所用技术（也就是视图类型）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ViewResolver</span> &#123;</span><br><span class="line">    <span class="comment">//根据视图名称解析视图对象</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">	View <span class="title function_">resolveViewName</span><span class="params">(String viewName, Locale locale)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最常使用的UrlBasedViewResolver系列的解析器都是针对单一视图类型进行解析的，如FreeMarkerViewResolver、InternalResourceViewResolver、VelocityViewResolver、ThymeleafViewResolver。</p>
<p>ResourceBundleViewResolver、XmlViewResolver、BeanNameResolver可以同时解析多种类型的视图。<strong>ResourceBundleViewResolver</strong>根据properties文件解析出视图，文件中指定视图类型和视图地址；<strong>XmlViewResolver</strong>根据xml文件解析出视图；<strong>BeanNameResolver</strong>是根据viewName从ApplicationContext容器中查找相应的bean做为View。</p>
<h3 id="1-5RequestToViewNameTranslator"><a href="#1-5RequestToViewNameTranslator" class="headerlink" title="1.5RequestToViewNameTranslator"></a>1.5RequestToViewNameTranslator</h3><p>作用：处理返回的ModelAndVIew对象中即没有view也没有设置viewName的情况，这时需要从request获取viewName。即定义了如何从请求对象获取viewName。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RequestToViewNameTranslator</span> &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">	String <span class="title function_">getViewName</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6LocaleResolver"><a href="#1-6LocaleResolver" class="headerlink" title="1.6LocaleResolver"></a>1.6LocaleResolver</h3><p>作用：从request中解析出Locale。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LocaleResolver</span> &#123;</span><br><span class="line">    <span class="comment">//从请求获取Locale</span></span><br><span class="line">	Locale <span class="title function_">resolveLocale</span><span class="params">(HttpServletRequest request)</span>;</span><br><span class="line">    <span class="comment">//设置请求和响应Locale</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setLocale</span><span class="params">(HttpServletRequest request, <span class="meta">@Nullable</span> HttpServletResponse response, <span class="meta">@Nullable</span> Locale locale)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring MVC中主要在<strong>两个地方用到了Locale</strong>：1.ViewResolver解析视图的时候2.使用到国际化资源或者主题的时候。</p>
<p>我们可以通过MVC拦截器 <code>LocaleChangeInterceptor</code> 来拦截请求的请求参数，从而设置改变请求的Locale属性。比如<a target="_blank" rel="noopener" href="http://localhost:8080/?locale=zh_cn%E5%B0%B1%E4%BC%9A%E5%B0%86%E8%AF%B7%E6%B1%82%E7%9A%84Locale%E8%AE%BE%E7%BD%AE%E4%B8%BA%E4%B8%AD%E6%96%87%E3%80%82">http://localhost:8080?locale=zh_cn就会将请求的Locale设置为中文。</a></p>
<h3 id="1-7ThemeResolver"><a href="#1-7ThemeResolver" class="headerlink" title="1.7ThemeResolver"></a>1.7ThemeResolver</h3><p>作用：根据请求解析主题名称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ThemeResolver</span> &#123;</span><br><span class="line">    <span class="comment">//解析主题</span></span><br><span class="line">    String <span class="title function_">resolveThemeName</span><span class="params">(HttpServletRequest request)</span>;</span><br><span class="line">    <span class="comment">//设置主题</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setThemeName</span><span class="params">(HttpServletRequest request, <span class="meta">@Nullable</span> HttpServletResponse response, <span class="meta">@Nullable</span> String themeName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring MVC中一套主题对应一个properties文件，里面存放着跟当前主题相关的所有资源，如图片、css样式等。例如：</p>
<p><img src="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/image-20240321160414104.png" alt="image-20240321160414104"></p>
<p><strong>ThemeResolver</strong>的作用是从request解析出主题名；<strong>ThemeSource</strong>则是根据主题名找到具体的主题；<strong>Theme</strong>是ThemeSource找出的一个具体的主题，可以通过它获取主题里面的资源。</p>
<p>获取主题资源是在RequestContext中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RequestContext.java</span></span><br><span class="line"><span class="keyword">public</span> Theme <span class="title function_">getTheme</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.theme == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Lazily determine theme to use for this RequestContext.</span></span><br><span class="line">      <span class="built_in">this</span>.theme = RequestContextUtils.getTheme(<span class="built_in">this</span>.request);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.theme == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// No ThemeResolver and ThemeSource available -&gt; try fallback.</span></span><br><span class="line">         <span class="built_in">this</span>.theme = getFallbackTheme();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.theme;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RequestContextUtils.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Theme <span class="title function_">getTheme</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">//1.根据请求获取ThemeResolver（数据源于IOC容器）</span></span><br><span class="line">    <span class="type">ThemeResolver</span> <span class="variable">themeResolver</span> <span class="operator">=</span> getThemeResolver(request);</span><br><span class="line">    <span class="comment">//2.根据请求获取ThemeSource</span></span><br><span class="line">    <span class="type">ThemeSource</span> <span class="variable">themeSource</span> <span class="operator">=</span> getThemeSource(request);</span><br><span class="line">    <span class="keyword">if</span> (themeResolver != <span class="literal">null</span> &amp;&amp; themeSource != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//3.themeResolver根据请求解析主题名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">themeName</span> <span class="operator">=</span> themeResolver.resolveThemeName(request);</span><br><span class="line">        <span class="comment">//4.themeSource根据主题名称解析主题对象</span></span><br><span class="line">        <span class="keyword">return</span> themeSource.getTheme(themeName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ThemeResolver的默认实现是 FixedThemeResolver</strong>，这里边使用固定的默认主题”theme”。</p>
<p><strong>ThemeSource的默认实现是WebApplicationContext的实现类</strong>。默认底层实现是ResourceBundleThemeSource，即WebApplicationContext封装了themesource属性的实现类型为ResourceBundleThemeSource，<strong>具体创建过程在UiApplicationContextUtils的initThemeSource方法</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接调用构造器创建，且设置到WebApplicationContext的themesource属性</span></span><br><span class="line">themeSource = <span class="keyword">new</span> <span class="title class_">ResourceBundleThemeSource</span>();</span><br></pre></td></tr></table></figure>

<p>Spring MVC中主题切换和Locale的切换使用相同的模式，也是使用Interceptor，即<strong>ThemeChangeInterceptor</strong>。</p>
<h3 id="1-8MultipartResolver"><a href="#1-8MultipartResolver" class="headerlink" title="1.8MultipartResolver"></a>1.8MultipartResolver</h3><p>作用：用于处理上传请求，处理方法是将普通request包装成MultipartHttpServletRequest，后者可以直接调用getFile方法获取到File，或多文件getFileMap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MultipartResolver</span> &#123;</span><br><span class="line">    <span class="comment">//1.判断是不是上传请求</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isMultipart</span><span class="params">(HttpServletRequest request)</span>;</span><br><span class="line">    <span class="comment">//2.将request包装成MultipartHttpServletRequest</span></span><br><span class="line">    MultipartHttpServletRequest <span class="title function_">resolveMultipart</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> MultipartException;</span><br><span class="line">    <span class="comment">//3.处理完后清理上传过程中产生的临时资源</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cleanupMultipart</span><span class="params">(MultipartHttpServletRequest request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-9FlashMapManager"><a href="#1-9FlashMapManager" class="headerlink" title="1.9FlashMapManager"></a>1.9FlashMapManager</h3><p>作用：管理FlashMap。</p>
<p>FlashMap主要用在redirect中传递参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FlashMapManager</span> &#123;</span><br><span class="line">    <span class="comment">//获取input flashmap</span></span><br><span class="line">    FlashMap <span class="title function_">retrieveAndUpdate</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>;</span><br><span class="line">    <span class="comment">//设置output flashmap</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">saveOutputFlashMap</span><span class="params">(FlashMap flashMap, HttpServletRequest request, HttpServletResponse response)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>retrieveAndUpdate</strong>方法用于恢复参数，并将恢复过的和超时的参数从保存介质中删除；<strong>saveOutputFlashMap</strong>用于将参数保存起来。</p>
<p>默认实现是 <code>SessionFlashMapManager</code> ，它是将参数保存到session中。</p>
<p>整个redirect的参数通过FlashMap的传递过程分为<strong>三步</strong>：</p>
<p>1.<strong>在处理器中将需要传递的参数设置到outputFlashMap中</strong>。当处理器处理完请求时，<strong>如果是redirect类型的返回值RequestMappingHandlerAdapter会将其设置到outputFlashMap中</strong>。即adapter的getModelAndView方法中实现。</p>
<p>2.在<strong>RedirectView</strong>的renderMergedOutputModel方法中<strong>调用FlashMapManager的saveOutputFlashMap方法</strong>，将outputFlashMap中的参数设置到Session中。</p>
<p>3.请求redirect后DispatcherServlet的<strong>doService会调用FlashMapManager的retrieveAndUpdate方法</strong>从Session中获取inputFlashMap并设置到Request的属性中备用，同时从Session中删除。</p>
<h2 id="2-HandlerMapping"><a href="#2-HandlerMapping" class="headerlink" title="2.HandlerMapping"></a>2.HandlerMapping</h2><p>HandlerMapping的继承结构如图：</p>
<p><img src="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/image-20240321183031638.png" alt="image-20240321183031638"></p>
<h3 id="2-1AbstractHandlerMapping"><a href="#2-1AbstractHandlerMapping" class="headerlink" title="2.1AbstractHandlerMapping"></a>2.1AbstractHandlerMapping</h3><p>是HandlerMapping的抽象实现，<strong>所有HandlerMapping都继承自AbstractHandlerMapping</strong>。</p>
<p>AbstractHandlerMapping采用模板模式设计了HandlerMapping实现的整体结构，子类只需要通过模板方法提供一些初始值或具体的算法即可。</p>
<h4 id="创建AbstractHandlerMapping之器"><a href="#创建AbstractHandlerMapping之器" class="headerlink" title="创建AbstractHandlerMapping之器"></a>创建AbstractHandlerMapping之器</h4><p>1.initApplicationContext方法</p>
<p>作用：初始化HandlerMapping的拦截器，包括其interceptors属性和adaptedInterceptors属性，<strong>具体初始化方式就是新增</strong>拦截器到属性中。</p>
<p>由于AbstractHandlerMapping继承了WebAppliactionObjectSupport，所以该对象创建时会调用父类的setApplicationContext方法，然后其方法又会调用本类的initApplicationContext()方法。即<strong>AbstractHandlerMapping的初始化就是在initApplicationContext方法实现</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initApplicationContext</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   extendInterceptors(<span class="built_in">this</span>.interceptors);</span><br><span class="line">   detectMappedInterceptors(<span class="built_in">this</span>.adaptedInterceptors);</span><br><span class="line">   initInterceptors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.extendInterceptors方法</p>
<p>作用：初始化HandlerMapping的interceptors属性</p>
<p>是<strong>模板方法</strong>，用于给子类提供一个添加（或者修改）Interceptors的入口，不过在现有Spring MVC的实现中并没有使用。</p>
<p>3.detectMappedInterceptors方法</p>
<p>作用：将Spring MVC容器及父容器中的<strong>所有MappedInterceptor类型的Bean添加到HandlerMapping的 adaptedInterceptors 属性</strong>。即初始化HandlerMapping的adaptedInterceptors属性。</p>
<p>即将用户注册的按请求路径是否生效的拦截器MappedInterceptor添加到HandlerMapping的adaptedInterceptors属性中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">detectMappedInterceptors</span><span class="params">(List&lt;HandlerInterceptor&gt; mappedInterceptors)</span> &#123;</span><br><span class="line">mappedInterceptors.addAll(BeanFactoryUtils.beansOfTypeIncludingAncestors(</span><br><span class="line">         obtainApplicationContext(), MappedInterceptor.class, <span class="literal">true</span>, <span class="literal">false</span>).values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.initInterceptors方法</p>
<p>作用：初始化HandlerMapping的adaptedInterceptors属性。<strong>将interceptors属性中的拦截器全部适配到添加到adaptedInterceptors</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void initInterceptors() &#123;</span><br><span class="line">   if (!this.interceptors.isEmpty()) &#123;</span><br><span class="line">      for (int i = 0; i &lt; this.interceptors.size(); i++) &#123;</span><br><span class="line">         Object interceptor = this.interceptors.get(i);</span><br><span class="line">         if (interceptor == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Entry number &quot; + i + &quot; in interceptors array is null&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         this.adaptedInterceptors.add(adaptInterceptor(interceptor));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AbstractHandlerMapping之用"><a href="#AbstractHandlerMapping之用" class="headerlink" title="AbstractHandlerMapping之用"></a>AbstractHandlerMapping之用</h4><p>主要是<strong>getHandler方法</strong>在起作用。getHandler方法就是AbstractHandlerMapping的<strong>底层设计</strong>。</p>
<p>getHandler方法的实现分为两部分，getHandlerExecutionChain之前是找Handler，getHandlerExecutionChain方法用于添加拦截器。</p>
<p>1.getHandler方法</p>
<p><strong>找Handler的过程</strong>：</p>
<ol>
<li><strong>通过 getHandlerInternal(request) 方法查找</strong>，这是模板方法，留给子类具体实现（也是子类主要做的事情）。</li>
<li>如果没有从子类获取到则<strong>使用默认的Handler</strong>。默认的Handler保存在AbstractHandlerMapping的一个Object类型的属性defaultHandler中。</li>
<li><strong>如果默认Handler为null则方法返回null</strong>。</li>
<li>如果找到的Handler类型是String，则<strong>从Spring MVC容器里查找相应名字的Bean</strong>。</li>
</ol>
<p>对应的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> getHandlerInternal(request);</span><br><span class="line">   <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">      handler = getDefaultHandler();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">   <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String) handler;</span><br><span class="line">      handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">   &#125;</span><br><span class="line">    。。。</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>2.getHandlerExecutionChain方法</p>
<p>作用：创建HandlerExecutionChain对象，然后将adaptedInterceptors属性中符合要求的拦截器添加进去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerExecutionChain <span class="title function_">getHandlerExecutionChain</span><span class="params">(Object handler, HttpServletRequest request)</span> &#123;</span><br><span class="line">   <span class="comment">//1.创建 HandlerExecutionChain 对象</span></span><br><span class="line">   <span class="type">HandlerExecutionChain</span> <span class="variable">chain</span> <span class="operator">=</span> (handler <span class="keyword">instanceof</span> HandlerExecutionChain ?</span><br><span class="line">         (HandlerExecutionChain) handler : <span class="keyword">new</span> <span class="title class_">HandlerExecutionChain</span>(handler));</span><br><span class="line">   <span class="comment">//2.遍历adaptedInterceptors属性中的拦截器</span></span><br><span class="line">   <span class="keyword">for</span> (HandlerInterceptor interceptor : <span class="built_in">this</span>.adaptedInterceptors) &#123;</span><br><span class="line">      <span class="comment">//3.如果类型为 MappedInterceptor，则判断是否匹配当前请求，匹配则添加到 HandlerExecutionChain 的拦截器中</span></span><br><span class="line">      <span class="keyword">if</span> (interceptor <span class="keyword">instanceof</span> MappedInterceptor) &#123;</span><br><span class="line">         <span class="type">MappedInterceptor</span> <span class="variable">mappedInterceptor</span> <span class="operator">=</span> (MappedInterceptor) interceptor;</span><br><span class="line">         <span class="keyword">if</span> (mappedInterceptor.matches(request)) &#123;   chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//3.如果为其它类型拦截器，则直接添加到 HandlerExecutionChain 的拦截器中</span></span><br><span class="line">         chain.addInterceptor(interceptor);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//4.返回 HandlerExecutionChain 对象</span></span><br><span class="line">   <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2AbstractUrlHandlerMapping系列"><a href="#2-2AbstractUrlHandlerMapping系列" class="headerlink" title="2.2AbstractUrlHandlerMapping系列"></a>2.2AbstractUrlHandlerMapping系列</h3><h4 id="AbstractUrlHandlerMapping"><a href="#AbstractUrlHandlerMapping" class="headerlink" title="AbstractUrlHandlerMapping"></a>AbstractUrlHandlerMapping</h4><p>它是通过请求的url来进行匹配查找处理器执行链的。</p>
<p>原理：<strong>将url与对应的Handler保存在一个Map中</strong>，在getHandlerInternal方法中使用url从Map中获取Handler，<strong>AbstractUrlHandlerMapping实现了getHandlerInternal方法具体从url中获取Handler的过程，而Map的初始化则交给了子类去完成</strong>。</p>
<p>AbstractUrlHandlerMapping包含的属性如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractUrlHandlerMapping</span> <span class="keyword">extends</span> <span class="title class_">AbstractHandlerMapping</span> <span class="keyword">implements</span> <span class="title class_">MatchableHandlerMapping</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> Object rootHandler;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">useTrailingSlashMatch</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">lazyInitHandlers</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; handlerMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;PathPattern, Object&gt; pathPatternHandlerMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>从源码来看，AbstractUrlHandlerMapping即支持直接literal字面量匹配也支持pattern模糊匹配。</p>
<p><code>PathPattern</code> 和 <code>AntPathMatcher</code> 都支持url的pattern模糊匹配，但<strong>PathPattern更高效且合适</strong>。</p>
<p>1.getHandlerInternal方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">//1.从请求中获取请求路径（不包括context path和请求参数），以供寻找handler处理器 </span></span><br><span class="line">   <span class="type">String</span> <span class="variable">lookupPath</span> <span class="operator">=</span> initLookupPath(request);</span><br><span class="line">   Object handler;</span><br><span class="line">   <span class="comment">//2.根据Map查找handler </span></span><br><span class="line">   <span class="keyword">if</span> (usesPathPatterns()) &#123;</span><br><span class="line">      <span class="type">RequestPath</span> <span class="variable">path</span> <span class="operator">=</span> ServletRequestPathUtils.getParsedRequestPath(request);</span><br><span class="line">      <span class="comment">//2.根据路径查找handler处理器</span></span><br><span class="line">      handler = lookupHandler(path, lookupPath, request);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//2.根据路径查找handler处理器 </span></span><br><span class="line">      handler = lookupHandler(lookupPath, request);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3.如果未找到handler则尝试使用根路径的handler和默认handler</span></span><br><span class="line">   <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// We need to care for the default handler directly, since we need to</span></span><br><span class="line">      <span class="comment">// expose the PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE for it as well.</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">rawHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.matchesCharacter(lookupPath, <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">         rawHandler = getRootHandler();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (rawHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">         rawHandler = getDefaultHandler();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//4.如果可以使用根handler或者默认handler则 </span></span><br><span class="line">      <span class="keyword">if</span> (rawHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">         <span class="keyword">if</span> (rawHandler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String) rawHandler;</span><br><span class="line">            rawHandler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//4.1校验handler是否适配请求</span></span><br><span class="line">         validateHandler(rawHandler, request);</span><br><span class="line">         <span class="comment">//4.2构建最终的handler返回(设置处理器和拦截器) </span></span><br><span class="line">         handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法逻辑如下：</p>
<ul>
<li>调用父类initLookupPath方法。<strong>从请求对象获取解析</strong>（URL解码如：%20）<strong>后的请求路径</strong>，获取的请求路径不包括context path和请求参数</li>
<li>调用本类lookupHandler方法。<strong>从handlerMap和pathPatternHandlerMap查找处理器</strong>。</li>
<li>如果从Map中未找到，则<strong>尝试使用根路径和默认的handler</strong>，获取到后要构建成处理器执行链。</li>
</ul>
<p>2.initLookupPath方法</p>
<p>作用：获取真正用于匹配的请求路径，<strong>即不包含context path、不包含请求参数、且被URL解码的路径</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected String initLookupPath(HttpServletRequest request) &#123;</span><br><span class="line">   //1.如果PathPatternParser属性在handlermapping存在，则通过ServletRequestPathUtils进行如下路径获取		</span><br><span class="line">   if (usesPathPatterns()) &#123;     request.removeAttribute(UrlPathHelper.PATH_ATTRIBUTE);</span><br><span class="line">      RequestPath requestPath = ServletRequestPathUtils.getParsedRequestPath(request);</span><br><span class="line">      String lookupPath = requestPath.pathWithinApplication().value();</span><br><span class="line">      return UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath);</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">   //2.如果不存在，则通过UrlPathHelper进行路径获取</span><br><span class="line">      return getUrlPathHelper().resolveAndCacheLookupPath(request);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.<strong>lookupHandler方法</strong>（核心方法）</p>
<p>作用：根据指定的路径查找匹配的handler处理器执行链。</p>
<p>有两种模式：lookupHandler(path, lookupPath, request)和lookupHandler(lookupPath, request)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractUrlHandlerMapping.java的getHandlerInternal方法部分逻辑</span></span><br><span class="line"><span class="keyword">if</span> (usesPathPatterns()) &#123;</span><br><span class="line">   <span class="type">RequestPath</span> <span class="variable">path</span> <span class="operator">=</span> ServletRequestPathUtils.getParsedRequestPath(request);</span><br><span class="line">   handler = lookupHandler(path, lookupPath, request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">   handler = lookupHandler(lookupPath, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lookupHandler方法用于使用lookupPath从Map中查找Handler，不过很多时候并不能直接通过字面量从Map中get到，因为很多Handler都是用了Pattern的匹配模式，如”/show/article/*”，这时就要进行模糊匹配。</p>
<p><strong>此外一个lookupHandler还可能跟多个Pattern相匹配</strong>，这时还要<strong>选择其中最优的</strong>，所以查找过程并不是直接从Map中获取。</p>
<p>先分析简单的模式方法lookupHandler(lookupPath, request)，此方法<strong>使用PathMatcher对lookupPath和pattern进行匹配</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">lookupHandler</span><span class="params">(String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">//1.先直接从 handlerMap 中直接根据路径字面量获取handler,如果获取不到直接返回null,如果获取到直接返回 </span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> getDirectMatch(lookupPath, request);</span><br><span class="line">   <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> handler;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//============获取与lookupPath匹配的所有pattern===========</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//初始化与lookupPath匹配的路径pattern字符串集合（mapkey集合）</span></span><br><span class="line">   List&lt;String&gt; matchingPatterns = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">//2.遍历 handlerMap 的key</span></span><br><span class="line">   <span class="keyword">for</span> (String registeredPattern : <span class="built_in">this</span>.handlerMap.keySet()) &#123;</span><br><span class="line">       <span class="comment">//2.1使用PathMatcher对象来匹配字符串pattern和lookupPath字符串路径</span></span><br><span class="line">      <span class="keyword">if</span> (getPathMatcher().match(registeredPattern, lookupPath)) &#123;</span><br><span class="line">         <span class="comment">//2.2如果匹配则添加到 matchingPatterns 集合中</span></span><br><span class="line">         matchingPatterns.add(registeredPattern);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (useTrailingSlashMatch()) &#123;</span><br><span class="line">         <span class="comment">//2.2否则尝试给 registeredPattern尾部加/再进行匹配，如果匹配则添加到 matchingPatterns 集合中(这里原来的key被加了&quot;/&quot;)</span></span><br><span class="line">         <span class="keyword">if</span> (!registeredPattern.endsWith(<span class="string">&quot;/&quot;</span>) &amp;&amp; getPathMatcher().match(registeredPattern + <span class="string">&quot;/&quot;</span>, lookupPath)) &#123;</span><br><span class="line">            matchingPatterns.add(registeredPattern + <span class="string">&quot;/&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=======从matchingPatterns获取最匹配的pattern==========   </span></span><br><span class="line">   <span class="comment">//初始化一个最匹配的pattern字符串 </span></span><br><span class="line">   <span class="type">String</span> <span class="variable">bestMatch</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">//3.从 PathMatcher获取路径匹配比较器，对matchingPatterns匹配程度进行排序</span></span><br><span class="line">   Comparator&lt;String&gt; patternComparator = getPathMatcher().getPatternComparator(lookupPath);</span><br><span class="line">   <span class="comment">//4.如果 matchingPatterns 非空</span></span><br><span class="line">   <span class="keyword">if</span> (!matchingPatterns.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">//4.1使用匹配比较器进行比较排序 matchingPatterns</span></span><br><span class="line">      matchingPatterns.sort(patternComparator);</span><br><span class="line">      <span class="comment">//4.2取排序最前面的，即匹配程度最高的（注意最高的可能有多个，这里暂时先不处理）</span></span><br><span class="line">      bestMatch = matchingPatterns.get(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//5.如果 bestMatch 非空 </span></span><br><span class="line">   <span class="keyword">if</span> (bestMatch != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//5.1从 handlerMap 取出bestMatch对应的handler</span></span><br><span class="line">      handler = <span class="built_in">this</span>.handlerMap.get(bestMatch);</span><br><span class="line">      <span class="comment">//5.2如果获取不到，则可能是我们前面加了后缀导致 </span></span><br><span class="line">      <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">//5.2.1去掉后缀获取handler </span></span><br><span class="line">         <span class="keyword">if</span> (bestMatch.endsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">            handler = <span class="built_in">this</span>.handlerMap.get(bestMatch.substring(<span class="number">0</span>, bestMatch.length() - <span class="number">1</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//5.2.2如果还获取不到，程序出错兜底报错 </span></span><br><span class="line">         <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                  <span class="string">&quot;Could not find handler for best pattern match [&quot;</span> + bestMatch + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//5.3如果handler是字符串类型，从容器中获取对应的bean</span></span><br><span class="line">      <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String) handler;</span><br><span class="line">         handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//5.4校验handler是否适配此请求 </span></span><br><span class="line">      validateHandler(handler, request);</span><br><span class="line"> 	  <span class="comment">//5.5获取lookupPath与bestMatch动态匹配的部分路径</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">pathWithinMapping</span> <span class="operator">=</span> getPathMatcher().extractPathWithinPattern(bestMatch, lookupPath);</span><br><span class="line">       </span><br><span class="line"><span class="comment">//=============处理最匹配的pattern其实有多个的情况==========</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// There might be multiple &#x27;best patterns&#x27;, let&#x27;s make sure we have the correct URI template variables</span></span><br><span class="line">      <span class="comment">// for all of them</span></span><br><span class="line">      Map&lt;String, String&gt; uriTemplateVariables = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">      <span class="comment">//6. 遍历matchingPatterns集合</span></span><br><span class="line">      <span class="keyword">for</span> (String matchingPattern : matchingPatterns) &#123;</span><br><span class="line">         <span class="comment">//6.1使用匹配比较器，比较pattern的匹配程度是否与bestMatch相等</span></span><br><span class="line">         <span class="keyword">if</span> (patternComparator.compare(bestMatch, matchingPattern) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//使用 PathMatcher 获取pattern对应lookupPath的路径参数UriTemplateVariables的map。key为pattern的变量字符串，value为当前请求对应变量的值</span></span><br><span class="line">            Map&lt;String, String&gt; vars = getPathMatcher().extractUriTemplateVariables(matchingPattern, lookupPath);</span><br><span class="line">            <span class="comment">//url解码变量值，如果未进行解码的话 </span></span><br><span class="line">            Map&lt;String, String&gt; decodedVars = getUrlPathHelper().decodePathVariables(request, vars);</span><br><span class="line">            uriTemplateVariables.putAll(decodedVars);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//7.封装handler为handler处理器执行链</span></span><br><span class="line">      <span class="keyword">return</span> buildPathExposingHandler(handler, bestMatch, pathWithinMapping, uriTemplateVariables);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//8.如果未pattern模糊匹配成功，返回null</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>buildPathExposingHandler</strong>方法用于封装构造handler处理器执行链，用于给查找到的Handler注册两个拦截器PathExposingHandlerInterceptor和UriTemplateVariablesHandlerInterceptor，这是两个内部拦截器，<strong>主要是将匹配的结果保存到请求对象的属性中</strong>。</p>
<p><strong>PathMatcher接口</strong></p>
<p>作用：基于字符串的路径匹配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PathMatcher</span> &#123;</span><br><span class="line">    <span class="comment">//校验字符串是否为pattern</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isPattern</span><span class="params">(String path)</span>;</span><br><span class="line">    <span class="comment">//校验指定path是否匹配指定pattern</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(String pattern, String path)</span>;</span><br><span class="line">    <span class="comment">//校验指定path是否匹配指定pattern的部分开头</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matchStart</span><span class="params">(String pattern, String path)</span>;</span><br><span class="line">    <span class="comment">//提取指定path中与指定pattern动态匹配的部分</span></span><br><span class="line">    String <span class="title function_">extractPathWithinPattern</span><span class="params">(String pattern, String path)</span>;</span><br><span class="line">    <span class="comment">//根据指定path和指定pattern提取路径变量Map对象</span></span><br><span class="line">    Map&lt;String, String&gt; <span class="title function_">extractUriTemplateVariables</span><span class="params">(String pattern, String path)</span>;</span><br><span class="line">    <span class="comment">//获取指定path的Pattern比较器,用于比较Pattern对指定path的匹配程度</span></span><br><span class="line">    Comparator&lt;String&gt; <span class="title function_">getPatternComparator</span><span class="params">(String path)</span>;</span><br><span class="line">    <span class="comment">//结合两个pattern字符串</span></span><br><span class="line">    String <span class="title function_">combine</span><span class="params">(String pattern1, String pattern2)</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>其默认实现类是AntPathMatcher。</p>
<p><strong>AntPathMatcher</strong>类</p>
<p>ant风格的路径匹配器</p>
<p>//TODO源码待解析</p>
<p>再**分析复杂的模式方法lookupHandler(path, lookupPath, request)**，此方法使用PathPattern进行匹配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">lookupHandler</span><span class="params">(</span></span><br><span class="line"><span class="params">      RequestPath path, String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//======1.通过字面量匹配直接从handlerMap获取handler==========</span></span><br><span class="line">    </span><br><span class="line">   <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> getDirectMatch(lookupPath, request);</span><br><span class="line">   <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> handler;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======2.通过pattern匹配从pathPatternHandlerMap获取所有匹配的PathPattern====</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//2.1初始化 matches 变量为null</span></span><br><span class="line">   List&lt;PathPattern&gt; matches = <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">//2.2遍历 pathPatternHandlerMap 集合的键</span></span><br><span class="line">   <span class="keyword">for</span> (PathPattern pattern : <span class="built_in">this</span>.pathPatternHandlerMap.keySet()) &#123;</span><br><span class="line">      <span class="comment">//2.3 使用PathPattern来匹配请求路径</span></span><br><span class="line">      <span class="keyword">if</span> (pattern.matches(path.pathWithinApplication())) &#123;</span><br><span class="line">         <span class="comment">//匹配成功，则先视情况初始化 matches集合，再将pattern添加到集合</span></span><br><span class="line">         matches = (matches != <span class="literal">null</span> ? matches : <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">         matches.add(pattern);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.4如果没有匹配的PathPattern，则直接返回null</span></span><br><span class="line">   <span class="keyword">if</span> (matches == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//=====3.从matches匹配的中获取最匹配的PathPattern===========</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//2.5如果有匹配的PathPattern</span></span><br><span class="line">   <span class="keyword">if</span> (matches.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//对 PathPattern 集合进行排序</span></span><br><span class="line">      matches.sort(PathPattern.SPECIFICITY_COMPARATOR);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.6获取首位作为最匹配的 PathPattern </span></span><br><span class="line">   <span class="type">PathPattern</span> <span class="variable">pattern</span> <span class="operator">=</span> matches.get(<span class="number">0</span>);</span><br><span class="line">   <span class="comment">//2.7从pathPatternHandlerMap获取其对应的handler</span></span><br><span class="line">   handler = <span class="built_in">this</span>.pathPatternHandlerMap.get(pattern);</span><br><span class="line">   <span class="comment">//2.8如果 handler为 字符串类型，则从容器中获取handler</span></span><br><span class="line">   <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String) handler;</span><br><span class="line">      handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.9校验handler是否与请求适配 </span></span><br><span class="line">   validateHandler(handler, request);</span><br><span class="line">   <span class="comment">//2.10获取请求路径与pattern动态匹配的部分 </span></span><br><span class="line">   <span class="type">String</span> <span class="variable">pathWithinMapping</span> <span class="operator">=</span> pattern.extractPathWithinPattern(path.pathWithinApplication()).value();</span><br><span class="line">   <span class="comment">//2.11去掉“;”的路径参数 </span></span><br><span class="line">   pathWithinMapping = UrlPathHelper.defaultInstance.removeSemicolonContent(pathWithinMapping);</span><br><span class="line">   <span class="comment">//2.12封装构建handler处理器执行链 </span></span><br><span class="line">   <span class="keyword">return</span> buildPathExposingHandler(handler, pattern.getPatternString(), pathWithinMapping, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.registerHandler方法</p>
<p>作用：初始化AbstractUrlHandlerMapping的Map类型属性，承担AbstractUrlHandlerMapping的创建工作。</p>
<p><strong>由子类调用</strong>，这样不同的子类就可以通过注册不同的Handler将组件创建出来。</p>
<p>registerHandler(String[] urlPaths, String beanName)方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerHandler</span><span class="params">(String[] urlPaths, String beanName)</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   <span class="comment">//遍历传入的urlPaths,委托给registerHandler(urlPath, beanName)进行注册</span></span><br><span class="line">   <span class="keyword">for</span> (String urlPath : urlPaths) &#123;</span><br><span class="line">      registerHandler(urlPath, beanName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>registerHandler(String urlPath, Object handler)方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerHandler</span><span class="params">(String urlPath, Object handler)</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   Assert.notNull(urlPath, <span class="string">&quot;URL path must not be null&quot;</span>);</span><br><span class="line">   Assert.notNull(handler, <span class="string">&quot;Handler object must not be null&quot;</span>);</span><br><span class="line">   <span class="type">Object</span> <span class="variable">resolvedHandler</span> <span class="operator">=</span> handler;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1.如果handler是String类型，且没有设置lazyInitHandlers,则从容器中获取handler</span></span><br><span class="line">   <span class="keyword">if</span> (!<span class="built_in">this</span>.lazyInitHandlers &amp;&amp; handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String) handler;</span><br><span class="line">      <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> obtainApplicationContext();</span><br><span class="line">      <span class="keyword">if</span> (applicationContext.isSingleton(handlerName)) &#123;</span><br><span class="line">         resolvedHandler = applicationContext.getBean(handlerName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.从 handlerMap 直接获取对应urlPath的处理器</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="built_in">this</span>.handlerMap.get(urlPath);</span><br><span class="line">   <span class="comment">//3.如果已存在对应urlPath的处理器 </span></span><br><span class="line">   <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果已存在的处理器和要注册的处理器不相同，则抛出异常 </span></span><br><span class="line">      <span class="keyword">if</span> (mappedHandler != resolvedHandler) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//3.如果不存在对应urlPath的处理器</span></span><br><span class="line">      <span class="comment">//4.判断urlPath是否为根路径 </span></span><br><span class="line">      <span class="keyword">if</span> (urlPath.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">         <span class="comment">//是根路径则，设置到rootHandler属性 </span></span><br><span class="line">         setRootHandler(resolvedHandler);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//4.判断urlPath是否为/*路径 </span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (urlPath.equals(<span class="string">&quot;/*&quot;</span>)) &#123;</span><br><span class="line">         <span class="comment">//是/*路径，设置到默认 defaultHandler 属性</span></span><br><span class="line">         setDefaultHandler(resolvedHandler);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//4.如果是其它urlPath </span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//4.1将 urlPath和对应的handler 放入handlerMap集合</span></span><br><span class="line">         <span class="built_in">this</span>.handlerMap.put(urlPath, resolvedHandler);</span><br><span class="line">         <span class="comment">//4.2如果使用PathPattern模式，还要放入 pathPatternHandlerMap集合</span></span><br><span class="line">         <span class="keyword">if</span> (getPatternParser() != <span class="literal">null</span>) &#123; </span><br><span class="line">			<span class="comment">//这里会使用 PathPatternParser将urlPath解析为PathPattern对象！！！</span></span><br><span class="line">             <span class="built_in">this</span>.pathPatternHandlerMap.put(getPatternParser().parse(urlPath), resolvedHandler);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SimpleUrlHandlerMapping"><a href="#SimpleUrlHandlerMapping" class="headerlink" title="SimpleUrlHandlerMapping"></a>SimpleUrlHandlerMapping</h4><p>是AbstractUrlHandlerMapping的直接实现子类。</p>
<p>通过重写父类的initApplicationContext方法<strong>在创建组件对象时</strong>调用**registerHandlers(Map&lt;String, Object&gt; urlMap)**方法来完成Handler的注册，方法内部又调用了registerHandler(url, handler)父类方法。</p>
<p><strong>原理</strong>：通过registerHandlers将urlMap读取出来，然后将key带上/前缀，将value去掉空白符号，然后注册。</p>
<p>SimpleUrlHandlerMapping类非常简单，就是直接将配置的内容注册到了AbstractUrlHandlerMapping的属性中。</p>
<h4 id="AbstractDetectingUrlHandlerMapping"><a href="#AbstractDetectingUrlHandlerMapping" class="headerlink" title="AbstractDetectingUrlHandlerMapping"></a>AbstractDetectingUrlHandlerMapping</h4><p>是AbstractUrlHandlerMapping的子抽象类。</p>
<p>也是通过重写父类的initApplicationContext方法来完成Handler的注册，里面调用了detectHandlers方法。</p>
<p><strong>原理</strong>：从容器中获取所有的beanName，遍历beanName尝试解析其对应的urls，解析出来非空则执行注册。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">detectHandlers</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   <span class="comment">//1.获取 ApplicationContext</span></span><br><span class="line">   <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> obtainApplicationContext();</span><br><span class="line">   <span class="comment">//2.从 ApplicationContext 获取所有的beanName </span></span><br><span class="line">   String[] beanNames = (<span class="built_in">this</span>.detectHandlersInAncestorContexts ?</span><br><span class="line">         BeanFactoryUtils.beanNamesForTypeIncludingAncestors(applicationContext, Object.class) :</span><br><span class="line">         applicationContext.getBeanNamesForType(Object.class));</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.遍历所有的beanName</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      <span class="comment">//3.1尝试从beanName解析出 urls</span></span><br><span class="line">      String[] urls = determineUrlsForHandler(beanName);</span><br><span class="line">      <span class="comment">//3.2如果解析出的urls非空，调用父类方法执行注册 </span></span><br><span class="line">      <span class="keyword">if</span> (!ObjectUtils.isEmpty(urls)) &#123;</span><br><span class="line">         <span class="comment">// URL paths found: Let&#x27;s consider it a handler.</span></span><br><span class="line">         registerHandler(urls, beanName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanNameUrlHandlerMapping实现类实现非常简单，检查beanName和alias是不是以”/“开头，如果是<strong>则将beanName和alias做为urls</strong>。</p>
<h3 id="2-3AbstractHandlerMethodMapping系列"><a href="#2-3AbstractHandlerMethodMapping系列" class="headerlink" title="2.3AbstractHandlerMethodMapping系列"></a>2.3AbstractHandlerMethodMapping系列</h3><p>这个系列是将Method作为Handler来使用的，这也是我们现在<strong>用的最多的一种Handler</strong>，经常使用的@RequestMapping所注释的方法就是这种Handler，它有一个专门的类型<strong>HandlerMethod</strong>。</p>
<p>它是Request和HandlerMethod的映射Map。</p>
<h4 id="创建AbstractHandlerMethodMapping系列之器"><a href="#创建AbstractHandlerMethodMapping系列之器" class="headerlink" title="创建AbstractHandlerMethodMapping系列之器"></a>创建AbstractHandlerMethodMapping系列之器</h4><p><strong>泛型T</strong>是用来代表<strong>匹配Handler的条件</strong>专门使用的一种类，这里的条件不仅是url还可以有很多其他条件，如请求类型、请求参数、Header等。</p>
<p><strong>RequestCondition</strong></p>
<p>默认泛型使用的是<strong>RequestMappingInfo</strong>。RequestMappingInfo实现了<strong>RequestCondition接口</strong>，此接口<strong>专门用于保存从request提取出的用于匹配Handler的条件</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RequestCondition</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//结合请求条件</span></span><br><span class="line">    T <span class="title function_">combine</span><span class="params">(T other)</span>;</span><br><span class="line">    <span class="comment">//校验请求是否匹配当前条件，然后返回匹配的条件或者null</span></span><br><span class="line">    T <span class="title function_">getMatchingCondition</span><span class="params">(HttpServletRequest request)</span>;</span><br><span class="line">    <span class="comment">//在当前请求下，比较当前请求条件和other请求条件</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T other, HttpServletRequest request)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/image-20240325141917597.png" alt="image-20240325141917597"></p>
<p><strong>AbstractRequestCondition</strong>中重写了equals、hashCode和toString三个方法，有8个子类，除了CompositeRequestCondition外每一个子类表示一种匹配条件。</p>
<p>RequestCondition的另一个实现就是这里要用的<strong>RequestMappingInfo</strong>，它里面其实就是用七个属性保存了七个RequestCondition，在匹配时<strong>使用那七个变量进行匹配</strong>，这也就是可以在@RequestMapping中给处理器指定多种匹配方式的原因。</p>
<p>AbstractHandlerMethodMapping中的核心属性是private final <strong>MappingRegistry</strong> mappingRegistry = new MappingRegistry();即一个映射注册器对象。这个注册器维护了所有的关于HandlerMethod的映射。</p>
<p>MappingRegistry又封装了三个最重要的Map:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MappingRegistry</span> &#123;</span><br><span class="line"><span class="comment">//1.匹配条件RequestCondition与HandlerMethod的对应关系，当然这里将HandlerMethod封装成MappingRegistration</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;T, MappingRegistration&lt;T&gt;&gt; registry = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//2.uri与匹配条件的对应关系</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MultiValueMap&lt;String, T&gt; pathLookup = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//3.name与HandlerMethod集合的对应关系</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;HandlerMethod&gt;&gt; nameLookup = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>这里的name是使用HandlerMethodMappingNamingStrategy策略的实现类从HandlerMethod中解析出来的，默认使用RequestMappingInfoHandlerMethodMappingNamingStrategy实现类，<strong>解析规则是：类名里的大写字母组合+”#”+方法名</strong>。</p>
<p>正常匹配过程中无需使用这个Map。</p>
<p>1.afterPropertiesSet方法</p>
<p>作用：初始化AbstractHandlerMethodMapping的属性</p>
<p>AbstractHandlerMethodMapping实现了InitializingBean接口，所以spring容器会自动调用其afterPropertiesSet方法，<strong>afterProperties方法</strong>又交给<strong>initHandlerMethods方法</strong>完成具体的初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">   initHandlerMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.initHandlerMethods方法</p>
<p>作用：从容器中扫描所有的bean，然后根据一定的规则筛选出Handler，然后注册。默认会去除以”scopedTarget.”开头的beanName。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initHandlerMethods</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//1.获取容器中所有的beanName并进行遍历 </span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : getCandidateBeanNames()) &#123;</span><br><span class="line">      <span class="comment">//1.2如果beanName不是以&quot;scopedTarget.&quot;开头 </span></span><br><span class="line">      <span class="keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class="line">         <span class="comment">//进行筛选bean,通知注册HandlerMethod </span></span><br><span class="line">         processCandidateBean(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//2.注册HandlerMethod 之后的后处理,这里默认是日志记录</span></span><br><span class="line">handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.processCandidateBean方法</p>
<p>作用：校验指定beanName的类型是否为handler，如果是则调用detectHandlerMethods(beanName)方法进行注册。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processCandidateBean</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">   <span class="comment">//1.获取beanName对应的beanType </span></span><br><span class="line">   Class&lt;?&gt; beanType = <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      beanType = obtainApplicationContext().getType(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.调用isHandler方法校验beanType，校验成功进行注册 </span></span><br><span class="line">   <span class="keyword">if</span> (beanType != <span class="literal">null</span> &amp;&amp; isHandler(beanType)) &#123;</span><br><span class="line">      detectHandlerMethods(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>isHandler方法由子类实现</strong>，即如何筛选容器中的bean由子类实现。</p>
<p>4.detectHandlerMethods方法（<strong>核心方法</strong>）</p>
<p>作用：注册。</p>
<p>通过一系列反射操作，先获取handler的真实类型，再从真实类型中遍历其方法反射对象，并通过getMappingForMethod(method, userType)方法获取请求条件对象，并构造出methods映射集合，最后遍历methods来调用registerHandlerMethod(handler, invocableMethod, mapping)进行注册到map中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">detectHandlerMethods</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">   <span class="comment">//1.获取handler的类型 </span></span><br><span class="line">   Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ?         obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (handlerType != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//2.获取真实的类型，解析动态代理的真实类型 </span></span><br><span class="line">      Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line">      <span class="comment">//3. 使用MethodIntrospector遍历真实类型的中的方法，如果方法是HandlerMethod则添加Method和条件对象的映射到methods集合中</span></span><br><span class="line">      Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">(MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//4.遍历methods集合</span></span><br><span class="line">      methods.forEach((method, mapping) -&gt; &#123;</span><br><span class="line">         <span class="comment">//4.1使用AopUtils获取方法反射对象的真正代理方法反射对象 </span></span><br><span class="line">         <span class="type">Method</span> <span class="variable">invocableMethod</span> <span class="operator">=</span> AopUtils.selectInvocableMethod(method, userType);</span><br><span class="line">         <span class="comment">//4.2调用registerHandlerMethod将方法和请求条件注册到map中</span></span><br><span class="line">         registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法分为两步：</p>
<ol>
<li>首先从传入的处理器中找到符合要求的方法，根据getMappingForMethod方法来找。</li>
<li>然后使用registerHandlerMethod进行注册（也就是保存到Map中）。</li>
</ol>
<p>5.RequestMappingHandlerMapping的getMappingForMethods方法</p>
<p>作用：<strong>通过类上和方法上@RequestMapping注解来创建RequestMappingInfo对象</strong>，并把它们合并返回。</p>
<p>它是根据@RequstMapping注解来找匹配条件的，如果没有则返回null，如果有则根据注解的内容来创建RequestMappingInfo类型的匹配条件对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RequestMappingHandlerMapping.java</span></span><br><span class="line"><span class="keyword">protected</span> RequestMappingInfo <span class="title function_">getMappingForMethod</span><span class="params">(Method method, Class&lt;?&gt; handlerType)</span> &#123;</span><br><span class="line">   <span class="comment">//1.根据【方法反射对象】创建 RequestMappingInfo</span></span><br><span class="line">   <span class="type">RequestMappingInfo</span> <span class="variable">info</span> <span class="operator">=</span> createRequestMappingInfo(method);</span><br><span class="line">   <span class="keyword">if</span> (info != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//2.根据【类class对象】创建 RequestMappingInfo</span></span><br><span class="line">      <span class="type">RequestMappingInfo</span> <span class="variable">typeInfo</span> <span class="operator">=</span> createRequestMappingInfo(handlerType);</span><br><span class="line">      <span class="comment">//3.如果类级别的注解非空，则组合匹配条件 </span></span><br><span class="line">      <span class="keyword">if</span> (typeInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">         info = typeInfo.combine(info);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//4.从handlermapping对象属性中获取路径前缀 </span></span><br><span class="line">      <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> getPathPrefix(handlerType);</span><br><span class="line">      <span class="comment">//5.如果路径前缀非空，则继续组合匹配条件 </span></span><br><span class="line">      <span class="keyword">if</span> (prefix != <span class="literal">null</span>) &#123;</span><br><span class="line">         info = RequestMappingInfo.paths(prefix).options(<span class="built_in">this</span>.config).build().combine(info);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//6.返回组合好的匹配条件，或者null </span></span><br><span class="line">   <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.RequestMappingHandlerMapping的createRequestMappingInfo方法</p>
<p>作用：<strong>通过</strong>方法Mthod反射对象或者所属类Class对象上的<strong>注解对象来创建RequestMappingInfo</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RequestMappingInfo <span class="title function_">createRequestMappingInfo</span><span class="params">(AnnotatedElement element)</span> &#123;</span><br><span class="line">   <span class="comment">//1.获取元素（方法或类反射对象）上的注解对象 </span></span><br><span class="line">   <span class="type">RequestMapping</span> <span class="variable">requestMapping</span> <span class="operator">=</span> AnnotatedElementUtils.findMergedAnnotation(element, RequestMapping.class);</span><br><span class="line">   <span class="comment">//2.根据元素对象获取对应的自定义的条件对象，这里默认为null</span></span><br><span class="line">   RequestCondition&lt;?&gt; condition = (element <span class="keyword">instanceof</span> Class ?</span><br><span class="line">         getCustomTypeCondition((Class&lt;?&gt;) element) : getCustomMethodCondition((Method) element));</span><br><span class="line">   <span class="comment">//3.如果注解非空，则根据注解对象真正执行创建 RequestMappingInfo对象</span></span><br><span class="line">   <span class="keyword">return</span> (requestMapping != <span class="literal">null</span> ? createRequestMappingInfo(requestMapping, condition) : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.registerHandlerMethod方法</p>
<p>作用：注册HandlerMethod相关映射到mappingRegistry属性中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerHandlerMethod</span><span class="params">(Object handler, Method method, T mapping)</span> &#123;</span><br><span class="line">   <span class="comment">//调用 mappingRegistry 属性对象的register方法</span></span><br><span class="line">   <span class="built_in">this</span>.mappingRegistry.register(mapping, handler, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8.MappingRegistry类的register方法</p>
<p>作用：将请求条件对象、handler的名字、Mthod反射对象转化一下注册到规范的三个Map中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(T mapping, Object handler, Method method)</span> &#123;</span><br><span class="line">   <span class="comment">//1.获取写锁 （此时不允许获取读锁和写锁）</span></span><br><span class="line">   <span class="built_in">this</span>.readWriteLock.writeLock().lock();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//2.调用 createHandlerMethod方法来创建HandlerMethod</span></span><br><span class="line">      <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> createHandlerMethod(handler, method);</span><br><span class="line">      <span class="comment">//3.校验要注册的HanderMethod是否已经注册，如果注册则判断是否矛盾 </span></span><br><span class="line">      validateMethodMapping(handlerMethod, mapping);</span><br><span class="line">	  <span class="comment">//4.获取请求条件对象的uri	</span></span><br><span class="line">      Set&lt;String&gt; directPaths = AbstractHandlerMethodMapping.<span class="built_in">this</span>.getDirectPaths(mapping);</span><br><span class="line">      <span class="comment">//5.以uri为key，请求条件对象为value添加到 pathLookup 映射【pathLookup初始化】</span></span><br><span class="line">      <span class="keyword">for</span> (String path : directPaths) &#123;</span><br><span class="line">         <span class="built_in">this</span>.pathLookup.add(path, mapping);</span><br><span class="line">      &#125;</span><br><span class="line">	  <span class="comment">//6.从handerMethod和mapping中获取name</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (getNamingStrategy() != <span class="literal">null</span>) &#123;</span><br><span class="line">         name = getNamingStrategy().getName(handlerMethod, mapping);</span><br><span class="line">         <span class="comment">//7.以name为key，handlerMethod为value添加到 nameLookup 映射【nameLookup初始化】 </span></span><br><span class="line">         addMappingName(name, handlerMethod);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//8. corsLookup初始化</span></span><br><span class="line">      <span class="type">CorsConfiguration</span> <span class="variable">corsConfig</span> <span class="operator">=</span> initCorsConfiguration(handler, method, mapping);</span><br><span class="line">      <span class="keyword">if</span> (corsConfig != <span class="literal">null</span>) &#123;</span><br><span class="line">         corsConfig.validateAllowCredentials();</span><br><span class="line">         <span class="built_in">this</span>.corsLookup.put(handlerMethod, corsConfig);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//9.以请求条件为key，以以上构建结果封装起来的MappingRegistration为value添加到 registry 映射【registry初始化】</span></span><br><span class="line">      <span class="built_in">this</span>.registry.put(mapping,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">MappingRegistration</span>&lt;&gt;(mapping, handlerMethod, directPaths, name, corsConfig != <span class="literal">null</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//10.释放写锁 </span></span><br><span class="line">      <span class="built_in">this</span>.readWriteLock.writeLock().unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先检查一下<strong>registry</strong>这个Map里是不是已经有这个匹配条件了，如果有而且所对应的值和现在传入的HandlerMethod不是同一个则抛出异常；否则<strong>依次添加到三个Map里</strong>。</p>
<h4 id="AbstractHandlerMethodMapping系列之用"><a href="#AbstractHandlerMethodMapping系列之用" class="headerlink" title="AbstractHandlerMethodMapping系列之用"></a>AbstractHandlerMethodMapping系列之用</h4><p>1.getHandlerInternal方法</p>
<p>作用：根据请求对象获取HandlerMethod对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerMethod <span class="title function_">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">//1.从请求对象提取 lookupPath</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">lookupPath</span> <span class="operator">=</span> initLookupPath(request);</span><br><span class="line">   <span class="comment">//2.获取读锁 </span></span><br><span class="line">   <span class="built_in">this</span>.mappingRegistry.acquireReadLock();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//3.根据请求路径查询对应的 HandlerMethod</span></span><br><span class="line">      <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> lookupHandlerMethod(lookupPath, request);</span><br><span class="line">      <span class="comment">//4.返回 </span></span><br><span class="line">      <span class="keyword">return</span> (handlerMethod != <span class="literal">null</span> ? handlerMethod.createWithResolvedBean() : <span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//5.释放读锁 </span></span><br><span class="line">      <span class="built_in">this</span>.mappingRegistry.releaseReadLock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.lookupHandlerMethod方法</p>
<p>作用：通过lookupPath和请求对象，从mappingRegistry查找对应最匹配的的HandlerMethod返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerMethod <span class="title function_">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//===========获取匹配项matches================    </span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//可能匹配的集合。内部类封装了 MappingRegistry的registry属性的键和值，即封装了请求条件和HandlerMethod</span></span><br><span class="line">   List&lt;Match&gt; matches = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">//1.根据lookupPath从 mappingRegistry的pathLookup属性中查找对应的多个请求条件对象集合</span></span><br><span class="line">   List&lt;T&gt; directPathMatches = <span class="built_in">this</span>.mappingRegistry.getMappingsByDirectPath(lookupPath);</span><br><span class="line">   <span class="comment">//2.如果非空，则遍历所有请求条件创建对应请求的请求条件对象，并创建对应Match将其添加到 matches集合。注意这里的请求条件已经根据请求对象发生了改变。</span></span><br><span class="line">   <span class="keyword">if</span> (directPathMatches != <span class="literal">null</span>) &#123;</span><br><span class="line">      addMatchingMappings(directPathMatches, matches, request);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3.如果matches集合为空，尝试将所有请求条件和handlerMethod的映射添加到matches，会通过请求条件对象的getMatchingCondition方法来校验当前请求是否匹配条件。</span></span><br><span class="line">   <span class="keyword">if</span> (matches.isEmpty()) &#123;</span><br><span class="line">      addMatchingMappings(<span class="built_in">this</span>.mappingRegistry.getRegistrations().keySet(), matches, request);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===============获取最匹配项bestMatch===========    </span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//4. 如果matches集合非空，即有符合的请求条件对象</span></span><br><span class="line">   <span class="keyword">if</span> (!matches.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">//5.对Match进行排序。底层是使用RequstCondition的compareTo方法实现的排序</span></span><br><span class="line">      <span class="type">Match</span> <span class="variable">bestMatch</span> <span class="operator">=</span> matches.get(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (matches.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">         Comparator&lt;Match&gt; comparator = <span class="keyword">new</span> <span class="title class_">MatchComparator</span>(getMappingComparator(request));</span><br><span class="line">         matches.sort(comparator);</span><br><span class="line">         <span class="comment">//6.取排序首位 </span></span><br><span class="line">         bestMatch = matches.get(<span class="number">0</span>);</span><br><span class="line">         <span class="comment">//7.如果是option类型请求返回一个默认的handlerMethod</span></span><br><span class="line">         <span class="keyword">if</span> (CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Match match : matches) &#123;</span><br><span class="line">               <span class="keyword">if</span> (match.hasCorsConfig()) &#123;</span><br><span class="line">                  <span class="keyword">return</span> PREFLIGHT_AMBIGUOUS_MATCH;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//7.如果是其它类型请求，获取第二匹配的匹配条件 </span></span><br><span class="line">            <span class="type">Match</span> <span class="variable">secondBestMatch</span> <span class="operator">=</span> matches.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//如果匹配程度相等，则抛出异常 </span></span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> bestMatch.getHandlerMethod().getMethod();</span><br><span class="line">               <span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> secondBestMatch.getHandlerMethod().getMethod();</span><br><span class="line">               <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                     <span class="string">&quot;Ambiguous handler methods mapped for &#x27;&quot;</span> + uri + <span class="string">&quot;&#x27;: &#123;&quot;</span> + m1 + <span class="string">&quot;, &quot;</span> + m2 + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> <span class="comment">//8.设置请求属性，将请求的handlerMethod设置进去</span></span><br><span class="line">       request.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.getHandlerMethod());</span><br><span class="line">      <span class="comment">//9. 匹配成功后的一些处理</span></span><br><span class="line">      handleMatch(bestMatch.mapping, lookupPath, request);</span><br><span class="line">      <span class="comment">//10.返回最匹配的对应的 HandlerMethod</span></span><br><span class="line">      <span class="keyword">return</span> bestMatch.getHandlerMethod();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">       </span><br><span class="line"><span class="comment">//==================匹配失败===============       </span></span><br><span class="line">       </span><br><span class="line">      <span class="comment">//4.匹配项集合为空，调用 handleNoMatch方法，匹配失败后的一些处理</span></span><br><span class="line">      <span class="keyword">return</span> handleNoMatch(<span class="built_in">this</span>.mappingRegistry.getRegistrations().keySet(), lookupPath, request);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4小结"><a href="#2-4小结" class="headerlink" title="2.4小结"></a>2.4小结</h3><p>HandlerMapping的整体结构在AbstractHandlerMapping中设计，简单来说<strong>其功能就是根据request找到Handler和Interceptors，组合成HandlerExecutionChain类型并返回</strong>。找到Handler的过程通过模板方法getHandlerInternal留给子类实现，<strong>查找Interceptors则是AbstractHandlerMapping自己完成的</strong>。</p>
<p>//TODO RequestMappingHandlerMapping.java源码待解析</p>
<h2 id="3-HandlerAdapter"><a href="#3-HandlerAdapter" class="headerlink" title="3.HandlerAdapter"></a>3.HandlerAdapter</h2><p>HandlerAdapter是具体使用Handler来干活的，<strong>每个HandlerAdapter封装了一种Handler的具体使用方法</strong>。</p>
<p><img src="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/image-20240325220431900.png" alt="image-20240325220431900"></p>
<p>RequestMappingHandlerAdapter的实现非常复杂，而其它的非常简单，因为其它三个Handler的格式都是固定的，只需要调用固定的方法即可，但是RequestMappingHandlerAdapter所处理的<strong>Handler可以是任意的方法</strong>，没有任何约束，这就极大地增加了难度。</p>
<h3 id="3-1RequestMappingHandlerAdapter概述"><a href="#3-1RequestMappingHandlerAdapter概述" class="headerlink" title="3.1RequestMappingHandlerAdapter概述"></a>3.1RequestMappingHandlerAdapter概述</h3><p>AbstractHandlerMethodAdapter非常简单，三个接口方法分别调用了自定义的模板方法supportsInternal、handleInternal、getLastModifiedInternal。即<strong>它只支持handler类型为HandlerMethod类型</strong>。</p>
<blockquote>
<p>RequestMappingHandlerAdapter是Spring MVC最复杂的组件！！！</p>
</blockquote>
<p><strong>核心方法就是handleInternal方法</strong>。这个方法是实际使用Handler处理请求的方法。具体过程大致分为三步：</p>
<ol>
<li><strong>准备</strong>好处理器所需要的<strong>参数</strong>。</li>
<li><strong>使用处理器处理请求</strong>。</li>
<li><strong>处理返回值</strong>，也就是将不同类型的返回值统一处理成ModelAndView类型。</li>
</ol>
<p>这三步里面第2步是最简单的，直接使用反射技术调用处理器执行就可以了，第三步也还算简单，<strong>最麻烦的是第一步</strong>。</p>
<p>这第一步根据处理器的需要设置参数，而参数类型、个数都是不确定的，所以难度非常大。</p>
<p>参数具体解析是使用<strong>HandlerMethodArgumentResolver</strong>类型的组件完成的，不同类型的参数使用不同的ArgumentResolver来解析。</p>
<p><strong>@InitBinder注解</strong></p>
<p>只用于注解在方法上，有@InitBinder注解的方法用于初始化WebDataBinder，我们可以在其中<strong>做一些WebDataBinder初始化的工作</strong>，如<strong>注册校验器、注册自己的参数编辑器</strong>等。</p>
<p>可以在Controller中通过以下代码<strong>注册一个转换Date类型的编辑器</strong>，这样就可以将”yyyy-MM-dd”类型的String转换成Date类型。</p>
<p><img src="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/image-20240326212215593.png" alt="image-20240326212215593"></p>
<p><strong>@ModelAttribute注解</strong></p>
<p><strong>@ModelAttribute注解如果用在方法上，则用于设置参数</strong>，它会在执行处理（执行HandlerMethod前）前将参数设置到Model中。</p>
<p><strong>@ModelAttribute注解如果用在参数上，则表示需要使用</strong>指定的ArgumentResolver来解析参数。</p>
<p>如果想<strong>让以上两个注解在所有处理器中都起作用</strong>，我们可以定义一个类，然后在类上加@ControllerAdvice注解，并将@InitBinder、@ModelAttribute注释的方法放进去就可以了，这样每个Handler调用前都会调用这些方法。</p>
<h3 id="3-2RequestMappingHandlerAdapter自身结构"><a href="#3-2RequestMappingHandlerAdapter自身结构" class="headerlink" title="3.2RequestMappingHandlerAdapter自身结构"></a>3.2RequestMappingHandlerAdapter自身结构</h3><p>RequestMappingHandlerAdapter自身的结构并不复杂，不过其中使用了很多组件。所以要准确理解各个组件的作用。</p>
<h4 id="创建RequestMappingHandlerAdapter之器"><a href="#创建RequestMappingHandlerAdapter之器" class="headerlink" title="创建RequestMappingHandlerAdapter之器"></a>创建RequestMappingHandlerAdapter之器</h4><p>RequestMappingHandlerAdapter的创建在<strong>afterPropertiesSet方法</strong>中实现。</p>
<p>1.afterPropertiesSet方法</p>
<p>作用：初始化 RequestMappingHandlerAdapter 的6个属性组件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//1.通过@ContorllerAdvice注解的类初始化属性modelAttributeAdviceCache、initBinderAdviceCache、requestResponseBodyAdvice</span></span><br><span class="line">   initControllerAdviceCache();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.初始化属性 argumentResolvers。用于处理参数</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.argumentResolvers == <span class="literal">null</span>) &#123;</span><br><span class="line">      List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();</span><br><span class="line">      <span class="built_in">this</span>.argumentResolvers = <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>().addResolvers(resolvers);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3.初始化属性 initBinderArgumentResolvers。</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.initBinderArgumentResolvers == <span class="literal">null</span>) &#123;</span><br><span class="line">      List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();</span><br><span class="line">      <span class="built_in">this</span>.initBinderArgumentResolvers = <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>().addResolvers(resolvers);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//4.初始化属性 returnValueHandlers。</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.returnValueHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">      List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();</span><br><span class="line">      <span class="built_in">this</span>.returnValueHandlers = <span class="keyword">new</span> <span class="title class_">HandlerMethodReturnValueHandlerComposite</span>().addHandlers(handlers);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>介绍一下这六个属性：</p>
<ul>
<li>argumentResolvers：用于给<strong>处理器方法</strong>和<strong>注解了@ModelAttribute的方法</strong>设置参数。</li>
<li>initBinderArgumentResolvers：用于给注解了@InitBinder的方法设置参数。</li>
<li>returnValueHandlers：用于将处理器的返回值处理成ModelAndVieW的类型。</li>
<li>modelAttributeAdviceCache和initBinderAdviceCache：分别用于缓存@ControllerAdvice注解里面注释了@ModelAttribute和@InitBinder的方法，也就是<strong>全局的@ModelAttribute和@InitBinder的方法</strong>。而每个处理器自己的@ModelAttribute和@InitBinder的方法是在第一次使用处理器处理请求时缓存起来的。</li>
<li>requestResponseBodyAdvice：用来保存实现了RequestBodyAdvice或者ResponseBodyAdvice接口的类。</li>
</ul>
<p>这些属性都是复数形式，也就是可以有多个，在使用的时候是按顺序调用的，所以这些属性初始化时的添加顺序就非常重要了。</p>
<p>2.initControllerAdviceCache方法</p>
<p>作用：<strong>从容器中</strong>获取bean来初始化modelAttributeAdviceCache、initBinderAdviceCache和requestResponseBodyAdvice属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initControllerAdviceCache</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (getApplicationContext() == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//1.从容器中获取所有注释了 @ControllerAdvice的bean，并封装成ControllerAdviceBean集合</span></span><br><span class="line">   List&lt;ControllerAdviceBean&gt; adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());</span><br><span class="line"></span><br><span class="line">   List&lt;Object&gt; requestResponseBodyAdviceBeans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.遍历 adviceBeans 集合</span></span><br><span class="line">   <span class="keyword">for</span> (ControllerAdviceBean adviceBean : adviceBeans) &#123;</span><br><span class="line">      <span class="comment">//2.1获取 adviceBean 的类型 beanType</span></span><br><span class="line">      Class&lt;?&gt; beanType = adviceBean.getBeanType();</span><br><span class="line">      <span class="keyword">if</span> (beanType == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unresolvable type for ControllerAdviceBean: &quot;</span> + adviceBean);</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//2.2获取 beanType 中所有的 注解了@ModelAttribute的方法 attrMethods</span></span><br><span class="line">      Set&lt;Method&gt; attrMethods = MethodIntrospector.selectMethods(beanType, MODEL_ATTRIBUTE_METHODS);</span><br><span class="line">      <span class="comment">//2.3向 【modelAttributeAdviceCache 属性】中添加 adviceBean 对 attrMethods 的映射</span></span><br><span class="line">      <span class="keyword">if</span> (!attrMethods.isEmpty()) &#123;</span><br><span class="line">         <span class="built_in">this</span>.modelAttributeAdviceCache.put(adviceBean, attrMethods);</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//2.4获取 beanType 中所有的 注解了@InitBinder的方法 binderMethods</span></span><br><span class="line">      Set&lt;Method&gt; binderMethods = MethodIntrospector.selectMethods(beanType, INIT_BINDER_METHODS);</span><br><span class="line">      <span class="comment">//2.5向 【initBinderAdviceCache 属性】中添加 adviceBean 对 binderMethods 的映射</span></span><br><span class="line">      <span class="keyword">if</span> (!binderMethods.isEmpty()) &#123;</span><br><span class="line">         <span class="built_in">this</span>.initBinderAdviceCache.put(adviceBean, binderMethods);</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//2.6如果beanType是 RequestBodyAdvice 或者 ResponseBodyAdvice，则向 requestResponseBodyAdviceBeans集合 中添加adviceBean</span></span><br><span class="line">      <span class="keyword">if</span> (RequestBodyAdvice.class.isAssignableFrom(beanType) || ResponseBodyAdvice.class.isAssignableFrom(beanType)) &#123;</span><br><span class="line">         requestResponseBodyAdviceBeans.add(adviceBean);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.如果 requestResponseBodyAdviceBeans 集合非空，则向 【requestResponseBodyAdvice 属性】中添加 requestResponseBodyAdviceBeans</span></span><br><span class="line">   <span class="keyword">if</span> (!requestResponseBodyAdviceBeans.isEmpty()) &#123;</span><br><span class="line">      <span class="built_in">this</span>.requestResponseBodyAdvice.addAll(<span class="number">0</span>, requestResponseBodyAdviceBeans);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.getDefualtXXX方法</p>
<p>作用：<strong>通过new</strong>直接创建组件初始化argumentResolvers、initBinderArgumentResolvers、returnValueHandlers属性。</p>
<p>参数解析器分为四类：通过注解解析的解析器、通过类型解析的解析器、自定义的解析器和可以解析所有类型的解析器。</p>
<p><strong>通过定义内置的参数解析器，也相当于定义了方法参数的来源</strong>。</p>
<h4 id="RequestMappingHandlerAdapter之用"><a href="#RequestMappingHandlerAdapter之用" class="headerlink" title="RequestMappingHandlerAdapter之用"></a>RequestMappingHandlerAdapter之用</h4><p>RequestMappingHandlerAdapter处理请求的<strong>入口方法是handleInternal</strong>。</p>
<h5 id="1-handleInternal方法"><a href="#1-handleInternal方法" class="headerlink" title="1.handleInternal方法"></a>1.handleInternal方法</h5><p>作用：校验请求、执行请求、添加Cache-Control响应头</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">handleInternal</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">      HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">   ModelAndView mav;</span><br><span class="line">   <span class="comment">//1.根据请求对象的类型和session校验请求 （默认情况下校验跳过）</span></span><br><span class="line">   checkRequest(request);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">      <span class="comment">//2.获取请求session对象 </span></span><br><span class="line">      <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(<span class="literal">false</span>);</span><br><span class="line">      <span class="comment">//3.如果session非空 </span></span><br><span class="line">      <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">//3.1获取session对应的锁对象 </span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">mutex</span> <span class="operator">=</span> WebUtils.getSessionMutex(session);</span><br><span class="line">         <span class="comment">//3.2线程获取锁对象，然后调用 invokeHandlerMethod 方法</span></span><br><span class="line">         <span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">            mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// No HttpSession available -&gt; no mutex necessary</span></span><br><span class="line">         <span class="comment">//3.如果session对象为空，则直接调用 invokeHandlerMethod 方法</span></span><br><span class="line">         mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// No synchronization on session demanded at all...</span></span><br><span class="line">      <span class="comment">//2.直接调用 invokeHandlerMethod 方法</span></span><br><span class="line">      mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//4.如果响应头还没有设置Cache-Control,则处理设置相应头 (默认会进入代码块，这里设置Cache-Control响应头控制浏览器响应缓存)【实现逻辑：如果有@SessionAttributes注解则阻止使用缓存，否则什么也不做】</span></span><br><span class="line">   <span class="keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">         <span class="comment">//second = 0，阻止浏览器使用缓存 </span></span><br><span class="line">         applyCacheSeconds(response, <span class="built_in">this</span>.cacheSecondsForSessionAttributeHandlers);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//默认执行 second = -1 ，即什么也不执行</span></span><br><span class="line">         prepareResponse(response);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//5.返回modelandview </span></span><br><span class="line">   <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里真正起作用的代码只有两句，也是两个方法：checkRequest和<strong>invokeHandlerMethod</strong>方法。这个方法通过synchronizeOnSession属性设置是否通过同步session来执行方法。</p>
<p>如果handlerMethod方法参数中带有注解@SessionAttributes，就会执行applyCacheSeconds(response,0（默认的）)方法，如果没有就会执行prepareResponse(response) -&gt; applyCacheSeconds(response,-1（默认的）)方法。</p>
<p>applyCacheSeconds会调用applyCacheControl，并根据second不同设置不同的Cache-Control响应头，以控制浏览器对响应的缓存策略。</p>
<p>RequestMappingHandlerAdapter的cacheSecondsForSessionAttributeHandlers和cacheSeconds属性其实<strong>与服务端的Session超时并没有关系</strong>，而是<strong>用于设置客户端浏览器</strong>response<strong>缓存</strong>相关的Header参数。</p>
<p><strong>@SessionAttributes注解</strong></p>
<ul>
<li><p>设置：在controller类上注解@SessionAttributes()，设置模型Model中要保存到SessionAttribute的属性名和类型，然后在处理器中将参数设置到model中。</p>
</li>
<li><p>使用：后续请求直接从Model获取或者@ModelAttribute的参数获取。</p>
</li>
</ul>
<h5 id="2-invokeHandleMethod方法"><a href="#2-invokeHandleMethod方法" class="headerlink" title="2.invokeHandleMethod方法"></a>2.invokeHandleMethod方法</h5><p>这个方法非常重要，它具体执行请求的处理。</p>
<p>invokeHandlerMethod方法<strong>首先</strong>使用request和response创建了ServletWebRequest类，在<strong>ArgumentResolver解析参数时使用的request就是这个webRequest</strong>。</p>
<p>接着对WebDataBinderFactory、ModelFactory、ServletInvocableHandlerMethod这三个类型的变量进行了定义和初始化。</p>
<p><strong>WebDataBinderFactory</strong></p>
<p>作用：是<strong>用来创建 WebDataBinder</strong> 的，WebDataBinder用于参数绑定，主要功能就是实现参数跟String之间的类型转换。<strong>ArgumentResolver在进行参数解析的过程中会用到WebDataBinder</strong>，另外ModelFactory在更新Model时也会用到它。</p>
<p><strong>WebDataBinder</strong></p>
<p>继承自DataBinder类，有三个直接实现类。</p>
<p><img src="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/image-20240330210602752.png" alt="image-20240330210602752"></p>
<p>先来看一下DataBinder。它实现了两个接口TypeConverter、PropertyEditorRegistry，即DataBinder和WebDataBinder是一个类型转换器和属性编辑注册器。通过属性编辑注册器接口来注册属性编辑器到DataBinder，再<strong>通过属性编辑器实现类型转换器</strong>（java内置提供了一些属性编辑器来实现string=&gt;目标类型的转换）。</p>
<p>即DataBinder核心是类型转换器，而类型转换器的核心是属性编辑器。类型转换器提供了方便的高层封装方法。</p>
<p><img src="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/image-20240330214201233.png" alt="image-20240330214201233"></p>
<p>类型转换器接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TypeConverter</span> &#123;</span><br><span class="line">    <span class="comment">//1.将value转换为指定requiredType类型</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">convertIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> Object value, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> TypeMismatchException;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.将value转换为指定类型requiredType类型，并提供了参数反射对象的封装MethodParameter对象</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">convertIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> Object value, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> MethodParameter methodParam)</span> <span class="keyword">throws</span> TypeMismatchException;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.将value转换为指定类型requiredType类型，并提供了对象的Field属性反射对象</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">convertIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> Object value, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Field field)</span></span><br><span class="line">			<span class="keyword">throws</span> TypeMismatchException;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.将value转换为指定类型requiredType类型，并提供了类型描述对象TypeDescriptor</span></span><br><span class="line">    <span class="keyword">default</span> &lt;T&gt; T <span class="title function_">convertIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> Object value, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> TypeDescriptor typeDescriptor)</span> <span class="keyword">throws</span> TypeMismatchException &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;TypeDescriptor resolution not supported&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>属性编辑器注册器接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PropertyEditorRegistry</span> &#123;</span><br><span class="line">    <span class="comment">//1.注册针对requiredType类型的属性编辑器</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerCustomEditor</span><span class="params">(Class&lt;?&gt; requiredType, PropertyEditor propertyEditor)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.注册针对requiredType类型和指定属性路径（属性名/嵌套属性名路径）的属性编辑器</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerCustomEditor</span><span class="params">(<span class="meta">@Nullable</span> Class&lt;?&gt; requiredType, <span class="meta">@Nullable</span> String propertyPath, PropertyEditor propertyEditor)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.查找指定类型和指定路径的属性编辑器</span></span><br><span class="line">    PropertyEditor <span class="title function_">findCustomEditor</span><span class="params">(<span class="meta">@Nullable</span> Class&lt;?&gt; requiredType, <span class="meta">@Nullable</span> String propertyPath)</span>;</span><br></pre></td></tr></table></figure>

<p>DataBinder的作用如下：Binder that allows for setting property values on a target object, including support for validation and binding result analysis.可以<strong>设置对象属性，并进行校验和绑定结果分析</strong>。</p>
<p>WebDataBinderFactory的创建过程就是将符合条件的注释了@InitBinder的方法找出来，并使用它们创建出ServletRequestDataBinderFactory类型的WebDataBinderFactory。</p>
<p>1.getDataBinderFactory方法</p>
<p>作用：使用HandlerMethod创建WebDataBinderFactory</p>
<p>WebDataBinderFactory的创建过程就是<strong>将符合条件的注释了@InitBinder的方法找出来</strong>，并使用它们创建出<strong>ServletRequestDataBinderFactory</strong>类型的WebDataBinderFactory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> WebDataBinderFactory <span class="title function_">getDataBinderFactory</span><span class="params">(HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">//1.通过 HandlerMethod 获取方法所在的bean类型，即处理器类型</span></span><br><span class="line">   Class&lt;?&gt; handlerType = handlerMethod.getBeanType();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//=====查找处理器级别的@InitBinder注解的方法============    </span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//2.以处理器类型为key在 initBinderCache 查找方法反射对象集合</span></span><br><span class="line">    Set&lt;Method&gt; methods = <span class="built_in">this</span>.initBinderCache.get(handlerType);</span><br><span class="line">   <span class="comment">//3.如果为空，则进行初始化（方法调用时初始化处理器中的@InitBinder注解的方法，懒加载机制） </span></span><br><span class="line">   <span class="keyword">if</span> (methods == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//使用 MethodIntrospector.selectMethods来查找处理器类型进行初始化</span></span><br><span class="line">      methods = MethodIntrospector.selectMethods(handlerType, INIT_BINDER_METHODS);</span><br><span class="line">      <span class="built_in">this</span>.initBinderCache.put(handlerType, methods);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//4.创建一个 【initBinderMethods 集合】。存储元素类型为InvocableHandlerMethod</span></span><br><span class="line">   List&lt;InvocableHandlerMethod&gt; initBinderMethods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//=====查找全局级别的@InitBinder注解的方法===========    </span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//5.从 initBinderAdviceCache 获取@InitBinder注解的方法，并封装到 initBinderMethods 集合</span></span><br><span class="line"><span class="built_in">this</span>.initBinderAdviceCache.forEach((controllerAdviceBean, methodSet) -&gt; &#123;</span><br><span class="line">      <span class="comment">//5.1如果 controllerAdviceBean 支持该 handlerType</span></span><br><span class="line">      <span class="keyword">if</span> (controllerAdviceBean.isApplicableToBeanType(handlerType)) &#123;</span><br><span class="line">         <span class="comment">//5.2从 controllerAdviceBean 解析出对应的bean对象</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> controllerAdviceBean.resolveBean();</span><br><span class="line">         <span class="comment">//5.3遍历反射方法，封装添加到 initBinderMethods【全局方法添加】</span></span><br><span class="line">         <span class="keyword">for</span> (Method method : methodSet) &#123;</span><br><span class="line">      initBinderMethods.add(createInitBinderMethod(bean, method));</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//======封装处理器级别的@InitBinder注解的方法===========</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//6.遍历处理器级别的 @InitBinder注解的方法反射对象</span></span><br><span class="line">   <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">      <span class="comment">//6.1获取方法所属bean对象/名字 </span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> handlerMethod.getBean();</span><br><span class="line">      <span class="comment">//6.2封装添加到 initBinderMethods【处理器级别方法添加】</span></span><br><span class="line">      initBinderMethods.add(createInitBinderMethod(bean, method));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> createDataBinderFactory(initBinderMethods);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入方法所属bean和方法反射对象，创建InvocableHandlerMethod</span></span><br><span class="line"><span class="comment">//InvocableHandlerMethod 是 HandlerMethod 的子类</span></span><br><span class="line"><span class="keyword">private</span> InvocableHandlerMethod <span class="title function_">createInitBinderMethod</span><span class="params">(Object bean, Method method)</span> &#123;</span><br><span class="line">    <span class="comment">//1.直接new创建InvocableHandlerMethod</span></span><br><span class="line">    <span class="type">InvocableHandlerMethod</span> <span class="variable">binderMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocableHandlerMethod</span>(bean, method);</span><br><span class="line">    <span class="comment">//2.设置binderMethod initBinderArgumentResolvers参数解析器，用于解析@InitBinder注解的方法参数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.initBinderArgumentResolvers != <span class="literal">null</span>) &#123;</span><br><span class="line">        binderMethod.setHandlerMethodArgumentResolvers(<span class="built_in">this</span>.initBinderArgumentResolvers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.设置binderMethod DataBinderFactory，用于参数绑定</span></span><br><span class="line">    binderMethod.setDataBinderFactory(<span class="keyword">new</span> <span class="title class_">DefaultDataBinderFactory</span>(<span class="built_in">this</span>.webBindingInitializer));</span><br><span class="line">    <span class="comment">//4.设置binderMethod 参数名发现器</span></span><br><span class="line">    binderMethod.setParameterNameDiscoverer(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line">    <span class="keyword">return</span> binderMethod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终创建的是 ServletRequestDataBinderFactory 类型的 InitBinderDataBinderFactory</span></span><br><span class="line"><span class="keyword">protected</span> InitBinderDataBinderFactory <span class="title function_">createDataBinderFactory</span><span class="params">(List&lt;InvocableHandlerMethod&gt; binderMethods)</span></span><br><span class="line">			<span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServletRequestDataBinderFactory</span>(binderMethods, getWebBindingInitializer());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p><strong>ModelFactory</strong></p>
<p>ModelFactory 是用来处理Model的，主要包含两个功能：1.<strong>在处理器具体处理之前对Model进行初始化</strong>，2.<strong>在处理完请求后对Model参数进行更新</strong>。</p>
<p>对Model初始化具体包括三部分内容：1.将原来的SessionAttributes中的值设置到Model；2.执行相应注释了@ModelAttribute的方法并将其设置到Model;3.处理器中注释了@ModelAttribute的参数如果同时在SessionAttributes也配置了，而且在mavContainer中还没有值则从全部SessionAttributes（可能是其它处理器设置的值）中查找出并设置进去。</p>
<p>2.getModelFactory方法</p>
<p>作用：使用HandlerMethod和WebDataBinderFactory创建ModelFactory</p>
<p>ModelFactory的创建过程就是<strong>将注释了@ModelAttribute却没有注释@RequestMapping的方法找出来</strong>，<strong>并使用它们创建出ModelFactory对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ModelFactory <span class="title function_">getModelFactory</span><span class="params">(HandlerMethod handlerMethod, WebDataBinderFactory binderFactory)</span> &#123;</span><br><span class="line">   <span class="comment">//1.从sessionAttributesHandlerCache根据 handlerMethod获取SessionAttributesHandler对象</span></span><br><span class="line">   <span class="type">SessionAttributesHandler</span> <span class="variable">sessionAttrHandler</span> <span class="operator">=</span> getSessionAttributesHandler(handlerMethod);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=========查找处理器级别的@ModelAttribute方法=========== </span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//2.从 handlerMethod获取处理器类型</span></span><br><span class="line">   Class&lt;?&gt; handlerType = handlerMethod.getBeanType();</span><br><span class="line">   <span class="comment">//3.从 modelAttributeCache 根据handlerType获取@ModelAttribute的反射方法</span></span><br><span class="line">    Set&lt;Method&gt; methods = <span class="built_in">this</span>.modelAttributeCache.get(handlerType);</span><br><span class="line">   <span class="comment">//4.若为空，则进行初始化（方法调用时初始化处理器中的@ModelAttribute注解的方法，懒加载机制）</span></span><br><span class="line">   <span class="keyword">if</span> (methods == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//从方法反射对象中获取没有@RequestMapping注解但有@ModelAttribute注解的方法</span></span><br><span class="line">      methods = MethodIntrospector.selectMethods(handlerType, MODEL_ATTRIBUTE_METHODS);</span><br><span class="line">    <span class="comment">//将处理器类型和反射方法映射放入 modelAttributeCache缓存</span></span><br><span class="line">      <span class="built_in">this</span>.modelAttributeCache.put(handlerType, methods);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//5.创建 【InvocableHandlerMethod 的集合】</span></span><br><span class="line">   List&lt;InvocableHandlerMethod&gt; attrMethods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//============处理器全局级别@ModelAttribute方法=========</span></span><br><span class="line">    </span><br><span class="line"> 	<span class="comment">//6.遍历 modelAttributeAdviceCache</span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">this</span>.modelAttributeAdviceCache.forEach((controllerAdviceBean, methodSet) -&gt; &#123;</span><br><span class="line">      <span class="comment">//6.1如果controllerAdviceBean支持handlerType</span></span><br><span class="line">      <span class="keyword">if</span> (controllerAdviceBean.isApplicableToBeanType(handlerType)) &#123;</span><br><span class="line">         <span class="comment">//6.2获取 controllerAdviceBean 的bean对象</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> controllerAdviceBean.resolveBean();</span><br><span class="line">         <span class="comment">//6.3遍历对应的 methodSet</span></span><br><span class="line">         <span class="keyword">for</span> (Method method : methodSet) &#123;</span><br><span class="line">		<span class="comment">//6.4调用createModelAttributeMethod方法创建InvocableHandlerMethod并添加到 attrMethods集合。</span></span><br><span class="line">             attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//============处理处理器级别@ModelAttribute方法===========</span></span><br><span class="line">   <span class="comment">//7.遍历处理器级别的 @ModelAttribute反射方法</span></span><br><span class="line">   <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">      <span class="comment">//7.1获取处理器的bean对象 </span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> handlerMethod.getBean();</span><br><span class="line">     <span class="comment">//7.2调用createModelAttributeMethod方法创建InvocableHandlerMethod并添加到 attrMethods集合。</span></span><br><span class="line">       attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//8.创建 ModelFactory 对象，封装attrMethods、binderFactory、sessionAttrHandler</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelFactory</span>(attrMethods, binderFactory, sessionAttrHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取HandlerMethod对应的SessionAttributesHandler</span></span><br><span class="line"><span class="keyword">private</span> SessionAttributesHandler <span class="title function_">getSessionAttributesHandler</span><span class="params">(HandlerMethod handlerMethod)</span> &#123;</span><br><span class="line">    <span class="comment">//依据HandlerMethod的beanType从sessionAttributesHandlerCache获取，如果获取不到，则new 创建指定type的SessionAttributesHandler</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.sessionAttributesHandlerCache.computeIfAbsent(</span><br><span class="line">            handlerMethod.getBeanType(),</span><br><span class="line">            type -&gt; <span class="keyword">new</span> <span class="title class_">SessionAttributesHandler</span>(type, <span class="built_in">this</span>.sessionAttributeStore));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ServletInvocableHandlerMethod</strong></p>
<p><strong>非常重要</strong>，它继承自HandlerMethod，并且可以直接执行。<strong>实际请求的处理就是通过它来执行的，参数绑定、处理请求以及返回值处理都在它里边完成</strong>。</p>
<p>3.createInvocableHandlerMethod方法</p>
<p>作用：封装HandlerMethod为ServletInvocableHandlerMethod对象，提供执行方法、绑定参数、处理返回值的场所。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ServletInvocableHandlerMethod <span class="title function_">createInvocableHandlerMethod</span><span class="params">(HandlerMethod handlerMethod)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServletInvocableHandlerMethod</span>(handlerMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建三个变量(binderFactory、modelFactory、invocableMethod)后，还有三步（这里省略了异步处理）：<br>1.新建传递参数的ModelAndViewContainer容器，并将相应参数设置到Model中，<br>2.执行请求，<br>3.请求处理完后进行一些后置处理。</p>
<p><strong>4.invokeHandlerMethod方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">      HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1.使用 request、response封装成ServletWebRequest</span></span><br><span class="line">   <span class="type">ServletWebRequest</span> <span class="variable">webRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//2.使用 handlerMethod 创建 binderFactory 对象（处理@InitBinder注解）</span></span><br><span class="line">      <span class="type">WebDataBinderFactory</span> <span class="variable">binderFactory</span> <span class="operator">=</span> getDataBinderFactory(handlerMethod);</span><br><span class="line">      <span class="comment">//3.使用 handlerMethod、binderFactory创建 ModelFactory（处理@ModelAttribute注解）</span></span><br><span class="line">      <span class="type">ModelFactory</span> <span class="variable">modelFactory</span> <span class="operator">=</span> getModelFactory(handlerMethod, binderFactory);</span><br><span class="line">	  <span class="comment">//4.使用 handlerMethod 创建 invocableMethod	</span></span><br><span class="line">      <span class="type">ServletInvocableHandlerMethod</span> <span class="variable">invocableMethod</span> <span class="operator">=</span> createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">      <span class="comment">//4.1设置 invocableMethod 的方法参数解析器，将adapter的参数解析器传递给invocableMethod</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.argumentResolvers != <span class="literal">null</span>) &#123;</span><br><span class="line">         invocableMethod.setHandlerMethodArgumentResolvers(<span class="built_in">this</span>.argumentResolvers);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//4.2设置 invocableMethod 的方法返回值处理器</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.returnValueHandlers != <span class="literal">null</span>) &#123;</span><br><span class="line">         invocableMethod.setHandlerMethodReturnValueHandlers(<span class="built_in">this</span>.returnValueHandlers);</span><br><span class="line">      &#125;</span><br><span class="line"> <span class="comment">//4.3设置 invocableMethod 的参数绑定工厂</span></span><br><span class="line">      invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line"> <span class="comment">//4.4设置 invocableMethod 的参数名发现器</span></span><br><span class="line">       invocableMethod.setParameterNameDiscoverer(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//5.创建  ModelAndViewContainer 对象</span></span><br><span class="line">      <span class="type">ModelAndViewContainer</span> <span class="variable">mavContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndViewContainer</span>();</span><br><span class="line">     <span class="comment">//6.将request请求中inputfalshmap的重定向传递属性添加到mavContainer</span></span><br><span class="line">       mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">      <span class="comment">//7. 使用modelFactory初始化mavContainer中的model</span></span><br><span class="line">      modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">     <span class="comment">//8.设置mavContainer属性ignoreDefaultModelOnRedirect</span></span><br><span class="line">       mavContainer.setIgnoreDefaultModelOnRedirect(<span class="built_in">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line">	  <span class="comment">//9.异步处理</span></span><br><span class="line">      <span class="type">AsyncWebRequest</span> <span class="variable">asyncWebRequest</span> <span class="operator">=</span> WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">      asyncWebRequest.setTimeout(<span class="built_in">this</span>.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">      <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">      asyncManager.setTaskExecutor(<span class="built_in">this</span>.taskExecutor);</span><br><span class="line">      asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">      asyncManager.registerCallableInterceptors(<span class="built_in">this</span>.callableInterceptors);</span><br><span class="line">      asyncManager.registerDeferredResultInterceptors(<span class="built_in">this</span>.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">         <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> asyncManager.getConcurrentResult();</span><br><span class="line">         mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">         asyncManager.clearConcurrentResult();</span><br><span class="line">         LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">formatted</span> <span class="operator">=</span> LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Resume with async result [&quot;</span> + formatted + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">         &#125;);</span><br><span class="line">         invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//10.使用 invocableMethod 调用invokeAndHandle方法真正调用处理器方法</span></span><br><span class="line">      invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">      <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//11.方法调用后处理，返回ModelAndView</span></span><br><span class="line">      <span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      webRequest.requestCompleted();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.getModelAndView方法</p>
<p>作用：使用ModelAndViewContainer、ModelFactory、NativeWebRequest创建ModelAndView对象，对请求调用进行后处理</p>
<p>1.调用ModelFactory的updateModel方法更新Model<br>2.根据mavContainer创建MdoelAndView<br>3.如果mavContainer里的model是RedirectAttributes类型，将其设置到FlashMap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ModelAndView <span class="title function_">getModelAndView</span><span class="params">(ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">      ModelFactory modelFactory, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">//1.使用modelFactory来更新mavContainer中的Model（包括更新Model对应的SessionAttributes和Model设置BindingResult）</span></span><br><span class="line">   modelFactory.updateModel(webRequest, mavContainer);</span><br><span class="line">   <span class="comment">//2.使用mavContainer来判断请求是否已经被处理，已被处理则直接返回null</span></span><br><span class="line">   <span class="keyword">if</span> (mavContainer.isRequestHandled()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3.从 mavContainer 获取model</span></span><br><span class="line">   <span class="type">ModelMap</span> <span class="variable">model</span> <span class="operator">=</span> mavContainer.getModel();</span><br><span class="line">   <span class="comment">//4.依据mavContainer的视图名称、model模型内容、状态创建ModelAndView对象</span></span><br><span class="line">   <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(mavContainer.getViewName(), model, mavContainer.getStatus());</span><br><span class="line">   <span class="comment">//5.如果 mavContainer的view属性不是字符串，则直接设置到mav的view属性中</span></span><br><span class="line">   <span class="keyword">if</span> (!mavContainer.isViewReference()) &#123;</span><br><span class="line">      mav.setView((View) mavContainer.getView());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//6.如果 mavContainer 中的model是RedirectAttributes类型，则获取model中的flashAttributes，并设置到请求属性中。(只有返回redirct视图时此块代码才会调用)</span></span><br><span class="line">   <span class="keyword">if</span> (model <span class="keyword">instanceof</span> RedirectAttributes) &#123;</span><br><span class="line">      Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();</span><br><span class="line">      <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">      <span class="keyword">if</span> (request != <span class="literal">null</span>) &#123;</span><br><span class="line">         RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//7.返回创建的mav </span></span><br><span class="line">   <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<strong>model只有处理器在返回redirect类型的视图才可能是RedirectAttributes类型</strong>，否则不会是RedirectAttributes类型，也就是说在不返回redirect类型视图的处理器中即使使用RedirectAttributes设置了变量也不会保存到FlashMap中。</p>
<h3 id="3-3ModelAndViewContainer"><a href="#3-3ModelAndViewContainer" class="headerlink" title="3.3ModelAndViewContainer"></a>3.3ModelAndViewContainer</h3><p>在 RequestMappingHandlerAdapter 的 invokeHandlerMethod方法 中创建并使用。</p>
<p>ModelAndViewContainer承担着整个请求过程中数据的传递工作。</p>
<ul>
<li>在处理器中使用了 Model 或者 ModelMap 时<strong>ArgumentResolver会传入defaultModel</strong>，它是BindingAwareModelMap类型，既继承了ModelMap又实现了Model接口，所以Model或者ModelMap其实使用的是同一个对象。</li>
<li>处理器中RedirectAttributes类型的参数<strong>ArgumentResolver会传入redirectModel</strong>，它实际上是RedirectAttributesModelMap类型。</li>
</ul>
<p><strong>getModel方法</strong>返回redirectModel的情况下，在处理器中设置到Model的参数就不会被mav使用了（设置SessionAttributes除外）。</p>
<p><strong>getModel方法</strong>返回defaultModel，设置到RedirectAttributes中的参数也将丢弃，也就是说在返回的view不是redirect类型时，即使处理器使用RedirectAttributes参数设置了值也不会传递到下一个请求。</p>
<p>只有将参数设置到Model或者ModelMap里才能使用SessionAttributes缓存，设置到RedirectAttributes里的参数不行。</p>
<h3 id="3-4SessionAttributesHandler和SessionAttributeStore"><a href="#3-4SessionAttributesHandler和SessionAttributeStore" class="headerlink" title="3.4SessionAttributesHandler和SessionAttributeStore"></a>3.4SessionAttributesHandler和SessionAttributeStore</h3><p>在 RequestMappingHandlerAdapter 的 getModelFactory方法中创建并缓存到其属性<strong>sessionAttributesHandlerCache</strong>中，<strong>每个controller对应一个自己的SessionAttributesHandler</strong>。且每个SessionAttributesHandler都封装了其属性sessionAttributeStore。</p>
<p>SessionAttributesHandler用来处理@SessionAttributes注解的参数，来创建SessionAttributesHandler对象。</p>
<p><strong>SessionAttributesHandler的具体存储工作是交给SessionAttributeStore去做的</strong>，而且使用的统一为 RequestMappingHandlerAdapter 的SessionAttributeStore。SessionAttributeStore并不是保存数据的容器，而是保存数据的工具，具体保存数据的容器使用的是Session。</p>
<p>SessionAttributeHandler是在ModelFactory中使用的。</p>
<h3 id="3-5ModelFactory"><a href="#3-5ModelFactory" class="headerlink" title="3.5ModelFactory"></a>3.5ModelFactory</h3><p>是用来维护Model的，具体包含两个功能：1.初始化Model,2.处理器执行后将Model中相应的参数更新到SessionAttributes中。</p>
<h4 id="初始化Model"><a href="#初始化Model" class="headerlink" title="初始化Model"></a>初始化Model</h4><p>主要是在处理器执行前将相应数据设置到Model中，是通过调用initModel方法完成的。</p>
<p><strong>initModel方法</strong></p>
<p>1.从sessionAttributes中取出保存的参数，并合并到mavContainer的Model中<br>2.执行注解了@ModelAttribute的方法并将结果设置到mavContainer的Model中<br>3.判断既注解了@ModelAttribute又在@SessionAttributes注解中（参数名或者参数类型在注解中设置了）的参数是否已经设置到mavContainer的Model中，如果没有则使用sessionAttributesHandler从sessionAttributeStore中获取并设置到mavContainer中。</p>
<p>第三步跟第一步的区别是<strong>第一步</strong>是将当前处理器保存的所有SessionAttributes属性合并到了mavContainer，而<strong>第三步</strong>可以使用其它处理器中保存的SessionAttributes属性来设置注解了@ModelAttribute的参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initModel</span><span class="params">(NativeWebRequest request, ModelAndViewContainer container, HandlerMethod handlerMethod)</span></span><br><span class="line">      <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1.从sessionAttributes中获取已经保存的参数，并保存到mavContainer中</span></span><br><span class="line">   Map&lt;String, ?&gt; sessionAttributes = <span class="built_in">this</span>.sessionAttributesHandler.retrieveAttributes(request);</span><br><span class="line">   container.mergeAttributes(sessionAttributes);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//2.执行注解了@ModelAttribute的方法并将结果设置到mavContainer的Model中</span></span><br><span class="line">   invokeModelAttributeMethods(request, container);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.遍历既注解了@ModelAttribute又在@SessionAttributes注解中出现的方法参数</span></span><br><span class="line">   <span class="keyword">for</span> (String name : findSessionAttributeArguments(handlerMethod)) &#123;</span><br><span class="line">      <span class="comment">//如果当前Model中没有此参数 </span></span><br><span class="line">      <span class="keyword">if</span> (!container.containsAttribute(name)) &#123;</span><br><span class="line">         <span class="comment">//3.1从sessionAttributes获取参数值 </span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.sessionAttributesHandler.retrieveAttribute(request, name);</span><br><span class="line">         <span class="comment">//3.2如果获取不到，则抛出异常 </span></span><br><span class="line">         <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HttpSessionRequiredException</span>(<span class="string">&quot;Expected session attribute &#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&quot;</span>, name);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//3.2获取到则添加到Model中 </span></span><br><span class="line">         container.addAttribute(name, value);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>invokeModelAttributeMethods方法</strong></p>
<p>作用：遍历的方式执行注解了@ModelAttribute的方法并将结果设置到mavContainer的Model中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeModelAttributeMethods</span><span class="params">(NativeWebRequest request, ModelAndViewContainer container)</span></span><br><span class="line">      <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//如果 modelMethods 属性非空</span></span><br><span class="line">   <span class="keyword">while</span> (!<span class="built_in">this</span>.modelMethods.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">//1.获取下一个注释了@ModelAttribute注解的方法 </span></span><br><span class="line">      <span class="type">InvocableHandlerMethod</span> <span class="variable">modelMethod</span> <span class="operator">=</span> getNextModelMethod(container).getHandlerMethod();</span><br><span class="line">      <span class="comment">//2.获取方法上的@ModelAttribute注解对象</span></span><br><span class="line">      <span class="type">ModelAttribute</span> <span class="variable">ann</span> <span class="operator">=</span> modelMethod.getMethodAnnotation(ModelAttribute.class);</span><br><span class="line">      <span class="comment">//3.如果@ModelAttribute注解设置了name且mavContainer中存在此参数则直接跳过后续处理</span></span><br><span class="line">      <span class="keyword">if</span> (container.containsAttribute(ann.name())) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!ann.binding()) &#123;</span><br><span class="line">            container.setBindingDisabled(ann.name());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.【执行@ModelAttribute注解的方法】</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> modelMethod.invokeForRequest(request, container);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//5.如果@ModelAttribute注解的方法返回类型为void，跳过后续处理（因为在执行方法时就设置好了Model）</span></span><br><span class="line">      <span class="keyword">if</span> (modelMethod.isVoid()) &#123;</span><br><span class="line">         <span class="comment">//如果 @ModelAttribute注解设置了value值，此时无效，因为没有返回值用于设置值</span></span><br><span class="line">         <span class="keyword">if</span> (StringUtils.hasText(ann.value())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">               logger.debug(<span class="string">&quot;Name in @ModelAttribute is ignored because method returns void: &quot;</span> +</span><br><span class="line">                     modelMethod.getShortLogMessage());</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//跳过后续处理 </span></span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//6.调用 getNameForReturnValue方法获取参数名</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">returnValueName</span> <span class="operator">=</span> getNameForReturnValue(returnValue, modelMethod.getReturnType());</span><br><span class="line">      <span class="comment">//获取@ModelAttribute注解的binding设置，来设置是否允许绑定此参数</span></span><br><span class="line">      <span class="keyword">if</span> (!ann.binding()) &#123;</span><br><span class="line">         container.setBindingDisabled(returnValueName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//7.如果mavContainer中没有此属性，则添加到mavContainer中</span></span><br><span class="line">      <span class="keyword">if</span> (!container.containsAttribute(returnValueName)) &#123;</span><br><span class="line">         container.addAttribute(returnValueName, returnValue);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>getNameForReturnValue方法</strong></p>
<p>作用：根据方法返回值和返回类型/@ModelAttribute注解获取Model的参数名，<strong>此方法主要实现基于@ModelAttribute注解获取Model的参数名</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getNameForReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType)</span> &#123;</span><br><span class="line">   <span class="comment">//1.根据返回类型对象获取方法注解@ModelAttribute</span></span><br><span class="line">   <span class="type">ModelAttribute</span> <span class="variable">ann</span> <span class="operator">=</span> returnType.getMethodAnnotation(ModelAttribute.class);</span><br><span class="line">   <span class="comment">//2.如果注解非空且注解中设置了 value，则直接返回value值</span></span><br><span class="line">   <span class="keyword">if</span> (ann != <span class="literal">null</span> &amp;&amp; StringUtils.hasText(ann.value())) &#123;</span><br><span class="line">      <span class="keyword">return</span> ann.value();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//2.如果注解中没有设置 value，则根据方法类型获取参数名</span></span><br><span class="line">      <span class="comment">//获取方法反射对象 </span></span><br><span class="line">      <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> returnType.getMethod();</span><br><span class="line">      <span class="comment">//获取此方法所在的类class对象</span></span><br><span class="line">      Class&lt;?&gt; containingClass = returnType.getContainingClass();</span><br><span class="line">      <span class="comment">//解析方法真实的返回类型class对象 </span></span><br><span class="line">      Class&lt;?&gt; resolvedType = GenericTypeResolver.resolveReturnType(method, containingClass);</span><br><span class="line">      <span class="comment">//调用Conventions.getVariableNameForReturnType方法根据方法返回类型获取参数名</span></span><br><span class="line">      <span class="keyword">return</span> Conventions.getVariableNameForReturnType(method, resolvedType, returnValue);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Conventions.getVariableNameForReturnType方法</strong></p>
<p>作用：根据方法<strong>返回类型</strong>和<strong>返回值</strong>获取参数名称。1.如果方法返回类型为Object，则<strong>基于返回值获取参数名称</strong>2.如果方法返回类型非Object则<strong>基于返回类型获取参数名称</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Conventions.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getVariableNameForReturnType</span><span class="params">(Method method, Class&lt;?&gt; resolvedType, <span class="meta">@Nullable</span> Object value)</span> &#123;</span><br><span class="line">   <span class="comment">//1.如果方法返回类型为Object</span></span><br><span class="line">   <span class="keyword">if</span> (Object.class == resolvedType) &#123;</span><br><span class="line">      <span class="comment">//如果方法返回值为null，则抛出异常 </span></span><br><span class="line">      <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">               <span class="string">&quot;Cannot generate variable name for an Object return type with null value&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//调用getVariableName方法，根据返回值获取参数名，即根据返回值的真实类型获取参数名</span></span><br><span class="line">      <span class="keyword">return</span> getVariableName(value);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1.如果方法返回类型非Object类型 </span></span><br><span class="line">   Class&lt;?&gt; valueClass;</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">pluralize</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">reactiveSuffix</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//2.如果方法返回类型为数组类型 </span></span><br><span class="line">   <span class="keyword">if</span> (resolvedType.isArray()) &#123;</span><br><span class="line">      <span class="comment">//获取数组的元素类型 </span></span><br><span class="line">      valueClass = resolvedType.getComponentType();</span><br><span class="line">      <span class="comment">//标记复数形式命名 </span></span><br><span class="line">      pluralize = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (Collection.class.isAssignableFrom(resolvedType)) &#123;</span><br><span class="line">   <span class="comment">//2.如果方法返回类型为Collection集合类型</span></span><br><span class="line">      <span class="comment">//获取集合元素的类型 </span></span><br><span class="line">      valueClass = ResolvableType.forMethodReturnType(method).asCollection().resolveGeneric();</span><br><span class="line">      <span class="keyword">if</span> (valueClass == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!(value <span class="keyword">instanceof</span> Collection)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot generate variable name &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;for non-typed Collection return type and a non-Collection value&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         Collection&lt;?&gt; collection = (Collection&lt;?&gt;) value;</span><br><span class="line">         <span class="keyword">if</span> (collection.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot generate variable name &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;for non-typed Collection return type and an empty Collection value&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="type">Object</span> <span class="variable">valueToCheck</span> <span class="operator">=</span> peekAhead(collection);</span><br><span class="line">         valueClass = getClassForValue(valueToCheck);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//标记复数命名 </span></span><br><span class="line">      pluralize = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//2.其它类型，则直接使用resolvedType方法返回类型 </span></span><br><span class="line">      valueClass = resolvedType;</span><br><span class="line">      <span class="comment">//获取响应式编程的适配器 </span></span><br><span class="line">      <span class="type">ReactiveAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> ReactiveAdapterRegistry.getSharedInstance().getAdapter(valueClass);</span><br><span class="line">      <span class="comment">//获取响应式编程返回值对应的后缀参数名 </span></span><br><span class="line">      <span class="keyword">if</span> (adapter != <span class="literal">null</span> &amp;&amp; !adapter.getDescriptor().isNoValue()) &#123;</span><br><span class="line">         reactiveSuffix = ClassUtils.getShortName(valueClass);</span><br><span class="line">         valueClass = ResolvableType.forMethodReturnType(method).getGeneric().toClass();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.根据方法返回类型class获取简短的参数名称</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ClassUtils.getShortNameAsProperty(valueClass);</span><br><span class="line">   <span class="comment">//4.添加复数后缀List或者响应式后缀 </span></span><br><span class="line">   <span class="keyword">return</span> (pluralize ? pluralize(name) : name + reactiveSuffix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/image-20240412213031924.png" alt="image-20240412213031924"></p>
<h4 id="更新Model"><a href="#更新Model" class="headerlink" title="更新Model"></a>更新Model</h4><p><strong>updateModel方法</strong></p>
<p>作用：1.将当前DefaultModel同步到SessionAttributes中，2.如果需要渲染页面，则给Model中相应参数设置BindingResult。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateModel</span><span class="params">(NativeWebRequest request, ModelAndViewContainer container)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">//1.从mavContainer获取defaultModel对象</span></span><br><span class="line">   <span class="type">ModelMap</span> <span class="variable">defaultModel</span> <span class="operator">=</span> container.getDefaultModel();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//2.如果SessionStatus#setComplete在处理器方法中调用了，则清空sessionAttributes</span></span><br><span class="line">   <span class="keyword">if</span> (container.getSessionStatus().isComplete())&#123;</span><br><span class="line">      <span class="built_in">this</span>.sessionAttributesHandler.cleanupAttributes(request);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">//2.没有调用SessionStatus#setComplete，则将defaultModel同步到sessionAttributes</span></span><br><span class="line">       <span class="built_in">this</span>.sessionAttributesHandler.storeAttributes(request, defaultModel);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//3. 更新BindingResult，即向defaultModel中添加BindingResult的相关参数（这里并没有校验的错误值）</span></span><br><span class="line">   <span class="keyword">if</span> (!container.isRequestHandled() &amp;&amp; container.getModel() == defaultModel) &#123;</span><br><span class="line">      updateBindingResult(request, defaultModel);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在处理器中绑定参数时<strong>如果参数注释了@Valid或者@Validated</strong>，则<strong>会将校验结果设置到跟其相邻的下一个Error或者BindingResult类型的参数中</strong>。</p>
<p>updateModel一共做了两件事，第一件事是维护SessionAttributes的数据，第二件是给Model中需要的参数设置BindingResult，以备视图使用。</p>
<h3 id="3-6ServletInvocableHandlerMethod"><a href="#3-6ServletInvocableHandlerMethod" class="headerlink" title="3.6ServletInvocableHandlerMethod"></a>3.6ServletInvocableHandlerMethod</h3><p><img src="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/image-20240412224139418.png" alt="image-20240412224139418"></p>
<p>ServletInvocableHandlerMethod也是一种HandlerMethod，只是<strong>增加了方法执行的功能</strong>，当然也相应的增加了<strong>参数解析、返回值处理等相关功能</strong>。</p>
<p>本节从HandlerMethod开始依次对这三个组件进行分析。</p>
<h4 id="3-6-1HandlerMethod"><a href="#3-6-1HandlerMethod" class="headerlink" title="3.6.1HandlerMethod"></a>3.6.1HandlerMethod</h4><p><strong>用于封装Handler和其中具体处理请求的Method</strong>，分别对应其中的<strong>bean和method属性</strong>。</p>
<p>如果Handler是String类型，将其变为容器中对应bean的过程在专门的方法createWithResolvedBean中来操作的。</p>
<p>HandlerMethod中属性的含义除了<strong>bridgedMethod</strong>外都比较容易理解，只是保存参数的属性parameters使用了可能不太熟悉的类型<strong>MethodParameter</strong>。</p>
<p><strong>MethodParameter</strong>里最重要的是method和parameterIndex，有了这两个参数后参数类型、注释等都可以获取到。不过在正常的反射技术里是不知道参数名的，所以这里专门使用了一个<strong>参数名查找的组件 parameterNameDiscoverer</strong>。</p>
<p>在 HandlerMethod 中定义了两个内部类来封装参数，一个封装方法调用的参数<strong>HandlerMethodParameter</strong>，一个封装方法返回的参数<strong>ReturnValueMethodParameter</strong>。</p>
<p>两个类都是MethodParameter的子类，而且ReturnValueMethodParameter还是HandlerMethodParameter的子类，其parameterIndex默认为-1。<strong>它们主要使用method和parameterIndex来创建MethodParamter，且它们使用的method都是bridgedMethod</strong>。</p>
<p><strong>bridge method(桥方法)</strong></p>
<p>桥方法作为一个桥将Object为参数的调用转换到了调用String为参数的方法。</p>
<p>在HandlerMethod中的bridgedMethod指的是被桥的方法（注意是bridged而不是bridge），也就是原来的方法。如果不涉及泛型bridgedMethod和method都是同一个方法。</p>
<h4 id="3-6-2InvocableHandlerMethod"><a href="#3-6-2InvocableHandlerMethod" class="headerlink" title="3.6.2InvocableHandlerMethod"></a>3.6.2InvocableHandlerMethod</h4><p>继承自HandlerMethod，在父类的基础上<strong>添加了调用的功能</strong>（核心），也就是说，InvocableHandlerMethod可以直接调用内部属性method对应的方法（严格来说应该是bridgedMethod）。</p>
<p>方法调用是基于<strong>从http请求中解析出来的参数</strong>，和<strong>HandlerMethod中封装的method和bean来通过反射调用的</strong>。</p>
<p>里面有三个属性：</p>
<ul>
<li>dataBinderFactory：WebDataBinderFactory类型，可以创建WebDataBInder，用于参数解析器ArgumentResolver中。</li>
<li>resolvers：HandlerMethodArgumentResolverComposite类型，用于解析参数。</li>
<li>parameterNameDiscoverer：ParameterNameDiscoverer类型，用来获取参数名，用于MethodParameter中。（注意是在放法调用时解析参数时才将parameterNameDiscoverer从InvocableHandlerMethod设置到MethodParameter对象中）</li>
</ul>
<p><strong>1.核心调用方法为invokeForRequest</strong></p>
<p>作用：getMethodArgumentValues解析方法参数（底层还是使用方法参数解析器组件解析），doInvoke调用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invokeForRequest</span><span class="params">(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">      Object... providedArgs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">//1.根据请求、mavContainer获取方法参数【难理解】</span></span><br><span class="line">   Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Arguments: &quot;</span> + Arrays.toString(args));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.调用方法【核心】 </span></span><br><span class="line">   <span class="keyword">return</span> doInvoke(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.doInvoke方法</strong></p>
<p>作用：使用传入的方法参数执行handlermethod封装的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doInvoke</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">//1.调用父类的getBridgedMethod方法获取原始方法反射对象</span></span><br><span class="line">   <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> getBridgedMethod();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (KotlinDetector.isSuspendingFunction(method)) &#123;</span><br><span class="line">         <span class="keyword">return</span> CoroutinesUtils.invokeSuspendingFunction(method, getBean(), args);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//2.反射执行handlermethod封装的方法【核心】</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(getBean(), args);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">      <span class="comment">//非法参数异常处理 </span></span><br><span class="line">      assertTargetBean(method, getBean(), args);</span><br><span class="line">      <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> (ex.getMessage() != <span class="literal">null</span> ? ex.getMessage() : <span class="string">&quot;Illegal argument&quot;</span>);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(formatInvokeError(text, args), ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">      <span class="comment">//方法调用异常处理 </span></span><br><span class="line">      <span class="comment">// Unwrap for HandlerExceptionResolvers ...</span></span><br><span class="line">      <span class="type">Throwable</span> <span class="variable">targetException</span> <span class="operator">=</span> ex.getTargetException();</span><br><span class="line">      <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (RuntimeException) targetException;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (Error) targetException;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (Exception) targetException;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(formatInvokeError(<span class="string">&quot;Invocation failure&quot;</span>, args), targetException);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.getMethodArgumentValues</strong>（重要）</p>
<p>作用：使用请求、mavContainer、providedArgs（一般没有）获取方法参数数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] getMethodArgumentValues(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span><br><span class="line">      Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">//1.获取方法参数数组（封装了方法反射对象和参数索引）</span></span><br><span class="line">   MethodParameter[] parameters = getMethodParameters();</span><br><span class="line">   <span class="comment">//2.判断如果参数为空则直接返回空数组</span></span><br><span class="line">   <span class="keyword">if</span> (ObjectUtils.isEmpty(parameters)) &#123;</span><br><span class="line">      <span class="keyword">return</span> EMPTY_ARGS;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3.构建一个【参数值数组】，大小与parameters相同</span></span><br><span class="line">   Object[] args = <span class="keyword">new</span> <span class="title class_">Object</span>[parameters.length];</span><br><span class="line">   <span class="comment">//4.遍历来初始化参数值数组元素</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">      <span class="comment">//4.1获取当前索引的方法参数MethodParameter</span></span><br><span class="line">      <span class="type">MethodParameter</span> <span class="variable">parameter</span> <span class="operator">=</span> parameters[i];</span><br><span class="line">      <span class="comment">//4.2将参数名解析器从InvocableHandlerMethod设置到 MethodParameter 中</span></span><br><span class="line">      parameter.initParameterNameDiscovery(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line">      <span class="comment">//4.3如果相应类型的参数已经在providedArgs提供，则直接设置到【参数值数组】args，且直接继续设置下一个方法参数</span></span><br><span class="line">      args[i] = findProvidedArgument(parameter, providedArgs);</span><br><span class="line">      <span class="keyword">if</span> (args[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//4.4校验参数解析器是否支持当前参数，如果不支持则抛出异常</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.resolvers.supportsParameter(parameter)) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(formatArgumentError(parameter, <span class="string">&quot;No suitable resolver&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//4.5使用参数解析器解析参数</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         args[i] = <span class="built_in">this</span>.resolvers.resolveArgument(parameter, mavContainer, request, <span class="built_in">this</span>.dataBinderFactory);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">         <span class="comment">//打印异常日志，抛出异常 </span></span><br><span class="line">         <span class="comment">// Leave stack trace for later, exception may actually be resolved and handled...</span></span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">exMsg</span> <span class="operator">=</span> ex.getMessage();</span><br><span class="line">            <span class="keyword">if</span> (exMsg != <span class="literal">null</span> &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123;</span><br><span class="line">               logger.debug(formatArgumentError(parameter, exMsg));</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//5.返回解析出的参数值数组</span></span><br><span class="line">   <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InvocableHandlerMethod就是在HandlerMethod基础上<strong>添加了方法调用功能</strong>，而方法调用又需要解析参数，所以<strong>又提供了解析参数的功能</strong>。</p>
<p>解析的方法有两种，第一种是在providedArgs里面找，第二种是使用argumentResolvers解析，在RequestMappingHandlerAdapter中的调用并没有提供providedArgs，所以<strong>只有使用argumentResolvers解析</strong>。</p>
<h4 id="3-6-3ServletInvocableHandlerMethod"><a href="#3-6-3ServletInvocableHandlerMethod" class="headerlink" title="3.6.3ServletInvocableHandlerMethod"></a>3.6.3ServletInvocableHandlerMethod</h4><p>继承自InvocableHandlerMethod，在父类的基础上增加了三个功能：<strong>1.对@ResponseStatus注解的支持，2.对返回值的处理，3.对异步处理结果的处理。</strong></p>
<p>对返回值的处理是使用returnValueHandlers属性完成的，它是HandlerMethodReturnValueHandlerComposite类型的属性。</p>
<p>当一个方法注解了@ResponseStatus后，返回的response会使用注释中的Status，<strong>如果处理器返回值为空或者注解的reason不为空</strong>，则将中断处理直接返回（不再渲染页面）。</p>
<p><strong>1.invokeAndHandle方法</strong>（核心）</p>
<p>作用：1.invokeForRequest执行方法并获取方法返回值，2.setResponseStatus将解析的@ResponseStatus设置到响应对象中，3.@ResponseStatus注解时两个情况直接返回无需页面渲染（如果处理器返回值为空或者注解的reason不为空），4.返回值处理用于页面渲染</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">      Object... providedArgs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">//1.调用父类的invokeForRequest方法执行方法并获取方法返回值</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">   <span class="comment">//2.根据@ResponseStatus注解（在构造阶段就已经解析了@ResponseStatus注解设置值并设置到HandlerMethod中）设置响应对象的状态码和原因</span></span><br><span class="line">   setResponseStatus(webRequest);</span><br><span class="line">   <span class="comment">//3.如果返回值为null</span></span><br><span class="line">   <span class="keyword">if</span> (returnValue == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//同时请求 NotModified为true（默认false） 或者 使用了@ResponseStatus注解 或者 请求已处理完，则直接返回</span></span><br><span class="line">      <span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="literal">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">         disableContentCachingIfNecessary(webRequest);</span><br><span class="line">         <span class="comment">//在mavContainer设置请求处理完 </span></span><br><span class="line">         mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line">         <span class="comment">//直接返回 </span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">   <span class="comment">//3.如果@ResponseStatus注解设置了异常原因，则直接返回    </span></span><br><span class="line">      mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//4.在mavContainer设置请求未处理完</span></span><br><span class="line">   mavContainer.setRequestHandled(<span class="literal">false</span>);</span><br><span class="line">   Assert.state(<span class="built_in">this</span>.returnValueHandlers != <span class="literal">null</span>, <span class="string">&quot;No return value handlers&quot;</span>);</span><br><span class="line">   <span class="comment">//5.使用返回值处理器处理原始返回值 </span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">            returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(formatErrorForReturnValue(returnValue), ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.setResponseStatus方法</p>
<p>作用：根据HandlerMethod解析好的@ResponseStatus注解内容设置响应对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResponseStatus</span><span class="params">(ServletWebRequest webRequest)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="comment">//1.从父类 HandlerMethod 获取responseStatus属性</span></span><br><span class="line">   <span class="type">HttpStatus</span> <span class="variable">status</span> <span class="operator">=</span> getResponseStatus();</span><br><span class="line">   <span class="comment">//2.如果为空直接返回 </span></span><br><span class="line">   <span class="keyword">if</span> (status == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3.获取响应对象</span></span><br><span class="line">   <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> webRequest.getResponse();</span><br><span class="line">   <span class="comment">//4.如果响应对象非空 </span></span><br><span class="line">   <span class="keyword">if</span> (response != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//4.1从父类 HandlerMethod 获取responseStatusReason属性</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">reason</span> <span class="operator">=</span> getResponseStatusReason();</span><br><span class="line">      <span class="comment">//4.2如果异常原因非空，则响应返回指定状态码与原因 </span></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(reason)) &#123;</span><br><span class="line">         response.sendError(status.value(), reason);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//4.2如果异常原因为空，则设置响应状态码</span></span><br><span class="line">         response.setStatus(status.value());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//5.给请求对象设置属性，值为状态对象</span></span><br><span class="line">   webRequest.getRequest().setAttribute(View.RESPONSE_STATUS_ATTRIBUTE, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-7HandlerMethodArgumentResolver"><a href="#3-7HandlerMethodArgumentResolver" class="headerlink" title="3.7HandlerMethodArgumentResolver"></a>3.7HandlerMethodArgumentResolver</h3><p>用来为处理器解析参数参数，主要用在前面讲过的InvocableHandlerMethod中。</p>
<p><strong>HandlerMethodArgumentResolver接口定义</strong>，只有两个方法，一个用于判断是否可以解析传入的参数，另一个就是用于实际解析参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerMethodArgumentResolver</span> &#123;</span><br><span class="line">    <span class="comment">//1.判断是否可以解析传入的参数</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span>;</span><br><span class="line">    <span class="comment">//2.解析参数，返回的就是参数值</span></span><br><span class="line">    Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">			NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>HandlerMethodArgumentResolver实现类一般有两种命名方式，<strong>一种是XXXMethodArgumentResolver，另一种是XXXMethodProcessor</strong>。前者表示一个参数解析器，后者除了可以解析参数外还可以处理相应类型的返回值，也就是同时还是后面要讲到的HandlerMethodReturnValueHandle。</p>
<p>另外还有个Adapter，它也不是直接解析参数的，而是用来兼容WebArgumentResolver类型的参数解析器的适配器。</p>
<p>解析器介绍：</p>
<ul>
<li>AbstractMessageConverterMethodArgumentResolver：使<strong>用 HttpMessageConverter 解析request body类型参数的基类</strong>。其实现类有HttpEntityMethodProcessor、RequestPartMethodArgumentResolver、RequestResponseBodyMethodProcessor。</li>
<li>AbstractMessageConverterMethodProcessor：AbstractMessageConverterMethodArgumentResolver的扩展，支持返回值的处理。</li>
<li>HttpEntityMethodProcessor：<strong>解析HttpEntity</strong>（代表请求对象或者响应对象，包含头和体）<strong>和RequestEntity</strong>（代表请求对象，还包含请求url和请求类型）<strong>类型的参数</strong>。</li>
<li>RequestResponseBodyMethodProcessor：解<strong>析注解了@RequestBody的参数</strong>。<strong>（核心参数解析器）</strong></li>
<li>RequestPartMethodArgumentResolver：<strong>解析注解了@RequestPart或者类型为MultipartFile类型以及javax.servlet.http.Part类型的参数</strong>。</li>
<li>AbstractNamedValueMethodArgumentResolver：<strong>解析named value类型的参数</strong>（有name的参数，如cookie、requestParam、requestHeader、pathVariable等）<strong>的基类</strong>。</li>
<li>AbstractCookieValueMethodArgumentResolver：是AbstractNamedValueMethodArgumentResolver的子抽象类，<strong>解析注解了@CookieValue的参数的基类</strong>。</li>
<li>ServletCookieValueMethodArgumentResolver：是AbstractCookieValueMethodArgumentResolver的子类实现类，<strong>实现resolveName方法，具体解析cookieValue</strong>。</li>
<li>ExpressionValueMethodArgumentResolver：<strong>解析注解了@Value的参数</strong>，解析过程在父类的resolveEmbeddedValuesAndExpressions方法完成。主要设置了beanFactory，并用它完成具体解析。</li>
<li>MatrixVariableMethodArgumentResolver：<strong>解析注解了@MatrixVariable而且类型不是Map的参数</strong>。</li>
<li>PathVariableMethodArgumentResolver：<strong>解析注解了@PathVariable而且类型不是Map的参数</strong>。</li>
<li>RequestHeaderMethodArgumentResolver：<strong>解析注解了@RequestHeader而且不是Map类型的参数</strong>。</li>
<li>RequestParamMethodArgumentResolver：解析注解了**@RequestParam的参数<strong>、</strong>MultipartFile类型<strong>的参数和没有注解的通用类型的参数，</strong>如果注解了@RequestParam且类型为Map的参数必须注解设置了name值否则不使用本解析器<strong>。</strong>（核心参数解析器）**</li>
<li>ModelAttributeMethodProcessor：<strong>解析注解了@ModelAttribute的参数</strong>，如果其中的属性annotationNotRequired为true时还可以解析没有注解的非通用类型的参数（但默认为false）。</li>
<li>AbstractWebArgumentResolverAdapter：用作 WebArgumentResolver（接口，不同于HandlerMethodArgumentResolver接口） 解析器的适配器。</li>
<li>ErrorsMethodArgumentResolver：<strong>解析Errors类型的参数</strong>。当一个参数绑定出现异常时会自动将异常设置到其相邻的下一个Errors类型的参数，设置方法就是使用了这个解析器，内部是直接从model中获取的。</li>
<li>MapMethodProcessor：<strong>解析Map类型参数</strong>（包括ModelMap类型，<strong>且同时要求参数上没有任何注解</strong>）。直接返回mavContainer中的model作为参数值。</li>
<li>ModelMethodProcessor：<strong>解析Model类型参数</strong>。直接返回mavContainer中的model作为参数值。</li>
<li>RedirectAttributesMethodArgumentResolver：<strong>解析RedirectAttributes类型的参数</strong>。新建RedirectAttributesModelMap类型的RedirectAttributes并设置到mavConatiner中，然后返回其作为参数值。</li>
<li>ServletRequestMethodArgumentResolver：解<strong>析WebRequest、ServletRequest、MultipartRequest、HttpSession、Principal、Locale、TimeZone、InputStream、Reader、HttpMethod、ZoneId类型的参数</strong>，它们都是使用request获取的。</li>
<li>ServletResponseMethodArgumentResolver：<strong>解析ServletResponse、OutputStream、Writer类型的参数</strong>。它们都是使用response获取的。</li>
<li>SessionStatusMethodArgumentResolver：解析SessionStatus类型参数，直接返回mavContainer中的SessionStatus作为参数值。</li>
</ul>
<h4 id="1-ModelMethodProcessor源码分析"><a href="#1-ModelMethodProcessor源码分析" class="headerlink" title="1.ModelMethodProcessor源码分析"></a>1.ModelMethodProcessor源码分析</h4><p>作用：用于解析Model类型的方法参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModelMethodProcessor</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodArgumentResolver</span>, HandlerMethodReturnValueHandler &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">      <span class="comment">//支持解析 Model 类型的参数</span></span><br><span class="line">      <span class="keyword">return</span> Model.class.isAssignableFrom(parameter.getParameterType());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">         NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">      Assert.state(mavContainer != <span class="literal">null</span>, <span class="string">&quot;ModelAndViewContainer is required for model exposure&quot;</span>);</span><br><span class="line">      <span class="comment">//解析参数值，直接返回 mavContainer 中的model</span></span><br><span class="line">      <span class="keyword">return</span> mavContainer.getModel();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>通过前面的分析知道，这时Model可能已经保存了一些值，如<strong>SessionAttributes中的值、FlashMap中的值、还有@ModelAttribute方法设置的值</strong>。主要是以下方法实现的初始化Model的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br></pre></td></tr></table></figure>



<h4 id="2-PathVariableMethodArgumentResolver源码分析"><a href="#2-PathVariableMethodArgumentResolver源码分析" class="headerlink" title="2.PathVariableMethodArgumentResolver源码分析"></a>2.PathVariableMethodArgumentResolver源码分析</h4><p>作用：解析带@PathVariable注解的方法参数。特别的参数类型为Map时还同时要求@PathVariable注解设置了value值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractNamedValueMethodArgumentResolver.java</span></span><br><span class="line"><span class="comment">//底层模板方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">      NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//=====根据MethodParameter创建NamedValueInfo=======    </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//1.根据 parameter 上的注解来创建NamedValueInfo，封装了参数注解信息（还可能封装了参数名如果注解未设置名字的情况下）</span></span><br><span class="line">   <span class="type">NamedValueInfo</span> <span class="variable">namedValueInfo</span> <span class="operator">=</span> getNamedValueInfo(parameter);</span><br><span class="line">   <span class="comment">//2.获取参数的真实 MethodParameter 对象</span></span><br><span class="line">   <span class="type">MethodParameter</span> <span class="variable">nestedParameter</span> <span class="operator">=</span> parameter.nestedIfOptional();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//====================解析参数名===================</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.解析 NamedValue 参数的名称。即通过注解的name属性值解析出参数名。name属性支持$&#123;&#125;从配置文件获取，支持#&#123;&#125;SpEL表达式，如&quot;#&#123;systemProperties[&#x27;java.vm.version&#x27;]&#125;&quot;。</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">resolvedName</span> <span class="operator">=</span> resolveEmbeddedValuesAndExpressions(namedValueInfo.name);</span><br><span class="line">   <span class="comment">//4.如果参数名为空抛出异常</span></span><br><span class="line">   <span class="keyword">if</span> (resolvedName == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">            <span class="string">&quot;Specified name must not resolve to null: [&quot;</span> + namedValueInfo.name + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//====================解析参数值===================</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//5.通过子类 resolveName 方法解析参数值</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">arg</span> <span class="operator">=</span> resolveName(resolvedName.toString(), nestedParameter, webRequest);</span><br><span class="line">   <span class="comment">//6.如果参数值解析为空 </span></span><br><span class="line">   <span class="keyword">if</span> (arg == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//6.1使用注解提供的默认值（如果注解提供了默认值） </span></span><br><span class="line">      <span class="keyword">if</span> (namedValueInfo.defaultValue != <span class="literal">null</span>) &#123;</span><br><span class="line">         arg = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) &#123;</span><br><span class="line">      <span class="comment">//6.1如果注解要求必须提供，则抛出异常 </span></span><br><span class="line">         handleMissingValue(namedValueInfo.name, nestedParameter, webRequest);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//6.2处理参数值为空值的情况。Boolean类型参数设置值为false，基本类型参数抛出异常</span></span><br><span class="line">      arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(arg) &amp;&amp; namedValueInfo.defaultValue != <span class="literal">null</span>) &#123;</span><br><span class="line">      arg = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//===================参数类型转换===================</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//7.如果 binderFactory 非空，则用它创建WebDataBinder并转换解析出的参数（如果需要转换）</span></span><br><span class="line">   <span class="keyword">if</span> (binderFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">WebDataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> binderFactory.createBinder(webRequest, <span class="literal">null</span>, namedValueInfo.name);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ConversionNotSupportedException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MethodArgumentConversionNotSupportedException</span>(arg, ex.getRequiredType(),</span><br><span class="line">               namedValueInfo.name, parameter, ex.getCause());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MethodArgumentTypeMismatchException</span>(arg, ex.getRequiredType(),</span><br><span class="line">               namedValueInfo.name, parameter, ex.getCause());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Check for null value after conversion of incoming argument value</span></span><br><span class="line">      <span class="keyword">if</span> (arg == <span class="literal">null</span> &amp;&amp; namedValueInfo.defaultValue == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) &#123;</span><br><span class="line">         handleMissingValueAfterConversion(namedValueInfo.name, nestedParameter, webRequest);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===================后置处理======================</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//8.对解析出的参数进行后置处理。pathvariable中为设置请求参数，其它子类为空实现</span></span><br><span class="line">   handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@Value中的value、</p>
<p>@PathVariable中的name、@RequestAttribute中的name、@SessionAttribute中的name、</p>
<p>@RequestHeader中的name和defaultValue、@RequestParam中的name和defaultValue、@CookieValue中的name和defaultValue支持${}与#{}SpEL表达式形式。</p>
<p>以上注解都由AbstractNamedValueMethodArgumentResolver子类来处理。</p>
</blockquote>
<h4 id="3-RequestParamMethodArgumentResolver源码分析"><a href="#3-RequestParamMethodArgumentResolver源码分析" class="headerlink" title="3.RequestParamMethodArgumentResolver源码分析"></a>3.RequestParamMethodArgumentResolver源码分析</h4><p>RequestMappingHandlerAdapter对象的argumentResolversz属性中<strong>包含对应类型的两个对象</strong>。第一个不会解析无注解简单类型参数，第二个会解析无注解简单类型参数。</p>
<p><strong>作用</strong>：</p>
<ol>
<li>会解析<strong>带@RequestParam注解的参数</strong>。</li>
<li>会解析<strong>无@RequestPart注解MultipartFile、Part类型</strong>（包括其数组类型和集合类型）<strong>的参数</strong>。</li>
<li>会解析<strong>无@RequestParam注解简单类型的参数</strong>（包括基本数据类型、基本数据类型对应的包装类型、枚举类型、CharSequence字符序列类型、Date日期类型、Temporal类型即LocalDateTime日期相关类型、URI、URL、Locale、Class类型）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestParamMethodArgumentResolver</span> <span class="keyword">extends</span> <span class="title class_">AbstractNamedValueMethodArgumentResolver</span></span><br><span class="line">      <span class="keyword">implements</span> <span class="title class_">UriComponentsContributor</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是否支持解析指定参数的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">        <span class="comment">//1.如果参数带@RequestParam注解支持解析【情况一】</span></span><br><span class="line">		<span class="keyword">if</span> (parameter.hasParameterAnnotation(RequestParam.class)) &#123;</span><br><span class="line">            <span class="comment">//1.1如果参数类型为Map类型，@RequestParam注解必须要指定name参数，如果没有指定则不支持而是依赖RequestParamMapMethodArgumentResolver来解析</span></span><br><span class="line">			<span class="keyword">if</span> (Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) &#123;</span><br><span class="line">                <span class="comment">//1.2获取参数上的@RequestParam注解</span></span><br><span class="line">				<span class="type">RequestParam</span> <span class="variable">requestParam</span> <span class="operator">=</span> parameter.getParameterAnnotation(RequestParam.class);</span><br><span class="line">                <span class="comment">//1.3判断注解非空且指定了name参数</span></span><br><span class="line">				<span class="keyword">return</span> (requestParam != <span class="literal">null</span> &amp;&amp; StringUtils.hasText(requestParam.name()));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//1.1如果为其它类型且带@RequestParam注解参数，一律支持 </span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//1.如果没有带@RequestParam注解的参数 </span></span><br><span class="line">            <span class="comment">//2.如果参数带@RequestPart注解不支持解析</span></span><br><span class="line">			<span class="keyword">if</span> (parameter.hasParameterAnnotation(RequestPart.class)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//3.获取Optional类型参数的嵌套真实参数类型</span></span><br><span class="line">			parameter = parameter.nestedIfOptional();</span><br><span class="line">            <span class="comment">//4.如果参数类型为MultipartFile、Part类型支持解析（隐含条件且不允许带@RequestPart、@RequestParam注解）【情况二】</span></span><br><span class="line">			<span class="keyword">if</span> (MultipartResolutionDelegate.isMultipartArgument(parameter)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.useDefaultResolution) &#123;</span><br><span class="line">            <span class="comment">//5.如果useDefaultResolution属性为true(第二个对象为true,第一个对象为false)  </span></span><br><span class="line">                <span class="comment">//如果参数类型为简单类型支持解析（隐含条件且不允许带@RequestParam、@RequestPart注解）【情况三】</span></span><br><span class="line">				<span class="keyword">return</span> BeanUtils.isSimpleProperty(parameter.getNestedParameterType());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//6.如果为其它情况则不支持解析 </span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据参数名、参数类型、请求对象解析参数值（注意此时解析出的参数值为String类型）（父类AbstractNamedValueMethodArgumentResolver#resolveArgument方法调用）</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">resolveName</span><span class="params">(String name, MethodParameter parameter, NativeWebRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.获取请求对象</span></span><br><span class="line">		<span class="type">HttpServletRequest</span> <span class="variable">servletRequest</span> <span class="operator">=</span> request.getNativeRequest(HttpServletRequest.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.解析MultipartFile、Part类型参数，并返回（如果不是此类型，则无效mpArg == MultipartResolutionDelegate.UNRESOLVABLE）【请求体获取方法参数值】</span></span><br><span class="line">		<span class="keyword">if</span> (servletRequest != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">mpArg</span> <span class="operator">=</span> MultipartResolutionDelegate.resolveMultipartArgument(name, parameter, servletRequest);</span><br><span class="line">			<span class="keyword">if</span> (mpArg != MultipartResolutionDelegate.UNRESOLVABLE) &#123;</span><br><span class="line">				<span class="keyword">return</span> mpArg;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">Object</span> <span class="variable">arg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//3.解析Multipart类型请求</span></span><br><span class="line">		<span class="type">MultipartRequest</span> <span class="variable">multipartRequest</span> <span class="operator">=</span> request.getNativeRequest(MultipartRequest.class);</span><br><span class="line">		<span class="keyword">if</span> (multipartRequest != <span class="literal">null</span>) &#123;</span><br><span class="line">			List&lt;MultipartFile&gt; files = multipartRequest.getFiles(name);</span><br><span class="line">			<span class="keyword">if</span> (!files.isEmpty()) &#123;</span><br><span class="line">				arg = (files.size() == <span class="number">1</span> ? files.get(<span class="number">0</span>) : files);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.如果还未解析到参数值（即不是流媒体数据类型MultipartFile、Part）（负责解析@RequestParam注解参数和不带@RequestParam注解简单类型参数）【核心】</span></span><br><span class="line">		<span class="keyword">if</span> (arg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//4.1从请求参数中获取指定 参数名 的 请求参数值数组【请求参数中获取方法参数值】</span></span><br><span class="line">			String[] paramValues = request.getParameterValues(name);</span><br><span class="line">            <span class="comment">//4.2如果请求参数值数组非空，将其作为方法参数值</span></span><br><span class="line">			<span class="keyword">if</span> (paramValues != <span class="literal">null</span>) &#123;</span><br><span class="line">				arg = (paramValues.length == <span class="number">1</span> ? paramValues[<span class="number">0</span>] : paramValues);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arg;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父类<strong>AbstractNamedValueMethodArgumentResolver</strong>关键方法</p>
<p>注意：<strong>MethodArgumentResolver</strong>里的resolveArgument方法的参数WebDataBinderFactory是由 <strong>InvocableHandlerMethod</strong> 的dataBinderFactory属性传入的，而其属性是在RequestMappingHandlerAdapter中设置的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractNamedValueMethodArgumentResolver</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractNamedValueMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodArgumentResolver</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//HandlerMethodArgumentResolver解析参数【入口方法】</span></span><br><span class="line">    <span class="comment">//根据参数类型MethodParameter、ModelAndViewContainer、请求对象、WebDataBinderFactory解析出参数值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">			NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       </span><br><span class="line"><span class="comment">//======获取并缓存指定方法参数对应的NamedValueInfo=========</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.调用本类方法getNamedValueInfo获取NamedValueInfo,</span></span><br><span class="line">        <span class="comment">//先查属性namedValueInfoCache缓存，查不到再调用子类createNamedValueInfo(parameter)创建NamedValueInfo类型对象并缓存起来（方法执行一次，后续方法就不用解析注解创建对象了）</span></span><br><span class="line">        <span class="comment">//createNamedValueInfo(parameter)方法是根据注解信息来创建NamedValueInfo类型对象</span></span><br><span class="line">		<span class="type">NamedValueInfo</span> <span class="variable">namedValueInfo</span> <span class="operator">=</span> getNamedValueInfo(parameter);</span><br><span class="line">        <span class="comment">//2.获取Optional参数类型的嵌套真实参数类型</span></span><br><span class="line">		<span class="type">MethodParameter</span> <span class="variable">nestedParameter</span> <span class="operator">=</span> parameter.nestedIfOptional();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//=====================解析方法参数名===================</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.根据namedValueInfo.name（来源于 注解 或者 方法参数名）解析方法参数名（可以解析嵌套表达式$&#123;属性文件值&#125;或者SpEL表达式#&#123;SpEL表达式&#125;）</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">resolvedName</span> <span class="operator">=</span> resolveEmbeddedValuesAndExpressions(namedValueInfo.name);</span><br><span class="line">        <span class="comment">//4.如果方法参数名为空则抛出异常</span></span><br><span class="line">		<span class="keyword">if</span> (resolvedName == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">					<span class="string">&quot;Specified name must not resolve to null: [&quot;</span> + namedValueInfo.name + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//===================解析方法参数值=====================</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.根据方法参数名、MethodParameter、请求对象解析方法参数值，调用子类的resolveName方法（不同子类实现不同，方法参数值来源不同，可能来自请求参数、请求头、请求属性、session、cookie、请求路径、@Value注解表达式）【核心】</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">arg</span> <span class="operator">=</span> resolveName(resolvedName.toString(), nestedParameter, webRequest);</span><br><span class="line">        <span class="comment">//6.如果解析出方法参数值等于null</span></span><br><span class="line">		<span class="keyword">if</span> (arg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//6.1namedValueInfo.defaultValue非空，即注解设置了默认值，则解析默认值作为方法参数值</span></span><br><span class="line">			<span class="keyword">if</span> (namedValueInfo.defaultValue != <span class="literal">null</span>) &#123;</span><br><span class="line">				arg = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) &#123;</span><br><span class="line">            <span class="comment">//6.2如果必须要参数值且参数类型非Optional（隐含条件且没有设置注解默认值），调用子类handleMissingValue方法（缺失参数值时的方法），实现为抛出异常</span></span><br><span class="line">				handleMissingValue(namedValueInfo.name, nestedParameter, webRequest);</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//6.3处理为null值的方法参数（如果此时参数值仍然为null才会进行处理）</span></span><br><span class="line">			arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(arg) &amp;&amp; namedValueInfo.defaultValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//6.如果解析出的方法参数值为&quot;&quot;字符串且注解设置了默认值，则解析默认值作为方法参数值  </span></span><br><span class="line">			arg = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=======================转换方法参数值类型===============</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.如果binderFactory非空（方法传入，一般都非空）</span></span><br><span class="line">		<span class="keyword">if</span> (binderFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//7.1使用 binderFactory 来创建WebDataBinder对象，【注意：target为null,objectName为方法参数名】，即创建的WebRequestDataBinder对象target属性等于null，objectName属性为方法参数名</span></span><br><span class="line">			<span class="type">WebDataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> binderFactory.createBinder(webRequest, <span class="literal">null</span>, namedValueInfo.name);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//7.2调用binder来转换方法参数值从原始类型到指定类型</span></span><br><span class="line">				arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (ConversionNotSupportedException ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MethodArgumentConversionNotSupportedException</span>(arg, ex.getRequiredType(),</span><br><span class="line">						namedValueInfo.name, parameter, ex.getCause());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MethodArgumentTypeMismatchException</span>(arg, ex.getRequiredType(),</span><br><span class="line">						namedValueInfo.name, parameter, ex.getCause());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Check for null value after conversion of incoming argument value</span></span><br><span class="line">			<span class="keyword">if</span> (arg == <span class="literal">null</span> &amp;&amp; namedValueInfo.defaultValue == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">					namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) &#123;</span><br><span class="line">				handleMissingValueAfterConversion(namedValueInfo.name, nestedParameter, webRequest);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//8.解析后处理，可忽略不重要</span></span><br><span class="line">		handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//9.返回参数值（参数值表面类型为Object、真实类型为指定方法参数类型）</span></span><br><span class="line">		<span class="keyword">return</span> arg;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据MethodParameter获取NamedValueInfo对象，此方法在方法调用中会逐步构建属性namedValueInfoCache缓存</span></span><br><span class="line">    <span class="keyword">private</span> NamedValueInfo <span class="title function_">getNamedValueInfo</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">        <span class="comment">//1.从属性namedValueInfoCache缓存中获取NamedValueInfo对象，第一次调用次方法时没有缓存后续都存在缓存</span></span><br><span class="line">		<span class="type">NamedValueInfo</span> <span class="variable">namedValueInfo</span> <span class="operator">=</span> <span class="built_in">this</span>.namedValueInfoCache.get(parameter);</span><br><span class="line">        <span class="comment">//2.如果缓存的namedValueInfo为空</span></span><br><span class="line">		<span class="keyword">if</span> (NamedValueInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//2.1则调用子类createNamedValueInfo方法根据参数上的注解创建NamedValueInfo类型对象，如没有注解则创建一个默认对象（当然有些子类不允许没有注解）</span></span><br><span class="line">			namedValueInfo = createNamedValueInfo(parameter);</span><br><span class="line">            <span class="comment">//2.2调用本类updateNamedValueInfo方法在子类创建的NamedValueInfo类型对象基础上再根据参数名创建新的NamedValueInfo对象</span></span><br><span class="line">            <span class="comment">//可能会更新NamedValueInfo对象name属性、defaultValue属性</span></span><br><span class="line">			namedValueInfo = updateNamedValueInfo(parameter, namedValueInfo);</span><br><span class="line">            <span class="comment">//2.3缓存到namedValueInfoCache属性</span></span><br><span class="line">			<span class="built_in">this</span>.namedValueInfoCache.put(parameter, namedValueInfo);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//3.返回NamedValueInfo对象（真实类型也为NamedValueInfo）</span></span><br><span class="line">		<span class="keyword">return</span> namedValueInfo;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-ServletModelAttributeMethodProcessor源码分析"><a href="#4-ServletModelAttributeMethodProcessor源码分析" class="headerlink" title="4.ServletModelAttributeMethodProcessor源码分析"></a>4.ServletModelAttributeMethodProcessor源码分析</h4><p>RequestMappingHandlerAdapter对象的argumentResolvers属性中<strong>包含对应类型的两个对象</strong>。第一个不会解析无注解复杂类型参数，第二个会解析无注解复杂类型参数。</p>
<p><strong>作用</strong>：</p>
<ol>
<li>支持<strong>解析带@ModelAttribute注解的方法参数</strong>。</li>
<li>支持<strong>解析无@ModelAttribute注解非简单类型的方法参数</strong>。</li>
</ol>
<blockquote>
<p>@ModelAttribute注解方法参数值解析来源，不仅来源于Model中还来源于 请求路径 和 请求参数，且请求路径优于请求参数优于Model。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModelAttributeMethodProcessor</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodArgumentResolver</span>, HandlerMethodReturnValueHandler &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否支持指定的方法参数MethodParameter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">        <span class="comment">//1.支持带@ModelAttribute注解的方法参数 或者 无@ModelAttribute注解非简单类型的方法参数</span></span><br><span class="line">		<span class="keyword">return</span> (parameter.hasParameterAnnotation(ModelAttribute.class) ||</span><br><span class="line">				(<span class="built_in">this</span>.annotationNotRequired &amp;&amp; !BeanUtils.isSimpleProperty(parameter.getParameterType())));</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据参数类型MethodParameter、ModelAndViewContainer、请求对象、WebDataBinderFactory解析参数值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">			NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">		Assert.state(mavContainer != <span class="literal">null</span>, <span class="string">&quot;ModelAttributeMethodProcessor requires ModelAndViewContainer&quot;</span>);</span><br><span class="line">		Assert.state(binderFactory != <span class="literal">null</span>, <span class="string">&quot;ModelAttributeMethodProcessor requires WebDataBinderFactory&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//========================解析参数名====================</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.调用ModelFactory静态方法getNameForParameter获取方法参数名</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ModelFactory.getNameForParameter(parameter);</span><br><span class="line">        <span class="comment">//2.获取方法参数上的@ModelAttribute注解对象</span></span><br><span class="line">		<span class="type">ModelAttribute</span> <span class="variable">ann</span> <span class="operator">=</span> parameter.getParameterAnnotation(ModelAttribute.class);</span><br><span class="line">        <span class="comment">//3.如果注解对象非空</span></span><br><span class="line">		<span class="keyword">if</span> (ann != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//设置 mavContainer 属性的绑定情况</span></span><br><span class="line">			mavContainer.setBinding(name, ann.binding());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=================初步解析参数值===================</span></span><br><span class="line">        </span><br><span class="line">		<span class="type">Object</span> <span class="variable">attribute</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">BindingResult</span> <span class="variable">bindingResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.如果 mavContainer 中有与方法参数名同名的属性名</span></span><br><span class="line">		<span class="keyword">if</span> (mavContainer.containsAttribute(name)) &#123;</span><br><span class="line">            <span class="comment">//4.1从model中获取同名属性值（会作为方法参数值）【情况一：从mavContainer的Model中获取方法参数值】</span></span><br><span class="line">			attribute = mavContainer.getModel().get(name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//4.如果 mavContainer 中没有有与方法参数名同名的属性名</span></span><br><span class="line">			<span class="comment">//4.1调用子类方法createAttribute创建属性对象【情况二：直接创建指定类型的参数值对象，此时没有绑定对象属性】</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				attribute = createAttribute(name, parameter, binderFactory, webRequest);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BindException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (isBindExceptionRequired(parameter)) &#123;</span><br><span class="line">					<span class="comment">// No BindingResult parameter -&gt; fail with BindException</span></span><br><span class="line">					<span class="keyword">throw</span> ex;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Otherwise, expose null/empty value and associated BindingResult</span></span><br><span class="line">				<span class="keyword">if</span> (parameter.getParameterType() == Optional.class) &#123;</span><br><span class="line">					attribute = Optional.empty();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					attribute = ex.getTarget();</span><br><span class="line">				&#125;</span><br><span class="line">				bindingResult = ex.getBindingResult();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=============绑定嵌套的参数值，并校验参数值==========</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.如果 bindingResult 为空（异常绑定时不为空）【核心】</span></span><br><span class="line">		<span class="keyword">if</span> (bindingResult == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// Bean property binding and validation;</span></span><br><span class="line">			<span class="comment">// skipped in case of binding failure on construction.</span></span><br><span class="line">            <span class="comment">//5.1创建指定attribute对象的数据绑定对象binder，来绑定并校验对象中的属性值</span></span><br><span class="line">			<span class="type">WebDataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> binderFactory.createBinder(webRequest, attribute, name);</span><br><span class="line">            <span class="comment">//5.2数据绑定对象binder的目标对象target非空（此时为attribute）</span></span><br><span class="line">			<span class="keyword">if</span> (binder.getTarget() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//5.2.1如果mavContainer没有禁止绑定此参数名</span></span><br><span class="line">				<span class="keyword">if</span> (!mavContainer.isBindingDisabled(name)) &#123;</span><br><span class="line">                    <span class="comment">//调用子类的bindRequestParameters方法，来通过request对象中的内容绑定对象属性数据</span></span><br><span class="line">					bindRequestParameters(binder, webRequest);</span><br><span class="line">				&#125;</span><br><span class="line">                <span class="comment">//5.2.2校验参数值</span></span><br><span class="line">				validateIfApplicable(binder, parameter);</span><br><span class="line">                <span class="comment">//5.2.3校验异常则抛出异常</span></span><br><span class="line">				<span class="keyword">if</span> (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindException</span>(binder.getBindingResult());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//5.3转换方法参数类型</span></span><br><span class="line">			<span class="comment">// Value type adaptation, also covering java.util.Optional</span></span><br><span class="line">			<span class="keyword">if</span> (!parameter.getParameterType().isInstance(attribute)) &#123;</span><br><span class="line">				attribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//5.4获取绑定结果</span></span><br><span class="line">			bindingResult = binder.getBindingResult();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.更新mavContainer</span></span><br><span class="line">		<span class="comment">// Add resolved attribute and BindingResult at the end of the model</span></span><br><span class="line">		Map&lt;String, Object&gt; bindingResultModel = bindingResult.getModel();</span><br><span class="line">		mavContainer.removeAttributes(bindingResultModel);</span><br><span class="line">		mavContainer.addAllAttributes(bindingResultModel);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//7.返回参数值</span></span><br><span class="line">		<span class="keyword">return</span> attribute;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ModelFactory.getNameForParameter(parameter)方法解析</p>
<p>作用：根据 MethodParameter对象 解析方法参数名，即基于参数上的注解或者参数类型解析参数名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ModelFactory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getNameForParameter</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">   <span class="comment">//1.获取指定方法参数上的 @ModelAttribute 注解</span></span><br><span class="line">   <span class="type">ModelAttribute</span> <span class="variable">ann</span> <span class="operator">=</span> parameter.getParameterAnnotation(ModelAttribute.class);</span><br><span class="line">   <span class="comment">//2.如果@ModelAttribute注解存在，则【基于注解value值】获取【方法参数名】</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (ann != <span class="literal">null</span> ? ann.value() : <span class="literal">null</span>);</span><br><span class="line">   <span class="comment">//3.如果@ModelAttribute注解不存在，则【基于参数类型】获取【方法参数名】</span></span><br><span class="line">   <span class="keyword">return</span> (StringUtils.hasText(name) ? name : Conventions.getVariableNameForParameter(parameter));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createAttribute(name, parameter, binderFactory, webRequest)方法解析</p>
<p>作用：根据参数名、参数类型创建方法参数值。（此时未初始化嵌套的参数属性值）。</p>
<p>1.对于**@ModelAttribute注解的参数，且未在mavContainer得Model中发现对应名称的属性时**，会在本方法创建Model的属性值，并作为方法参数值。（本子类实现如请求路径或请求参数存在此参数名的值时以此值作为方法参数值，父类实现不存在时创建Model属性对象）</p>
<p>2.对于<strong>没有@ModelAttribute注解非简单类型的参数</strong>，则会在本方法根据参数类型直接使用反射构造器创建方法参数值对象，后续再使用WebDataBinder来初始化方法参数的属性值。（完全由父类实现创建）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServletModelAttributeMethodProcessor.java</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title function_">createAttribute</span><span class="params">(String attributeName, MethodParameter parameter,</span></span><br><span class="line"><span class="params">      WebDataBinderFactory binderFactory, NativeWebRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1.从请求对象中（请求路径、请求参数）获取与参数名同名的“请求值”【只使用与@ModelAttribute参数】</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> getRequestValueForAttribute(attributeName, request);</span><br><span class="line">   <span class="comment">//2.如果 “请求值” 非空，则基于”请求值“创建属性值/方法参数值，如果非空则返回</span></span><br><span class="line">   <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//2.1基于请求值通过WebDataBinder来转换值类型为方法参数值类型（一般只适用于@ModelAttribute注解的参数情况，因为WebDataBinder不支持直接将String转换为复杂对象类型）</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">attribute</span> <span class="operator">=</span> createAttributeFromRequestValue(</span><br><span class="line">            value, attributeName, parameter, binderFactory, request);</span><br><span class="line">      <span class="comment">//2.2如果 attribute非空，则返回类型转换好的方法参数值</span></span><br><span class="line">      <span class="keyword">if</span> (attribute != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> attribute;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.如果“请求值”为空，则调用父类createAttribute来创建属性值/方法参数值对象【适用于@ModelAttribute参数和复杂类型参数】</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">super</span>.createAttribute(attributeName, parameter, binderFactory, request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据【方法参数名】从请求对象中获取“请求值”字符串</span></span><br><span class="line"><span class="comment">// * 先从【请求路径】获取指定方法参数名的 请求路径值</span></span><br><span class="line"><span class="comment">// * 再从【请求参数】中获取指定方法参数名的 请求参数值</span></span><br><span class="line"><span class="comment">// * 如果从以上参数值源中无法获取到，则返回null</span></span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">getRequestValueForAttribute</span><span class="params">(String attributeName, NativeWebRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">//1.获取请求路径名字与值的映射</span></span><br><span class="line">    Map&lt;String, String&gt; variables = getUriTemplateVariables(request);</span><br><span class="line">    <span class="comment">//2.从请求路径中获取与【方法参数名】同名的【请求路径值】“请求值”，如果非空则返回</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">variableValue</span> <span class="operator">=</span> variables.get(attributeName);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(variableValue)) &#123;</span><br><span class="line">        <span class="keyword">return</span> variableValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.获取与【方法参数名】同名的【请求参数值】，如果非空则返回</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">parameterValue</span> <span class="operator">=</span> request.getParameter(attributeName);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(parameterValue)) &#123;</span><br><span class="line">        <span class="keyword">return</span> parameterValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.如果没有与方法参数名同名的请求路径与请求参数，则返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据String类型的 sourceValue 来创建属性值对象/方法参数值对象</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createAttributeFromRequestValue</span><span class="params">(String sourceValue, String attributeName,</span></span><br><span class="line"><span class="params">        MethodParameter parameter, WebDataBinderFactory binderFactory, NativeWebRequest request)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.从 binderFactory 获取 DataBinder 对象</span></span><br><span class="line">    <span class="type">DataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> binderFactory.createBinder(request, <span class="literal">null</span>, attributeName);</span><br><span class="line">    <span class="comment">//2.从DataBinder对象获取 ConversionService 对象</span></span><br><span class="line">    <span class="type">ConversionService</span> <span class="variable">conversionService</span> <span class="operator">=</span> binder.getConversionService();</span><br><span class="line">    <span class="comment">//3.如果conversionService非空,尝试进行类型转换获取方法参数值</span></span><br><span class="line">    <span class="keyword">if</span> (conversionService != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//3.1获取源数据类型TypeDescriptor对象</span></span><br><span class="line">        <span class="type">TypeDescriptor</span> <span class="variable">source</span> <span class="operator">=</span> TypeDescriptor.valueOf(String.class);</span><br><span class="line">        <span class="comment">//3.2创建方法参数类型TypeDescriptor对象</span></span><br><span class="line">        <span class="type">TypeDescriptor</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeDescriptor</span>(parameter);</span><br><span class="line">        <span class="comment">//3.3使用 conversionService 来转换数据类型，来获取正确类型的 方法参数值对象</span></span><br><span class="line">        <span class="keyword">if</span> (conversionService.canConvert(source, target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> binder.convertIfNecessary(sourceValue, parameter.getParameterType(), parameter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.如果不支持类型转换则返回null（如：String类型=》自定义类型）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父类ModelAttributeMethodProcessor的createAttribute方法</p>
<p>作用：1.创建Model属性对象2.创建复杂类型对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ModelAttributeMethodProcessor.java</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createAttribute</span><span class="params">(String attributeName, MethodParameter parameter,</span></span><br><span class="line"><span class="params">      WebDataBinderFactory binderFactory, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1.获取非Optional类型的 MethodParameter 参数类型对象</span></span><br><span class="line">   <span class="type">MethodParameter</span> <span class="variable">nestedParameter</span> <span class="operator">=</span> parameter.nestedIfOptional();</span><br><span class="line">   <span class="comment">//2.获取方法参数类型 </span></span><br><span class="line">   Class&lt;?&gt; clazz = nestedParameter.getNestedParameterType();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.获取 方法参数反射构造器对象（可用的构造器对象）</span></span><br><span class="line">   Constructor&lt;?&gt; ctor = BeanUtils.getResolvableConstructor(clazz);</span><br><span class="line">   <span class="comment">//4.通过构造器创建方法参数值对象 【核心】</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">attribute</span> <span class="operator">=</span> constructAttribute(ctor, attributeName, parameter, binderFactory, webRequest);</span><br><span class="line">   <span class="keyword">if</span> (parameter != nestedParameter) &#123;</span><br><span class="line">      attribute = Optional.of(attribute);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//5.返回方法参数值对象 </span></span><br><span class="line">   <span class="keyword">return</span> attribute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数据绑定器工厂</strong></p>
<p><strong>核心绑定不同类型参数</strong>的组件<strong>ServletRequestDataBinderFactory</strong>，每次调用方法就会创建一个此 WebDataBinderFactory 工厂对象。</p>
<p><img src="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/image-20240420004623145.png" alt="image-20240420004623145"></p>
<p>ServletRequestDataBinderFactory组件有两个作用:</p>
<ol>
<li>对于<strong>简单</strong>类型，将String类型值（来源于请求）<strong>转换</strong>为方法参数值类型。</li>
<li>对于<strong>复杂</strong>类型，将string类型值（来源于请求）<strong>设置</strong>到方法参数对象的属性中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServletRequestDataBinderFactory工厂对象的顶层设计</span></span><br><span class="line"><span class="comment">//主要实现了创建ExtendedServletRequestDataBinder对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletRequestDataBinderFactory</span> <span class="keyword">extends</span> <span class="title class_">InitBinderDataBinderFactory</span> &#123;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServletRequestDataBinderFactory</span><span class="params">(<span class="meta">@Nullable</span> List&lt;InvocableHandlerMethod&gt; binderMethods,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> WebBindingInitializer initializer)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">super</span>(binderMethods, initializer);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取 ExtendedServletRequestDataBinder类型的 DataBinder 对象（非单例的）</span></span><br><span class="line">    <span class="keyword">protected</span> ServletRequestDataBinder <span class="title function_">createBinderInstance</span><span class="params">(</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> Object target, String objectName, NativeWebRequest request)</span> <span class="keyword">throws</span> Exception  &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExtendedServletRequestDataBinder</span>(target, objectName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主要存储了InitBinder方法集合、和实现了其相关方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitBinderDataBinderFactory</span> <span class="keyword">extends</span> <span class="title class_">DefaultDataBinderFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//InitBinderDataBinderFactory子类核心属性，封装了构造器传入的InitBinder方法对象集合</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;InvocableHandlerMethod&gt; binderMethods;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器，初始化binderMethods属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InitBinderDataBinderFactory</span><span class="params">(<span class="meta">@Nullable</span> List&lt;InvocableHandlerMethod&gt; binderMethods,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> WebBindingInitializer initializer)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">super</span>(initializer);</span><br><span class="line">		<span class="built_in">this</span>.binderMethods = (binderMethods != <span class="literal">null</span> ? binderMethods : Collections.emptyList());</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用本对象的binderMethods属性来初始化传入的 WebDataBinder 参数对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initBinder</span><span class="params">(WebDataBinder dataBinder, NativeWebRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">for</span> (InvocableHandlerMethod binderMethod : <span class="built_in">this</span>.binderMethods) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isBinderMethodApplicable(binderMethod, dataBinder)) &#123;</span><br><span class="line">				<span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> binderMethod.invokeForRequest(request, <span class="literal">null</span>, dataBinder);</span><br><span class="line">				<span class="keyword">if</span> (returnValue != <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">							<span class="string">&quot;@InitBinder methods must not return a value (should be void): &quot;</span> + binderMethod);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是否可以对指定WebDataBinder使用指定HandlerMethod</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isBinderMethodApplicable</span><span class="params">(HandlerMethod initBinderMethod, WebDataBinder dataBinder)</span> &#123;</span><br><span class="line">		<span class="type">InitBinder</span> <span class="variable">ann</span> <span class="operator">=</span> initBinderMethod.getMethodAnnotation(InitBinder.class);</span><br><span class="line">		Assert.state(ann != <span class="literal">null</span>, <span class="string">&quot;No InitBinder annotation&quot;</span>);</span><br><span class="line">		String[] names = ann.value();</span><br><span class="line">		<span class="keyword">return</span> (ObjectUtils.isEmpty(names) || ObjectUtils.containsElement(names, dataBinder.getObjectName()));</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主要存储了WebBindingInitializer对象，并实现了使用它来初始化WebRequestDataBinder对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultDataBinderFactory</span> <span class="keyword">implements</span> <span class="title class_">WebDataBinderFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化器属性（构造器传入）</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> WebBindingInitializer initializer;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DefaultDataBinderFactory</span><span class="params">(<span class="meta">@Nullable</span> WebBindingInitializer initializer)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.initializer = initializer;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接口实现，底层模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> WebDataBinder <span class="title function_">createBinder</span><span class="params">(</span></span><br><span class="line"><span class="params">			NativeWebRequest webRequest, <span class="meta">@Nullable</span> Object target, String objectName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.使用子类ServletRequestDataBinderFactory工厂对象方法创建WebDataBinder对象</span></span><br><span class="line">		<span class="type">WebDataBinder</span> <span class="variable">dataBinder</span> <span class="operator">=</span> createBinderInstance(target, objectName, webRequest);</span><br><span class="line">        <span class="comment">//2.使用 initializer 属性对象中的属性来【初始化 dataBinder】的属性</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.initializer != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.initializer.initBinder(dataBinder, webRequest);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//3.调用父类InitBinderDataBinderFactory的initBinder方法，使用initBinder方法集合来【初始化 dataBinder】</span></span><br><span class="line">		initBinder(dataBinder, webRequest);</span><br><span class="line">		<span class="keyword">return</span> dataBinder;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口 WebDataBinderFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WebDataBinderFactory</span> &#123;</span><br><span class="line">    <span class="comment">//创建 WebDataBinder</span></span><br><span class="line">    <span class="comment">//Params:</span></span><br><span class="line">	<span class="comment">//webRequest – the current request</span></span><br><span class="line">	<span class="comment">//target – the object to create a data binder for, or null if creating a binder for a simple type</span></span><br><span class="line">	<span class="comment">//objectName – the name of the target object</span></span><br><span class="line">    WebDataBinder <span class="title function_">createBinder</span><span class="params">(NativeWebRequest webRequest, <span class="meta">@Nullable</span> Object target, String objectName)</span></span><br><span class="line">			<span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>数据绑定器</strong></p>
<p><img src="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/image-20240420005124008.png" alt="image-20240420005124008"></p>
<p>核心入口方法是<strong>bind(ServletRequest request)方法</strong>！</p>
<p>方法位于ServletRequestDataBinder类中。</p>
<p>作用：</p>
<ol>
<li>收集【请求参数】中的数据创建 ServletRequestParameterPropertyValues 对象，</li>
<li>调用父类addBindValues(mpvs, request)方法收集【请求路径】中的数据填充ServletRequestParameterPropertyValues数据，</li>
<li>调用子类WebDataBinder的doBind(mpvs)方法来真正执行数据绑定。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入口方法所在类（从请求对象执行数据绑定到目标参数对象（这里是此对象的target属性））</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletRequestDataBinder</span> <span class="keyword">extends</span> <span class="title class_">WebDataBinder</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//入口方法。将【请求对象中的数据】绑定到【绑定器属性target中】。绑定支持multipart file</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(ServletRequest request)</span> &#123;</span><br><span class="line"><span class="comment">//==============查询数据绑定源数据=============</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.创建 ServletRequestParameterPropertyValues 对象，基于【请求参数数据】创建对象</span></span><br><span class="line">		<span class="type">MutablePropertyValues</span> <span class="variable">mpvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRequestParameterPropertyValues</span>(request);</span><br><span class="line">        <span class="comment">//2.处理 文件类型的 方法参数数据绑定</span></span><br><span class="line">		<span class="type">MultipartRequest</span> <span class="variable">multipartRequest</span> <span class="operator">=</span> WebUtils.getNativeRequest(request, MultipartRequest.class);</span><br><span class="line">		<span class="keyword">if</span> (multipartRequest != <span class="literal">null</span>) &#123;</span><br><span class="line">			bindMultipart(multipartRequest.getMultiFileMap(), mpvs);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.startsWithIgnoreCase(request.getContentType(), MediaType.MULTIPART_FORM_DATA_VALUE)) &#123;</span><br><span class="line">			<span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> WebUtils.getNativeRequest(request, HttpServletRequest.class);</span><br><span class="line">			<span class="keyword">if</span> (httpServletRequest != <span class="literal">null</span> &amp;&amp; HttpMethod.POST.matches(httpServletRequest.getMethod())) &#123;</span><br><span class="line">				StandardServletPartUtils.bindParts(httpServletRequest, mpvs, isBindEmptyMultipartFiles());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//3.基于【请求路径数据】将绑定数据源添加到创建的 mpvs 对象中</span></span><br><span class="line">		addBindValues(mpvs, request);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=============使用mpvs来执行数据绑定==========</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.使用收集到的绑定数据来真正执行数据绑定</span></span><br><span class="line">		doBind(mpvs);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WebDataBinder的doBind(mpvs)方法</p>
<p>作用：1.校验mpvs中的默认字段2.校验mpvs中的空白字段3.将mpvs中的[]名字后缀去掉4.真正执行数据绑定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WebDataBinder.java</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">fieldMarkerPrefix</span> <span class="operator">=</span> DEFAULT_FIELD_MARKER_PREFIX;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">fieldDefaultPrefix</span> <span class="operator">=</span> DEFAULT_FIELD_DEFAULT_PREFIX;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">bindEmptyMultipartFiles</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBind</span><span class="params">(MutablePropertyValues mpvs)</span> &#123;</span><br><span class="line">   <span class="comment">//1.从 mpvs 查找以 &quot;！&quot;开头的PropertyValue，并将其item移除，且可能会添加新的item。即检查有无默认值并视情况使用</span></span><br><span class="line">   checkFieldDefaults(mpvs);</span><br><span class="line">   <span class="comment">//2.从 mpvs 查找以 &quot;_&quot;开头的PropertyValue，并将其item移除，且可能会添加新的item。即检查有无空白值并视情况使用</span></span><br><span class="line">   checkFieldMarkers(mpvs);</span><br><span class="line">   <span class="comment">//3.从 mpvs 查找以 &quot;[]&quot;结束的PropertyValue，并将其item移除，且可能会添加新的item。</span></span><br><span class="line">   adaptEmptyArrayIndices(mpvs);</span><br><span class="line">   <span class="comment">//4.调用父类DataBinder.dobind(mpvs)真正执行数据绑定</span></span><br><span class="line">   <span class="built_in">super</span>.doBind(mpvs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DataBinder的dobind(mpvs)方法</p>
<p>作用：1.校验是否允许绑定2.校验是否必须绑定3.指定数据绑定</p>
<p>是基于<strong>BeanWrapperImpl</strong>来实现的bean属性的数据类型转换，更核心的是<strong>AbstractNestablePropertyAccessor</strong>.java类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBind</span><span class="params">(MutablePropertyValues mpvs)</span> &#123;</span><br><span class="line">   <span class="comment">//1.通过本类属性allowedFields、disallowedFields来校验指定字段是否允许绑定 </span></span><br><span class="line">   checkAllowedFields(mpvs);</span><br><span class="line">   <span class="comment">//2.通过本类属性requiredFields来校验指定必须绑定的字段 </span></span><br><span class="line">   checkRequiredFields(mpvs);</span><br><span class="line">   <span class="comment">//3.真正执行数据绑定 </span></span><br><span class="line">   applyPropertyValues(mpvs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真正执行数据绑定的我方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">applyPropertyValues</span><span class="params">(MutablePropertyValues mpvs)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Bind request parameters onto target object.</span></span><br><span class="line">        <span class="comment">//1.首先从bindingResult属性中获取beanWrapper属性即得到ConfigurablePropertyAccessor（真实类型BeanWrapperImpl）；然后调用其setPropertyValues方法【核心是BeanWrapperImpl类的实现】</span></span><br><span class="line">        getPropertyAccessor().setPropertyValues(mpvs, isIgnoreUnknownFields(), isIgnoreInvalidFields());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (PropertyBatchUpdateException ex) &#123;</span><br><span class="line">        <span class="comment">// Use bind error processor to create FieldErrors.</span></span><br><span class="line">        <span class="keyword">for</span> (PropertyAccessException pae : ex.getPropertyAccessExceptions()) &#123;</span><br><span class="line">            getBindingErrorProcessor().processPropertyAccessException(pae, getInternalBindingResult());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> ConfigurablePropertyAccessor <span class="title function_">getPropertyAccessor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getInternalBindingResult().getPropertyAccessor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> AbstractPropertyBindingResult <span class="title function_">getInternalBindingResult</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.bindingResult == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.bindingResult = (<span class="built_in">this</span>.directFieldAccess ?</span><br><span class="line">                createDirectFieldBindingResult(): createBeanPropertyBindingResult());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.bindingResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>BeanWrapperImpl的核心</strong>转换数据类型是基于：<strong>ConversionService</strong>（TODO：分析BeanWrapperImpl、与WebConversionService组件）</p>
<p>对象参数转换核心：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConversionService接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConversionService</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">canConvert</span><span class="params">(<span class="meta">@Nullable</span> Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">canConvert</span><span class="params">(<span class="meta">@Nullable</span> TypeDescriptor sourceType, TypeDescriptor targetType)</span>;</span><br><span class="line">    &lt;T&gt; T <span class="title function_">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, Class&lt;T&gt; targetType)</span>;</span><br><span class="line">    Object <span class="title function_">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, <span class="meta">@Nullable</span> TypeDescriptor sourceType, TypeDescriptor targetType)</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>核心实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GenericConversionService（WebConversionService父类）</span></span><br><span class="line"><span class="comment">//WebConversionService(WebMvcAutoConfiguration自动注入)</span></span><br></pre></td></tr></table></figure>



<h4 id="5-RequestResponseBodyMethodProcessor源码分析"><a href="#5-RequestResponseBodyMethodProcessor源码分析" class="headerlink" title="5.RequestResponseBodyMethodProcessor源码分析"></a>5.RequestResponseBodyMethodProcessor源码分析</h4></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://featherbrainna.github.io">wzy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://featherbrainna.github.io/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/">https://featherbrainna.github.io/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://featherbrainna.github.io" target="_blank">淡云月来去</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring-MVC/">Spring MVC</a></div><div class="post_share"><div class="social-share" data-image="/./img/springMVC.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2024/04/21/IDEA%E4%B8%ADmaven%E5%A4%9A%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%9C%BA%E5%88%B6/"><img class="prev-cover" src="/./img/maven.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">IDEA中maven多模块打包方式与机制</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">wzy</div><div class="author-info__description">java知识分享、个人博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/featherbrainna"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/featherbrainna" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:578996401@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=or3qBLP2W6fec06prAHhrNj-ldIc-qHH&amp;noverify=0&amp;personal_qrcode_source=4" target="_blank" title=""><i class="fa-brands fa-qq"></i></a><a class="social-icon" href="https://weibo.com/u/6536962254" target="_blank" title=""><i class="fa-brands fa-weibo"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">最近在研究spring security</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BB%84%E4%BB%B6%E6%A6%82%E8%A7%88"><span class="toc-text">1.组件概览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1HandlerMapping"><span class="toc-text">1.1HandlerMapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2HandlerAdapter"><span class="toc-text">1.2HandlerAdapter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3HandlerExceptionResolver"><span class="toc-text">1.3HandlerExceptionResolver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4ViewResolver"><span class="toc-text">1.4ViewResolver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5RequestToViewNameTranslator"><span class="toc-text">1.5RequestToViewNameTranslator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6LocaleResolver"><span class="toc-text">1.6LocaleResolver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7ThemeResolver"><span class="toc-text">1.7ThemeResolver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8MultipartResolver"><span class="toc-text">1.8MultipartResolver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9FlashMapManager"><span class="toc-text">1.9FlashMapManager</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-HandlerMapping"><span class="toc-text">2.HandlerMapping</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1AbstractHandlerMapping"><span class="toc-text">2.1AbstractHandlerMapping</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAAbstractHandlerMapping%E4%B9%8B%E5%99%A8"><span class="toc-text">创建AbstractHandlerMapping之器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AbstractHandlerMapping%E4%B9%8B%E7%94%A8"><span class="toc-text">AbstractHandlerMapping之用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2AbstractUrlHandlerMapping%E7%B3%BB%E5%88%97"><span class="toc-text">2.2AbstractUrlHandlerMapping系列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AbstractUrlHandlerMapping"><span class="toc-text">AbstractUrlHandlerMapping</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SimpleUrlHandlerMapping"><span class="toc-text">SimpleUrlHandlerMapping</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AbstractDetectingUrlHandlerMapping"><span class="toc-text">AbstractDetectingUrlHandlerMapping</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3AbstractHandlerMethodMapping%E7%B3%BB%E5%88%97"><span class="toc-text">2.3AbstractHandlerMethodMapping系列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAAbstractHandlerMethodMapping%E7%B3%BB%E5%88%97%E4%B9%8B%E5%99%A8"><span class="toc-text">创建AbstractHandlerMethodMapping系列之器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AbstractHandlerMethodMapping%E7%B3%BB%E5%88%97%E4%B9%8B%E7%94%A8"><span class="toc-text">AbstractHandlerMethodMapping系列之用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E5%B0%8F%E7%BB%93"><span class="toc-text">2.4小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-HandlerAdapter"><span class="toc-text">3.HandlerAdapter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1RequestMappingHandlerAdapter%E6%A6%82%E8%BF%B0"><span class="toc-text">3.1RequestMappingHandlerAdapter概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2RequestMappingHandlerAdapter%E8%87%AA%E8%BA%AB%E7%BB%93%E6%9E%84"><span class="toc-text">3.2RequestMappingHandlerAdapter自身结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BARequestMappingHandlerAdapter%E4%B9%8B%E5%99%A8"><span class="toc-text">创建RequestMappingHandlerAdapter之器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RequestMappingHandlerAdapter%E4%B9%8B%E7%94%A8"><span class="toc-text">RequestMappingHandlerAdapter之用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-handleInternal%E6%96%B9%E6%B3%95"><span class="toc-text">1.handleInternal方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-invokeHandleMethod%E6%96%B9%E6%B3%95"><span class="toc-text">2.invokeHandleMethod方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3ModelAndViewContainer"><span class="toc-text">3.3ModelAndViewContainer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4SessionAttributesHandler%E5%92%8CSessionAttributeStore"><span class="toc-text">3.4SessionAttributesHandler和SessionAttributeStore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5ModelFactory"><span class="toc-text">3.5ModelFactory</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96Model"><span class="toc-text">初始化Model</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0Model"><span class="toc-text">更新Model</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6ServletInvocableHandlerMethod"><span class="toc-text">3.6ServletInvocableHandlerMethod</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-1HandlerMethod"><span class="toc-text">3.6.1HandlerMethod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-2InvocableHandlerMethod"><span class="toc-text">3.6.2InvocableHandlerMethod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-3ServletInvocableHandlerMethod"><span class="toc-text">3.6.3ServletInvocableHandlerMethod</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7HandlerMethodArgumentResolver"><span class="toc-text">3.7HandlerMethodArgumentResolver</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ModelMethodProcessor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">1.ModelMethodProcessor源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-PathVariableMethodArgumentResolver%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">2.PathVariableMethodArgumentResolver源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-RequestParamMethodArgumentResolver%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">3.RequestParamMethodArgumentResolver源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-ServletModelAttributeMethodProcessor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">4.ServletModelAttributeMethodProcessor源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-RequestResponseBodyMethodProcessor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">5.RequestResponseBodyMethodProcessor源码分析</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/" title="Spring-MVC组件分析"><img src="/./img/springMVC.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring-MVC组件分析"/></a><div class="content"><a class="title" href="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/" title="Spring-MVC组件分析">Spring-MVC组件分析</a><time datetime="2024-04-21T01:42:38.000Z" title="发表于 2024-04-21 09:42:38">2024-04-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/21/IDEA%E4%B8%ADmaven%E5%A4%9A%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%9C%BA%E5%88%B6/" title="IDEA中maven多模块打包方式与机制"><img src="/./img/maven.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IDEA中maven多模块打包方式与机制"/></a><div class="content"><a class="title" href="/2024/04/21/IDEA%E4%B8%ADmaven%E5%A4%9A%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%9C%BA%E5%88%B6/" title="IDEA中maven多模块打包方式与机制">IDEA中maven多模块打包方式与机制</a><time datetime="2024-04-21T00:43:17.000Z" title="发表于 2024-04-21 08:43:17">2024-04-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/" title="Spring-Security源码解析与实战（持续更新）"><img src="/./img/springSecurity.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring-Security源码解析与实战（持续更新）"/></a><div class="content"><a class="title" href="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/" title="Spring-Security源码解析与实战（持续更新）">Spring-Security源码解析与实战（持续更新）</a><time datetime="2024-02-25T15:50:53.000Z" title="发表于 2024-02-25 23:50:53">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/14/%E5%85%B3%E4%BA%8E%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF%E9%82%A3%E4%BA%9B%E4%BA%8B/" title="关于部署上线那些事"><img src="/./img/bt.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于部署上线那些事"/></a><div class="content"><a class="title" href="/2024/02/14/%E5%85%B3%E4%BA%8E%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF%E9%82%A3%E4%BA%9B%E4%BA%8B/" title="关于部署上线那些事">关于部署上线那些事</a><time datetime="2024-02-14T09:16:00.000Z" title="发表于 2024-02-14 17:16:00">2024-02-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/14/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0~%EF%BC%89/" title="异常及其解决方案汇总（持续更新~）"><img src="/./img/summary.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="异常及其解决方案汇总（持续更新~）"/></a><div class="content"><a class="title" href="/2024/02/14/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0~%EF%BC%89/" title="异常及其解决方案汇总（持续更新~）">异常及其解决方案汇总（持续更新~）</a><time datetime="2024-02-14T08:16:00.000Z" title="发表于 2024-02-14 16:16:00">2024-02-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/./img/springMVC.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By wzy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://featherbrainna.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'GbOYbdcEvuOxM7YfTqwXQ664-gzGzoHsz',
      appKey: 'vCrYp5O8ZWaOdSx4suuhZrkb',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://featherbrainna.github.io/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/'
    this.page.identifier = '/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/'
    this.page.title = 'Spring-MVC组件分析'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script>window.$crisp = [];
window.CRISP_WEBSITE_ID = "2e53c9c7-c85c-4d34-94a3-80c801a15ca1";
(function () {
  d = document;
  s = d.createElement("script");
  s.src = "https://client.crisp.chat/l.js";
  s.async = 1;
  d.getElementsByTagName("head")[0].appendChild(s);
})();
$crisp.push(["safe", true])

if (true) {
  $crisp.push(["do", "chat:hide"])
  $crisp.push(["on", "chat:closed", function() {
    $crisp.push(["do", "chat:hide"])
  }])
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      $crisp.push(["do", "chat:show"])
      $crisp.push(["do", "chat:open"])

    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      $crisp.push(["do", "chat:hide"])
    }
    function chatBtnShow () {
      $crisp.push(["do", "chat:show"])
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>