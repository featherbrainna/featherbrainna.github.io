<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java树形数据结构两种构建方式</title>
      <link href="/2024/07/02/Java%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%A4%E7%A7%8D%E6%9E%84%E5%BB%BA%E6%96%B9%E5%BC%8F/"/>
      <url>/2024/07/02/Java%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%A4%E7%A7%8D%E6%9E%84%E5%BB%BA%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="方式一：Stream分组"><a href="#方式一：Stream分组" class="headerlink" title="方式一：Stream分组"></a>方式一：Stream分组</h2><p>使用stream分组子节点，再连接父子节点，最后返回根节点集合。2*n时间复杂度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.原始列表数据</span></span><br><span class="line">List&lt;Node&gt; nodes = 。。。</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.将数结构的【子节点】全部选出来，并根据子节点的 【父id】 分组，返回Map。（key:父id,value：子节点集合）</span></span><br><span class="line">Map&lt;String, List&lt;Node&gt;&gt; childNodes = CollectionUtils.convertMultiMap(</span><br><span class="line">        CollectionUtils.filterList(nodes, r -&gt; StringUtils.isNotBlank(r.getParentId())),</span><br><span class="line">        Node::getParentId);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.连接父子节点</span></span><br><span class="line"><span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line">    node.setChildren(childNodes.get(node.getId()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.返回根节点列表</span></span><br><span class="line"><span class="keyword">return</span> CollectionUtils.filterList(nodes,r -&gt; StringUtils.isBlank(r.getParentId()));</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionUtils</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用 keyFunc 将集合转换为 Map&lt;K,List&lt;V&gt;&gt;集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,List&lt;V&gt;&gt; <span class="title function_">convertMultiMap</span><span class="params">(Collection&lt;V&gt; from,Function&lt;V,K&gt; keyFunc)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollUtil.isEmpty(from)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> from.stream().collect(Collectors.groupingBy(keyFunc,Collectors.mapping(Function.identity(),Collectors.toList())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">filterList</span><span class="params">(Collection&lt;T&gt; from, Predicate&lt;T&gt; predicate)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollUtil.isEmpty(from)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> from.stream().filter(predicate).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方式二：Stream双重遍历"><a href="#方式二：Stream双重遍历" class="headerlink" title="方式二：Stream双重遍历"></a>方式二：Stream双重遍历</h2><p>n^2时间复杂度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.原始列表数据</span></span><br><span class="line">List&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//2.返回根节点列表</span></span><br><span class="line">List&lt;Node&gt; roots = nodes.stream().filter(father -&gt; &#123;</span><br><span class="line">    father.children = nodes.stream().filter(child -&gt; Objects.equals(father.id,child.parentId)).collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> StringUtils.isBlank(father.getParentId());</span><br><span class="line">&#125;).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其它 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-MVC组件分析</title>
      <link href="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/"/>
      <url>/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="1-组件概览"><a href="#1-组件概览" class="headerlink" title="1.组件概览"></a>1.组件概览</h2><p>这里的组件指的是DispatcherServlet中直接初始化的那九个组件，不同的组件内部还会用到一些子组件。</p><h3 id="1-1HandlerMapping"><a href="#1-1HandlerMapping" class="headerlink" title="1.1HandlerMapping"></a>1.1HandlerMapping</h3><p>作用：根据request找到相应的处理器Handler和Interceptors。</p><p>可以<strong>实现Order接口以控制遍历HandlerMapping的顺序</strong>，越小越先使用优先级越高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerMapping</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">usesPathPatterns</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//1.根据请求获取HandlerExecutionChain</span></span><br><span class="line">    HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2HandlerAdapter"><a href="#1-2HandlerAdapter" class="headerlink" title="1.2HandlerAdapter"></a>1.2HandlerAdapter</h3><p>作用：调用handler来真正处理请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">//1.根据handler判断本对象是否支持使用该handler处理</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span>;</span><br><span class="line">    <span class="comment">//2.使用handler进行处理</span></span><br><span class="line">    ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="comment">//3.获取资源的Last-Modified（资源最后一次的修改时间）</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>视图名称是handler处理器返回的，或者RequestToViewNameTranslator获取的默认视图名。</p></blockquote><h3 id="1-3HandlerExceptionResolver"><a href="#1-3HandlerExceptionResolver" class="headerlink" title="1.3HandlerExceptionResolver"></a>1.3HandlerExceptionResolver</h3><p>作用：请求处理过程出现异常后，由此组件进行处理。只用于解析对请求做处理过程中的异常，而渲染环节产生的异常不归它管。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line">    <span class="comment">//根据异常解析处理异常</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">ModelAndView <span class="title function_">resolveException</span><span class="params">(</span></span><br><span class="line"><span class="params">HttpServletRequest request, HttpServletResponse response, <span class="meta">@Nullable</span> Object handler, Exception ex)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4ViewResolver"><a href="#1-4ViewResolver" class="headerlink" title="1.4ViewResolver"></a>1.4ViewResolver</h3><p>作用：将String类型的视图名和Locale解析为View类型的视图，找到渲染所需要的模板和所用技术（也就是视图类型）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ViewResolver</span> &#123;</span><br><span class="line">    <span class="comment">//根据视图名称解析视图对象</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">View <span class="title function_">resolveViewName</span><span class="params">(String viewName, Locale locale)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最常使用的UrlBasedViewResolver系列的解析器都是针对单一视图类型进行解析的，如FreeMarkerViewResolver、InternalResourceViewResolver、VelocityViewResolver、ThymeleafViewResolver。</p><p>ResourceBundleViewResolver、XmlViewResolver、BeanNameResolver可以同时解析多种类型的视图。<strong>ResourceBundleViewResolver</strong>根据properties文件解析出视图，文件中指定视图类型和视图地址；<strong>XmlViewResolver</strong>根据xml文件解析出视图；<strong>BeanNameResolver</strong>是根据viewName从ApplicationContext容器中查找相应的bean做为View。</p><h3 id="1-5RequestToViewNameTranslator"><a href="#1-5RequestToViewNameTranslator" class="headerlink" title="1.5RequestToViewNameTranslator"></a>1.5RequestToViewNameTranslator</h3><p>作用：处理返回的ModelAndVIew对象中即没有view也没有设置viewName的情况，这时需要从request获取viewName。即定义了如何从请求对象获取viewName。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RequestToViewNameTranslator</span> &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">String <span class="title function_">getViewName</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6LocaleResolver"><a href="#1-6LocaleResolver" class="headerlink" title="1.6LocaleResolver"></a>1.6LocaleResolver</h3><p>作用：从request中解析出Locale。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LocaleResolver</span> &#123;</span><br><span class="line">    <span class="comment">//从请求获取Locale</span></span><br><span class="line">Locale <span class="title function_">resolveLocale</span><span class="params">(HttpServletRequest request)</span>;</span><br><span class="line">    <span class="comment">//设置请求和响应Locale</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setLocale</span><span class="params">(HttpServletRequest request, <span class="meta">@Nullable</span> HttpServletResponse response, <span class="meta">@Nullable</span> Locale locale)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring MVC中主要在<strong>两个地方用到了Locale</strong>：1.ViewResolver解析视图的时候2.使用到国际化资源或者主题的时候。</p><p>我们可以通过MVC拦截器 <code>LocaleChangeInterceptor</code> 来拦截请求的请求参数，从而设置改变请求的Locale属性。比如<a href="http://localhost:8080/?locale=zh_cn%E5%B0%B1%E4%BC%9A%E5%B0%86%E8%AF%B7%E6%B1%82%E7%9A%84Locale%E8%AE%BE%E7%BD%AE%E4%B8%BA%E4%B8%AD%E6%96%87%E3%80%82">http://localhost:8080?locale=zh_cn就会将请求的Locale设置为中文。</a></p><h3 id="1-7ThemeResolver"><a href="#1-7ThemeResolver" class="headerlink" title="1.7ThemeResolver"></a>1.7ThemeResolver</h3><p>作用：根据请求解析主题名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ThemeResolver</span> &#123;</span><br><span class="line">    <span class="comment">//解析主题</span></span><br><span class="line">    String <span class="title function_">resolveThemeName</span><span class="params">(HttpServletRequest request)</span>;</span><br><span class="line">    <span class="comment">//设置主题</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setThemeName</span><span class="params">(HttpServletRequest request, <span class="meta">@Nullable</span> HttpServletResponse response, <span class="meta">@Nullable</span> String themeName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring MVC中一套主题对应一个properties文件，里面存放着跟当前主题相关的所有资源，如图片、css样式等。例如：</p><p><img src="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/image-20240321160414104.png" alt="image-20240321160414104"></p><p><strong>ThemeResolver</strong>的作用是从request解析出主题名；<strong>ThemeSource</strong>则是根据主题名找到具体的主题；<strong>Theme</strong>是ThemeSource找出的一个具体的主题，可以通过它获取主题里面的资源。</p><p>获取主题资源是在RequestContext中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RequestContext.java</span></span><br><span class="line"><span class="keyword">public</span> Theme <span class="title function_">getTheme</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.theme == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Lazily determine theme to use for this RequestContext.</span></span><br><span class="line">      <span class="built_in">this</span>.theme = RequestContextUtils.getTheme(<span class="built_in">this</span>.request);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.theme == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// No ThemeResolver and ThemeSource available -&gt; try fallback.</span></span><br><span class="line">         <span class="built_in">this</span>.theme = getFallbackTheme();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.theme;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RequestContextUtils.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Theme <span class="title function_">getTheme</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">//1.根据请求获取ThemeResolver（数据源于IOC容器）</span></span><br><span class="line">    <span class="type">ThemeResolver</span> <span class="variable">themeResolver</span> <span class="operator">=</span> getThemeResolver(request);</span><br><span class="line">    <span class="comment">//2.根据请求获取ThemeSource</span></span><br><span class="line">    <span class="type">ThemeSource</span> <span class="variable">themeSource</span> <span class="operator">=</span> getThemeSource(request);</span><br><span class="line">    <span class="keyword">if</span> (themeResolver != <span class="literal">null</span> &amp;&amp; themeSource != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//3.themeResolver根据请求解析主题名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">themeName</span> <span class="operator">=</span> themeResolver.resolveThemeName(request);</span><br><span class="line">        <span class="comment">//4.themeSource根据主题名称解析主题对象</span></span><br><span class="line">        <span class="keyword">return</span> themeSource.getTheme(themeName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ThemeResolver的默认实现是 FixedThemeResolver</strong>，这里边使用固定的默认主题”theme”。</p><p><strong>ThemeSource的默认实现是WebApplicationContext的实现类</strong>。默认底层实现是ResourceBundleThemeSource，即WebApplicationContext封装了themesource属性的实现类型为ResourceBundleThemeSource，<strong>具体创建过程在UiApplicationContextUtils的initThemeSource方法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接调用构造器创建，且设置到WebApplicationContext的themesource属性</span></span><br><span class="line">themeSource = <span class="keyword">new</span> <span class="title class_">ResourceBundleThemeSource</span>();</span><br></pre></td></tr></table></figure><p>Spring MVC中主题切换和Locale的切换使用相同的模式，也是使用Interceptor，即<strong>ThemeChangeInterceptor</strong>。</p><h3 id="1-8MultipartResolver"><a href="#1-8MultipartResolver" class="headerlink" title="1.8MultipartResolver"></a>1.8MultipartResolver</h3><p>作用：用于处理上传请求，处理方法是将普通request包装成MultipartHttpServletRequest，后者可以直接调用getFile方法获取到File，或多文件getFileMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MultipartResolver</span> &#123;</span><br><span class="line">    <span class="comment">//1.判断是不是上传请求</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isMultipart</span><span class="params">(HttpServletRequest request)</span>;</span><br><span class="line">    <span class="comment">//2.将request包装成MultipartHttpServletRequest</span></span><br><span class="line">    MultipartHttpServletRequest <span class="title function_">resolveMultipart</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> MultipartException;</span><br><span class="line">    <span class="comment">//3.处理完后清理上传过程中产生的临时资源</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cleanupMultipart</span><span class="params">(MultipartHttpServletRequest request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-9FlashMapManager"><a href="#1-9FlashMapManager" class="headerlink" title="1.9FlashMapManager"></a>1.9FlashMapManager</h3><p>作用：管理FlashMap。</p><p>FlashMap主要用在redirect中传递参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FlashMapManager</span> &#123;</span><br><span class="line">    <span class="comment">//获取input flashmap</span></span><br><span class="line">    FlashMap <span class="title function_">retrieveAndUpdate</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>;</span><br><span class="line">    <span class="comment">//设置output flashmap</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">saveOutputFlashMap</span><span class="params">(FlashMap flashMap, HttpServletRequest request, HttpServletResponse response)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>retrieveAndUpdate</strong>方法用于恢复参数，并将恢复过的和超时的参数从保存介质中删除；<strong>saveOutputFlashMap</strong>用于将参数保存起来。</p><p>默认实现是 <code>SessionFlashMapManager</code> ，它是将参数保存到session中。</p><p>整个redirect的参数通过FlashMap的传递过程分为<strong>三步</strong>：</p><p>1.<strong>在处理器中将需要传递的参数设置到outputFlashMap中</strong>。当处理器处理完请求时，<strong>如果是redirect类型的返回值RequestMappingHandlerAdapter会将其设置到outputFlashMap中</strong>。即adapter的getModelAndView方法中实现。</p><p>2.在<strong>RedirectView</strong>的renderMergedOutputModel方法中<strong>调用FlashMapManager的saveOutputFlashMap方法</strong>，将outputFlashMap中的参数设置到Session中。</p><p>3.请求redirect后DispatcherServlet的<strong>doService会调用FlashMapManager的retrieveAndUpdate方法</strong>从Session中获取inputFlashMap并设置到Request的属性中备用，同时从Session中删除。</p><h2 id="2-HandlerMapping"><a href="#2-HandlerMapping" class="headerlink" title="2.HandlerMapping"></a>2.HandlerMapping</h2><p>HandlerMapping的继承结构如图：</p><p><img src="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/image-20240321183031638.png" alt="image-20240321183031638"></p><h3 id="2-1AbstractHandlerMapping"><a href="#2-1AbstractHandlerMapping" class="headerlink" title="2.1AbstractHandlerMapping"></a>2.1AbstractHandlerMapping</h3><p>是HandlerMapping的抽象实现，<strong>所有HandlerMapping都继承自AbstractHandlerMapping</strong>。</p><p>AbstractHandlerMapping采用模板模式设计了HandlerMapping实现的整体结构，子类只需要通过模板方法提供一些初始值或具体的算法即可。</p><h4 id="创建AbstractHandlerMapping之器"><a href="#创建AbstractHandlerMapping之器" class="headerlink" title="创建AbstractHandlerMapping之器"></a>创建AbstractHandlerMapping之器</h4><p>1.initApplicationContext方法</p><p>作用：初始化HandlerMapping的拦截器，包括其interceptors属性和adaptedInterceptors属性，<strong>具体初始化方式就是新增</strong>拦截器到属性中。</p><p>由于AbstractHandlerMapping继承了WebAppliactionObjectSupport，所以该对象创建时会调用父类的setApplicationContext方法，然后其方法又会调用本类的initApplicationContext()方法。即<strong>AbstractHandlerMapping的初始化就是在initApplicationContext方法实现</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initApplicationContext</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   extendInterceptors(<span class="built_in">this</span>.interceptors);</span><br><span class="line">   detectMappedInterceptors(<span class="built_in">this</span>.adaptedInterceptors);</span><br><span class="line">   initInterceptors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.extendInterceptors方法</p><p>作用：初始化HandlerMapping的interceptors属性</p><p>是<strong>模板方法</strong>，用于给子类提供一个添加（或者修改）Interceptors的入口，不过在现有Spring MVC的实现中并没有使用。</p><p>3.detectMappedInterceptors方法</p><p>作用：将Spring MVC容器及父容器中的<strong>所有MappedInterceptor类型的Bean添加到HandlerMapping的 adaptedInterceptors 属性</strong>。即初始化HandlerMapping的adaptedInterceptors属性。</p><p>即将用户注册的按请求路径是否生效的拦截器MappedInterceptor添加到HandlerMapping的adaptedInterceptors属性中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">detectMappedInterceptors</span><span class="params">(List&lt;HandlerInterceptor&gt; mappedInterceptors)</span> &#123;</span><br><span class="line">mappedInterceptors.addAll(BeanFactoryUtils.beansOfTypeIncludingAncestors(</span><br><span class="line">         obtainApplicationContext(), MappedInterceptor.class, <span class="literal">true</span>, <span class="literal">false</span>).values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.initInterceptors方法</p><p>作用：初始化HandlerMapping的adaptedInterceptors属性。<strong>将interceptors属性中的拦截器全部适配到添加到adaptedInterceptors</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void initInterceptors() &#123;</span><br><span class="line">   if (!this.interceptors.isEmpty()) &#123;</span><br><span class="line">      for (int i = 0; i &lt; this.interceptors.size(); i++) &#123;</span><br><span class="line">         Object interceptor = this.interceptors.get(i);</span><br><span class="line">         if (interceptor == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Entry number &quot; + i + &quot; in interceptors array is null&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         this.adaptedInterceptors.add(adaptInterceptor(interceptor));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AbstractHandlerMapping之用"><a href="#AbstractHandlerMapping之用" class="headerlink" title="AbstractHandlerMapping之用"></a>AbstractHandlerMapping之用</h4><p>主要是<strong>getHandler方法</strong>在起作用。getHandler方法就是AbstractHandlerMapping的<strong>底层设计</strong>。</p><p>getHandler方法的实现分为两部分，getHandlerExecutionChain之前是找Handler，getHandlerExecutionChain方法用于添加拦截器。</p><p>1.getHandler方法</p><p><strong>找Handler的过程</strong>：</p><ol><li><strong>通过 getHandlerInternal(request) 方法查找</strong>，这是模板方法，留给子类具体实现（也是子类主要做的事情）。</li><li>如果没有从子类获取到则<strong>使用默认的Handler</strong>。默认的Handler保存在AbstractHandlerMapping的一个Object类型的属性defaultHandler中。</li><li><strong>如果默认Handler为null则方法返回null</strong>。</li><li>如果找到的Handler类型是String，则<strong>从Spring MVC容器里查找相应名字的Bean</strong>。</li></ol><p>对应的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> getHandlerInternal(request);</span><br><span class="line">   <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">      handler = getDefaultHandler();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">   <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String) handler;</span><br><span class="line">      handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">   &#125;</span><br><span class="line">    。。。</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>2.getHandlerExecutionChain方法</p><p>作用：创建HandlerExecutionChain对象，然后将adaptedInterceptors属性中符合要求的拦截器添加进去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerExecutionChain <span class="title function_">getHandlerExecutionChain</span><span class="params">(Object handler, HttpServletRequest request)</span> &#123;</span><br><span class="line">   <span class="comment">//1.创建 HandlerExecutionChain 对象</span></span><br><span class="line">   <span class="type">HandlerExecutionChain</span> <span class="variable">chain</span> <span class="operator">=</span> (handler <span class="keyword">instanceof</span> HandlerExecutionChain ?</span><br><span class="line">         (HandlerExecutionChain) handler : <span class="keyword">new</span> <span class="title class_">HandlerExecutionChain</span>(handler));</span><br><span class="line">   <span class="comment">//2.遍历adaptedInterceptors属性中的拦截器</span></span><br><span class="line">   <span class="keyword">for</span> (HandlerInterceptor interceptor : <span class="built_in">this</span>.adaptedInterceptors) &#123;</span><br><span class="line">      <span class="comment">//3.如果类型为 MappedInterceptor，则判断是否匹配当前请求，匹配则添加到 HandlerExecutionChain 的拦截器中</span></span><br><span class="line">      <span class="keyword">if</span> (interceptor <span class="keyword">instanceof</span> MappedInterceptor) &#123;</span><br><span class="line">         <span class="type">MappedInterceptor</span> <span class="variable">mappedInterceptor</span> <span class="operator">=</span> (MappedInterceptor) interceptor;</span><br><span class="line">         <span class="keyword">if</span> (mappedInterceptor.matches(request)) &#123;   chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//3.如果为其它类型拦截器，则直接添加到 HandlerExecutionChain 的拦截器中</span></span><br><span class="line">         chain.addInterceptor(interceptor);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//4.返回 HandlerExecutionChain 对象</span></span><br><span class="line">   <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2AbstractUrlHandlerMapping系列"><a href="#2-2AbstractUrlHandlerMapping系列" class="headerlink" title="2.2AbstractUrlHandlerMapping系列"></a>2.2AbstractUrlHandlerMapping系列</h3><h4 id="AbstractUrlHandlerMapping"><a href="#AbstractUrlHandlerMapping" class="headerlink" title="AbstractUrlHandlerMapping"></a>AbstractUrlHandlerMapping</h4><p>它是通过请求的url来进行匹配查找处理器执行链的。</p><p>原理：<strong>将url与对应的Handler保存在一个Map中</strong>，在getHandlerInternal方法中使用url从Map中获取Handler，<strong>AbstractUrlHandlerMapping实现了getHandlerInternal方法具体从url中获取Handler的过程，而Map的初始化则交给了子类去完成</strong>。</p><p>AbstractUrlHandlerMapping包含的属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractUrlHandlerMapping</span> <span class="keyword">extends</span> <span class="title class_">AbstractHandlerMapping</span> <span class="keyword">implements</span> <span class="title class_">MatchableHandlerMapping</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> Object rootHandler;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">useTrailingSlashMatch</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">lazyInitHandlers</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; handlerMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;PathPattern, Object&gt; pathPatternHandlerMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>从源码来看，AbstractUrlHandlerMapping即支持直接literal字面量匹配也支持pattern模糊匹配。</p><p><code>PathPattern</code> 和 <code>AntPathMatcher</code> 都支持url的pattern模糊匹配，但<strong>PathPattern更高效且合适</strong>。</p><p>1.getHandlerInternal方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">//1.从请求中获取请求路径（不包括context path和请求参数），以供寻找handler处理器 </span></span><br><span class="line">   <span class="type">String</span> <span class="variable">lookupPath</span> <span class="operator">=</span> initLookupPath(request);</span><br><span class="line">   Object handler;</span><br><span class="line">   <span class="comment">//2.根据Map查找handler </span></span><br><span class="line">   <span class="keyword">if</span> (usesPathPatterns()) &#123;</span><br><span class="line">      <span class="type">RequestPath</span> <span class="variable">path</span> <span class="operator">=</span> ServletRequestPathUtils.getParsedRequestPath(request);</span><br><span class="line">      <span class="comment">//2.根据路径查找handler处理器</span></span><br><span class="line">      handler = lookupHandler(path, lookupPath, request);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//2.根据路径查找handler处理器 </span></span><br><span class="line">      handler = lookupHandler(lookupPath, request);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3.如果未找到handler则尝试使用根路径的handler和默认handler</span></span><br><span class="line">   <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// We need to care for the default handler directly, since we need to</span></span><br><span class="line">      <span class="comment">// expose the PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE for it as well.</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">rawHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.matchesCharacter(lookupPath, <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">         rawHandler = getRootHandler();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (rawHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">         rawHandler = getDefaultHandler();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//4.如果可以使用根handler或者默认handler则 </span></span><br><span class="line">      <span class="keyword">if</span> (rawHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">         <span class="keyword">if</span> (rawHandler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String) rawHandler;</span><br><span class="line">            rawHandler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//4.1校验handler是否适配请求</span></span><br><span class="line">         validateHandler(rawHandler, request);</span><br><span class="line">         <span class="comment">//4.2构建最终的handler返回(设置处理器和拦截器) </span></span><br><span class="line">         handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法逻辑如下：</p><ul><li>调用父类initLookupPath方法。<strong>从请求对象获取解析</strong>（URL解码如：%20）<strong>后的请求路径</strong>，获取的请求路径不包括context path和请求参数</li><li>调用本类lookupHandler方法。<strong>从handlerMap和pathPatternHandlerMap查找处理器</strong>。</li><li>如果从Map中未找到，则<strong>尝试使用根路径和默认的handler</strong>，获取到后要构建成处理器执行链。</li></ul><p>2.initLookupPath方法</p><p>作用：获取真正用于匹配的请求路径，<strong>即不包含context path、不包含请求参数、且被URL解码的路径</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected String initLookupPath(HttpServletRequest request) &#123;</span><br><span class="line">   //1.如果PathPatternParser属性在handlermapping存在，则通过ServletRequestPathUtils进行如下路径获取</span><br><span class="line">   if (usesPathPatterns()) &#123;     request.removeAttribute(UrlPathHelper.PATH_ATTRIBUTE);</span><br><span class="line">      RequestPath requestPath = ServletRequestPathUtils.getParsedRequestPath(request);</span><br><span class="line">      String lookupPath = requestPath.pathWithinApplication().value();</span><br><span class="line">      return UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath);</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">   //2.如果不存在，则通过UrlPathHelper进行路径获取</span><br><span class="line">      return getUrlPathHelper().resolveAndCacheLookupPath(request);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.<strong>lookupHandler方法</strong>（核心方法）</p><p>作用：根据指定的路径查找匹配的handler处理器执行链。</p><p>有两种模式：lookupHandler(path, lookupPath, request)和lookupHandler(lookupPath, request)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractUrlHandlerMapping.java的getHandlerInternal方法部分逻辑</span></span><br><span class="line"><span class="keyword">if</span> (usesPathPatterns()) &#123;</span><br><span class="line">   <span class="type">RequestPath</span> <span class="variable">path</span> <span class="operator">=</span> ServletRequestPathUtils.getParsedRequestPath(request);</span><br><span class="line">   handler = lookupHandler(path, lookupPath, request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">   handler = lookupHandler(lookupPath, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lookupHandler方法用于使用lookupPath从Map中查找Handler，不过很多时候并不能直接通过字面量从Map中get到，因为很多Handler都是用了Pattern的匹配模式，如”/show/article/*”，这时就要进行模糊匹配。</p><p><strong>此外一个lookupHandler还可能跟多个Pattern相匹配</strong>，这时还要<strong>选择其中最优的</strong>，所以查找过程并不是直接从Map中获取。</p><p>先分析简单的模式方法lookupHandler(lookupPath, request)，此方法<strong>使用PathMatcher对lookupPath和pattern进行匹配</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">lookupHandler</span><span class="params">(String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">//1.先直接从 handlerMap 中直接根据路径字面量获取handler,如果获取不到直接返回null,如果获取到直接返回 </span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> getDirectMatch(lookupPath, request);</span><br><span class="line">   <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> handler;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//============获取与lookupPath匹配的所有pattern===========</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//初始化与lookupPath匹配的路径pattern字符串集合（mapkey集合）</span></span><br><span class="line">   List&lt;String&gt; matchingPatterns = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">//2.遍历 handlerMap 的key</span></span><br><span class="line">   <span class="keyword">for</span> (String registeredPattern : <span class="built_in">this</span>.handlerMap.keySet()) &#123;</span><br><span class="line">       <span class="comment">//2.1使用PathMatcher对象来匹配字符串pattern和lookupPath字符串路径</span></span><br><span class="line">      <span class="keyword">if</span> (getPathMatcher().match(registeredPattern, lookupPath)) &#123;</span><br><span class="line">         <span class="comment">//2.2如果匹配则添加到 matchingPatterns 集合中</span></span><br><span class="line">         matchingPatterns.add(registeredPattern);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (useTrailingSlashMatch()) &#123;</span><br><span class="line">         <span class="comment">//2.2否则尝试给 registeredPattern尾部加/再进行匹配，如果匹配则添加到 matchingPatterns 集合中(这里原来的key被加了&quot;/&quot;)</span></span><br><span class="line">         <span class="keyword">if</span> (!registeredPattern.endsWith(<span class="string">&quot;/&quot;</span>) &amp;&amp; getPathMatcher().match(registeredPattern + <span class="string">&quot;/&quot;</span>, lookupPath)) &#123;</span><br><span class="line">            matchingPatterns.add(registeredPattern + <span class="string">&quot;/&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=======从matchingPatterns获取最匹配的pattern==========   </span></span><br><span class="line">   <span class="comment">//初始化一个最匹配的pattern字符串 </span></span><br><span class="line">   <span class="type">String</span> <span class="variable">bestMatch</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">//3.从 PathMatcher获取路径匹配比较器，对matchingPatterns匹配程度进行排序</span></span><br><span class="line">   Comparator&lt;String&gt; patternComparator = getPathMatcher().getPatternComparator(lookupPath);</span><br><span class="line">   <span class="comment">//4.如果 matchingPatterns 非空</span></span><br><span class="line">   <span class="keyword">if</span> (!matchingPatterns.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">//4.1使用匹配比较器进行比较排序 matchingPatterns</span></span><br><span class="line">      matchingPatterns.sort(patternComparator);</span><br><span class="line">      <span class="comment">//4.2取排序最前面的，即匹配程度最高的（注意最高的可能有多个，这里暂时先不处理）</span></span><br><span class="line">      bestMatch = matchingPatterns.get(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//5.如果 bestMatch 非空 </span></span><br><span class="line">   <span class="keyword">if</span> (bestMatch != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//5.1从 handlerMap 取出bestMatch对应的handler</span></span><br><span class="line">      handler = <span class="built_in">this</span>.handlerMap.get(bestMatch);</span><br><span class="line">      <span class="comment">//5.2如果获取不到，则可能是我们前面加了后缀导致 </span></span><br><span class="line">      <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">//5.2.1去掉后缀获取handler </span></span><br><span class="line">         <span class="keyword">if</span> (bestMatch.endsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">            handler = <span class="built_in">this</span>.handlerMap.get(bestMatch.substring(<span class="number">0</span>, bestMatch.length() - <span class="number">1</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//5.2.2如果还获取不到，程序出错兜底报错 </span></span><br><span class="line">         <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                  <span class="string">&quot;Could not find handler for best pattern match [&quot;</span> + bestMatch + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//5.3如果handler是字符串类型，从容器中获取对应的bean</span></span><br><span class="line">      <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String) handler;</span><br><span class="line">         handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//5.4校验handler是否适配此请求 </span></span><br><span class="line">      validateHandler(handler, request);</span><br><span class="line">   <span class="comment">//5.5获取lookupPath与bestMatch动态匹配的部分路径</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">pathWithinMapping</span> <span class="operator">=</span> getPathMatcher().extractPathWithinPattern(bestMatch, lookupPath);</span><br><span class="line">       </span><br><span class="line"><span class="comment">//=============处理最匹配的pattern其实有多个的情况==========</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// There might be multiple &#x27;best patterns&#x27;, let&#x27;s make sure we have the correct URI template variables</span></span><br><span class="line">      <span class="comment">// for all of them</span></span><br><span class="line">      Map&lt;String, String&gt; uriTemplateVariables = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">      <span class="comment">//6. 遍历matchingPatterns集合</span></span><br><span class="line">      <span class="keyword">for</span> (String matchingPattern : matchingPatterns) &#123;</span><br><span class="line">         <span class="comment">//6.1使用匹配比较器，比较pattern的匹配程度是否与bestMatch相等</span></span><br><span class="line">         <span class="keyword">if</span> (patternComparator.compare(bestMatch, matchingPattern) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//使用 PathMatcher 获取pattern对应lookupPath的路径参数UriTemplateVariables的map。key为pattern的变量字符串，value为当前请求对应变量的值</span></span><br><span class="line">            Map&lt;String, String&gt; vars = getPathMatcher().extractUriTemplateVariables(matchingPattern, lookupPath);</span><br><span class="line">            <span class="comment">//url解码变量值，如果未进行解码的话 </span></span><br><span class="line">            Map&lt;String, String&gt; decodedVars = getUrlPathHelper().decodePathVariables(request, vars);</span><br><span class="line">            uriTemplateVariables.putAll(decodedVars);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//7.封装handler为handler处理器执行链</span></span><br><span class="line">      <span class="keyword">return</span> buildPathExposingHandler(handler, bestMatch, pathWithinMapping, uriTemplateVariables);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//8.如果未pattern模糊匹配成功，返回null</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>buildPathExposingHandler</strong>方法用于封装构造handler处理器执行链，用于给查找到的Handler注册两个拦截器PathExposingHandlerInterceptor和UriTemplateVariablesHandlerInterceptor，这是两个内部拦截器，<strong>主要是将匹配的结果保存到请求对象的属性中</strong>。</p><p><strong>PathMatcher接口</strong></p><p>作用：基于字符串的路径匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PathMatcher</span> &#123;</span><br><span class="line">    <span class="comment">//校验字符串是否为pattern</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isPattern</span><span class="params">(String path)</span>;</span><br><span class="line">    <span class="comment">//校验指定path是否匹配指定pattern</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(String pattern, String path)</span>;</span><br><span class="line">    <span class="comment">//校验指定path是否匹配指定pattern的部分开头</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matchStart</span><span class="params">(String pattern, String path)</span>;</span><br><span class="line">    <span class="comment">//提取指定path中与指定pattern动态匹配的部分</span></span><br><span class="line">    String <span class="title function_">extractPathWithinPattern</span><span class="params">(String pattern, String path)</span>;</span><br><span class="line">    <span class="comment">//根据指定path和指定pattern提取路径变量Map对象</span></span><br><span class="line">    Map&lt;String, String&gt; <span class="title function_">extractUriTemplateVariables</span><span class="params">(String pattern, String path)</span>;</span><br><span class="line">    <span class="comment">//获取指定path的Pattern比较器,用于比较Pattern对指定path的匹配程度</span></span><br><span class="line">    Comparator&lt;String&gt; <span class="title function_">getPatternComparator</span><span class="params">(String path)</span>;</span><br><span class="line">    <span class="comment">//结合两个pattern字符串</span></span><br><span class="line">    String <span class="title function_">combine</span><span class="params">(String pattern1, String pattern2)</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>其默认实现类是AntPathMatcher。</p><p><strong>AntPathMatcher</strong>类</p><p>ant风格的路径匹配器</p><p>//TODO源码待解析</p><p>再**分析复杂的模式方法lookupHandler(path, lookupPath, request)**，此方法使用PathPattern进行匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">lookupHandler</span><span class="params">(</span></span><br><span class="line"><span class="params">      RequestPath path, String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//======1.通过字面量匹配直接从handlerMap获取handler==========</span></span><br><span class="line">    </span><br><span class="line">   <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> getDirectMatch(lookupPath, request);</span><br><span class="line">   <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> handler;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======2.通过pattern匹配从pathPatternHandlerMap获取所有匹配的PathPattern====</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//2.1初始化 matches 变量为null</span></span><br><span class="line">   List&lt;PathPattern&gt; matches = <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">//2.2遍历 pathPatternHandlerMap 集合的键</span></span><br><span class="line">   <span class="keyword">for</span> (PathPattern pattern : <span class="built_in">this</span>.pathPatternHandlerMap.keySet()) &#123;</span><br><span class="line">      <span class="comment">//2.3 使用PathPattern来匹配请求路径</span></span><br><span class="line">      <span class="keyword">if</span> (pattern.matches(path.pathWithinApplication())) &#123;</span><br><span class="line">         <span class="comment">//匹配成功，则先视情况初始化 matches集合，再将pattern添加到集合</span></span><br><span class="line">         matches = (matches != <span class="literal">null</span> ? matches : <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">         matches.add(pattern);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.4如果没有匹配的PathPattern，则直接返回null</span></span><br><span class="line">   <span class="keyword">if</span> (matches == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//=====3.从matches匹配的中获取最匹配的PathPattern===========</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//2.5如果有匹配的PathPattern</span></span><br><span class="line">   <span class="keyword">if</span> (matches.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//对 PathPattern 集合进行排序</span></span><br><span class="line">      matches.sort(PathPattern.SPECIFICITY_COMPARATOR);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.6获取首位作为最匹配的 PathPattern </span></span><br><span class="line">   <span class="type">PathPattern</span> <span class="variable">pattern</span> <span class="operator">=</span> matches.get(<span class="number">0</span>);</span><br><span class="line">   <span class="comment">//2.7从pathPatternHandlerMap获取其对应的handler</span></span><br><span class="line">   handler = <span class="built_in">this</span>.pathPatternHandlerMap.get(pattern);</span><br><span class="line">   <span class="comment">//2.8如果 handler为 字符串类型，则从容器中获取handler</span></span><br><span class="line">   <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String) handler;</span><br><span class="line">      handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.9校验handler是否与请求适配 </span></span><br><span class="line">   validateHandler(handler, request);</span><br><span class="line">   <span class="comment">//2.10获取请求路径与pattern动态匹配的部分 </span></span><br><span class="line">   <span class="type">String</span> <span class="variable">pathWithinMapping</span> <span class="operator">=</span> pattern.extractPathWithinPattern(path.pathWithinApplication()).value();</span><br><span class="line">   <span class="comment">//2.11去掉“;”的路径参数 </span></span><br><span class="line">   pathWithinMapping = UrlPathHelper.defaultInstance.removeSemicolonContent(pathWithinMapping);</span><br><span class="line">   <span class="comment">//2.12封装构建handler处理器执行链 </span></span><br><span class="line">   <span class="keyword">return</span> buildPathExposingHandler(handler, pattern.getPatternString(), pathWithinMapping, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.registerHandler方法</p><p>作用：初始化AbstractUrlHandlerMapping的Map类型属性，承担AbstractUrlHandlerMapping的创建工作。</p><p><strong>由子类调用</strong>，这样不同的子类就可以通过注册不同的Handler将组件创建出来。</p><p>registerHandler(String[] urlPaths, String beanName)方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerHandler</span><span class="params">(String[] urlPaths, String beanName)</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   <span class="comment">//遍历传入的urlPaths,委托给registerHandler(urlPath, beanName)进行注册</span></span><br><span class="line">   <span class="keyword">for</span> (String urlPath : urlPaths) &#123;</span><br><span class="line">      registerHandler(urlPath, beanName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerHandler(String urlPath, Object handler)方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerHandler</span><span class="params">(String urlPath, Object handler)</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   Assert.notNull(urlPath, <span class="string">&quot;URL path must not be null&quot;</span>);</span><br><span class="line">   Assert.notNull(handler, <span class="string">&quot;Handler object must not be null&quot;</span>);</span><br><span class="line">   <span class="type">Object</span> <span class="variable">resolvedHandler</span> <span class="operator">=</span> handler;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1.如果handler是String类型，且没有设置lazyInitHandlers,则从容器中获取handler</span></span><br><span class="line">   <span class="keyword">if</span> (!<span class="built_in">this</span>.lazyInitHandlers &amp;&amp; handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String) handler;</span><br><span class="line">      <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> obtainApplicationContext();</span><br><span class="line">      <span class="keyword">if</span> (applicationContext.isSingleton(handlerName)) &#123;</span><br><span class="line">         resolvedHandler = applicationContext.getBean(handlerName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.从 handlerMap 直接获取对应urlPath的处理器</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="built_in">this</span>.handlerMap.get(urlPath);</span><br><span class="line">   <span class="comment">//3.如果已存在对应urlPath的处理器 </span></span><br><span class="line">   <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果已存在的处理器和要注册的处理器不相同，则抛出异常 </span></span><br><span class="line">      <span class="keyword">if</span> (mappedHandler != resolvedHandler) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//3.如果不存在对应urlPath的处理器</span></span><br><span class="line">      <span class="comment">//4.判断urlPath是否为根路径 </span></span><br><span class="line">      <span class="keyword">if</span> (urlPath.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">         <span class="comment">//是根路径则，设置到rootHandler属性 </span></span><br><span class="line">         setRootHandler(resolvedHandler);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//4.判断urlPath是否为/*路径 </span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (urlPath.equals(<span class="string">&quot;/*&quot;</span>)) &#123;</span><br><span class="line">         <span class="comment">//是/*路径，设置到默认 defaultHandler 属性</span></span><br><span class="line">         setDefaultHandler(resolvedHandler);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//4.如果是其它urlPath </span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//4.1将 urlPath和对应的handler 放入handlerMap集合</span></span><br><span class="line">         <span class="built_in">this</span>.handlerMap.put(urlPath, resolvedHandler);</span><br><span class="line">         <span class="comment">//4.2如果使用PathPattern模式，还要放入 pathPatternHandlerMap集合</span></span><br><span class="line">         <span class="keyword">if</span> (getPatternParser() != <span class="literal">null</span>) &#123; </span><br><span class="line"><span class="comment">//这里会使用 PathPatternParser将urlPath解析为PathPattern对象！！！</span></span><br><span class="line">             <span class="built_in">this</span>.pathPatternHandlerMap.put(getPatternParser().parse(urlPath), resolvedHandler);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SimpleUrlHandlerMapping"><a href="#SimpleUrlHandlerMapping" class="headerlink" title="SimpleUrlHandlerMapping"></a>SimpleUrlHandlerMapping</h4><p>是AbstractUrlHandlerMapping的直接实现子类。</p><p>通过重写父类的initApplicationContext方法<strong>在创建组件对象时</strong>调用**registerHandlers(Map&lt;String, Object&gt; urlMap)**方法来完成Handler的注册，方法内部又调用了registerHandler(url, handler)父类方法。</p><p><strong>原理</strong>：通过registerHandlers将urlMap读取出来，然后将key带上/前缀，将value去掉空白符号，然后注册。</p><p>SimpleUrlHandlerMapping类非常简单，就是直接将配置的内容注册到了AbstractUrlHandlerMapping的属性中。</p><h4 id="AbstractDetectingUrlHandlerMapping"><a href="#AbstractDetectingUrlHandlerMapping" class="headerlink" title="AbstractDetectingUrlHandlerMapping"></a>AbstractDetectingUrlHandlerMapping</h4><p>是AbstractUrlHandlerMapping的子抽象类。</p><p>也是通过重写父类的initApplicationContext方法来完成Handler的注册，里面调用了detectHandlers方法。</p><p><strong>原理</strong>：从容器中获取所有的beanName，遍历beanName尝试解析其对应的urls，解析出来非空则执行注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">detectHandlers</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   <span class="comment">//1.获取 ApplicationContext</span></span><br><span class="line">   <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> obtainApplicationContext();</span><br><span class="line">   <span class="comment">//2.从 ApplicationContext 获取所有的beanName </span></span><br><span class="line">   String[] beanNames = (<span class="built_in">this</span>.detectHandlersInAncestorContexts ?</span><br><span class="line">         BeanFactoryUtils.beanNamesForTypeIncludingAncestors(applicationContext, Object.class) :</span><br><span class="line">         applicationContext.getBeanNamesForType(Object.class));</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.遍历所有的beanName</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      <span class="comment">//3.1尝试从beanName解析出 urls</span></span><br><span class="line">      String[] urls = determineUrlsForHandler(beanName);</span><br><span class="line">      <span class="comment">//3.2如果解析出的urls非空，调用父类方法执行注册 </span></span><br><span class="line">      <span class="keyword">if</span> (!ObjectUtils.isEmpty(urls)) &#123;</span><br><span class="line">         <span class="comment">// URL paths found: Let&#x27;s consider it a handler.</span></span><br><span class="line">         registerHandler(urls, beanName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanNameUrlHandlerMapping实现类实现非常简单，检查beanName和alias是不是以”/“开头，如果是<strong>则将beanName和alias做为urls</strong>。</p><h3 id="2-3AbstractHandlerMethodMapping系列"><a href="#2-3AbstractHandlerMethodMapping系列" class="headerlink" title="2.3AbstractHandlerMethodMapping系列"></a>2.3AbstractHandlerMethodMapping系列</h3><p>这个系列是将Method作为Handler来使用的，这也是我们现在<strong>用的最多的一种Handler</strong>，经常使用的@RequestMapping所注释的方法就是这种Handler，它有一个专门的类型<strong>HandlerMethod</strong>。</p><p>它是Request和HandlerMethod的映射Map。</p><h4 id="创建AbstractHandlerMethodMapping系列之器"><a href="#创建AbstractHandlerMethodMapping系列之器" class="headerlink" title="创建AbstractHandlerMethodMapping系列之器"></a>创建AbstractHandlerMethodMapping系列之器</h4><p><strong>泛型T</strong>是用来代表<strong>匹配Handler的条件</strong>专门使用的一种类，这里的条件不仅是url还可以有很多其他条件，如请求类型、请求参数、Header等。</p><p><strong>RequestCondition</strong></p><p>默认泛型使用的是<strong>RequestMappingInfo</strong>。RequestMappingInfo实现了<strong>RequestCondition接口</strong>，此接口<strong>专门用于保存从request提取出的用于匹配Handler的条件</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RequestCondition</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//结合请求条件</span></span><br><span class="line">    T <span class="title function_">combine</span><span class="params">(T other)</span>;</span><br><span class="line">    <span class="comment">//校验请求是否匹配当前条件，然后返回匹配的条件或者null</span></span><br><span class="line">    T <span class="title function_">getMatchingCondition</span><span class="params">(HttpServletRequest request)</span>;</span><br><span class="line">    <span class="comment">//在当前请求下，比较当前请求条件和other请求条件</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T other, HttpServletRequest request)</span>;</span><br></pre></td></tr></table></figure><p><img src="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/image-20240325141917597.png" alt="image-20240325141917597"></p><p><strong>AbstractRequestCondition</strong>中重写了equals、hashCode和toString三个方法，有8个子类，除了CompositeRequestCondition外每一个子类表示一种匹配条件。</p><p>RequestCondition的另一个实现就是这里要用的<strong>RequestMappingInfo</strong>，它里面其实就是用七个属性保存了七个RequestCondition，在匹配时<strong>使用那七个变量进行匹配</strong>，这也就是可以在@RequestMapping中给处理器指定多种匹配方式的原因。</p><p>AbstractHandlerMethodMapping中的核心属性是private final <strong>MappingRegistry</strong> mappingRegistry = new MappingRegistry();即一个映射注册器对象。这个注册器维护了所有的关于HandlerMethod的映射。</p><p>MappingRegistry又封装了三个最重要的Map:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MappingRegistry</span> &#123;</span><br><span class="line"><span class="comment">//1.匹配条件RequestCondition与HandlerMethod的对应关系，当然这里将HandlerMethod封装成MappingRegistration</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;T, MappingRegistration&lt;T&gt;&gt; registry = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//2.uri与匹配条件的对应关系</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MultiValueMap&lt;String, T&gt; pathLookup = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//3.name与HandlerMethod集合的对应关系</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;HandlerMethod&gt;&gt; nameLookup = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>这里的name是使用HandlerMethodMappingNamingStrategy策略的实现类从HandlerMethod中解析出来的，默认使用RequestMappingInfoHandlerMethodMappingNamingStrategy实现类，<strong>解析规则是：类名里的大写字母组合+”#”+方法名</strong>。</p><p>正常匹配过程中无需使用这个Map。</p><p>1.afterPropertiesSet方法</p><p>作用：初始化AbstractHandlerMethodMapping的属性</p><p>AbstractHandlerMethodMapping实现了InitializingBean接口，所以spring容器会自动调用其afterPropertiesSet方法，<strong>afterProperties方法</strong>又交给<strong>initHandlerMethods方法</strong>完成具体的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">   initHandlerMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.initHandlerMethods方法</p><p>作用：从容器中扫描所有的bean，然后根据一定的规则筛选出Handler，然后注册。默认会去除以”scopedTarget.”开头的beanName。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initHandlerMethods</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//1.获取容器中所有的beanName并进行遍历 </span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : getCandidateBeanNames()) &#123;</span><br><span class="line">      <span class="comment">//1.2如果beanName不是以&quot;scopedTarget.&quot;开头 </span></span><br><span class="line">      <span class="keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class="line">         <span class="comment">//进行筛选bean,通知注册HandlerMethod </span></span><br><span class="line">         processCandidateBean(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//2.注册HandlerMethod 之后的后处理,这里默认是日志记录</span></span><br><span class="line">handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.processCandidateBean方法</p><p>作用：校验指定beanName的类型是否为handler，如果是则调用detectHandlerMethods(beanName)方法进行注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processCandidateBean</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">   <span class="comment">//1.获取beanName对应的beanType </span></span><br><span class="line">   Class&lt;?&gt; beanType = <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      beanType = obtainApplicationContext().getType(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.调用isHandler方法校验beanType，校验成功进行注册 </span></span><br><span class="line">   <span class="keyword">if</span> (beanType != <span class="literal">null</span> &amp;&amp; isHandler(beanType)) &#123;</span><br><span class="line">      detectHandlerMethods(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>isHandler方法由子类实现</strong>，即如何筛选容器中的bean由子类实现。</p><p>4.detectHandlerMethods方法（<strong>核心方法</strong>）</p><p>作用：注册。</p><p>通过一系列反射操作，先获取handler的真实类型，再从真实类型中遍历其方法反射对象，并通过getMappingForMethod(method, userType)方法获取请求条件对象，并构造出methods映射集合，最后遍历methods来调用registerHandlerMethod(handler, invocableMethod, mapping)进行注册到map中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">detectHandlerMethods</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">   <span class="comment">//1.获取handler的类型 </span></span><br><span class="line">   Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ?         obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (handlerType != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//2.获取真实的类型，解析动态代理的真实类型 </span></span><br><span class="line">      Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line">      <span class="comment">//3. 使用MethodIntrospector遍历真实类型的中的方法，如果方法是HandlerMethod则添加Method和条件对象的映射到methods集合中</span></span><br><span class="line">      Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">(MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//4.遍历methods集合</span></span><br><span class="line">      methods.forEach((method, mapping) -&gt; &#123;</span><br><span class="line">         <span class="comment">//4.1使用AopUtils获取方法反射对象的真正代理方法反射对象 </span></span><br><span class="line">         <span class="type">Method</span> <span class="variable">invocableMethod</span> <span class="operator">=</span> AopUtils.selectInvocableMethod(method, userType);</span><br><span class="line">         <span class="comment">//4.2调用registerHandlerMethod将方法和请求条件注册到map中</span></span><br><span class="line">         registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法分为两步：</p><ol><li>首先从传入的处理器中找到符合要求的方法，根据getMappingForMethod方法来找。</li><li>然后使用registerHandlerMethod进行注册（也就是保存到Map中）。</li></ol><p>5.RequestMappingHandlerMapping的getMappingForMethods方法</p><p>作用：<strong>通过类上和方法上@RequestMapping注解来创建RequestMappingInfo对象</strong>，并把它们合并返回。</p><p>它是根据@RequstMapping注解来找匹配条件的，如果没有则返回null，如果有则根据注解的内容来创建RequestMappingInfo类型的匹配条件对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RequestMappingHandlerMapping.java</span></span><br><span class="line"><span class="keyword">protected</span> RequestMappingInfo <span class="title function_">getMappingForMethod</span><span class="params">(Method method, Class&lt;?&gt; handlerType)</span> &#123;</span><br><span class="line">   <span class="comment">//1.根据【方法反射对象】创建 RequestMappingInfo</span></span><br><span class="line">   <span class="type">RequestMappingInfo</span> <span class="variable">info</span> <span class="operator">=</span> createRequestMappingInfo(method);</span><br><span class="line">   <span class="keyword">if</span> (info != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//2.根据【类class对象】创建 RequestMappingInfo</span></span><br><span class="line">      <span class="type">RequestMappingInfo</span> <span class="variable">typeInfo</span> <span class="operator">=</span> createRequestMappingInfo(handlerType);</span><br><span class="line">      <span class="comment">//3.如果类级别的注解非空，则组合匹配条件 </span></span><br><span class="line">      <span class="keyword">if</span> (typeInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">         info = typeInfo.combine(info);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//4.从handlermapping对象属性中获取路径前缀 </span></span><br><span class="line">      <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> getPathPrefix(handlerType);</span><br><span class="line">      <span class="comment">//5.如果路径前缀非空，则继续组合匹配条件 </span></span><br><span class="line">      <span class="keyword">if</span> (prefix != <span class="literal">null</span>) &#123;</span><br><span class="line">         info = RequestMappingInfo.paths(prefix).options(<span class="built_in">this</span>.config).build().combine(info);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//6.返回组合好的匹配条件，或者null </span></span><br><span class="line">   <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.RequestMappingHandlerMapping的createRequestMappingInfo方法</p><p>作用：<strong>通过</strong>方法Mthod反射对象或者所属类Class对象上的<strong>注解对象来创建RequestMappingInfo</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RequestMappingInfo <span class="title function_">createRequestMappingInfo</span><span class="params">(AnnotatedElement element)</span> &#123;</span><br><span class="line">   <span class="comment">//1.获取元素（方法或类反射对象）上的注解对象 </span></span><br><span class="line">   <span class="type">RequestMapping</span> <span class="variable">requestMapping</span> <span class="operator">=</span> AnnotatedElementUtils.findMergedAnnotation(element, RequestMapping.class);</span><br><span class="line">   <span class="comment">//2.根据元素对象获取对应的自定义的条件对象，这里默认为null</span></span><br><span class="line">   RequestCondition&lt;?&gt; condition = (element <span class="keyword">instanceof</span> Class ?</span><br><span class="line">         getCustomTypeCondition((Class&lt;?&gt;) element) : getCustomMethodCondition((Method) element));</span><br><span class="line">   <span class="comment">//3.如果注解非空，则根据注解对象真正执行创建 RequestMappingInfo对象</span></span><br><span class="line">   <span class="keyword">return</span> (requestMapping != <span class="literal">null</span> ? createRequestMappingInfo(requestMapping, condition) : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.registerHandlerMethod方法</p><p>作用：注册HandlerMethod相关映射到mappingRegistry属性中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerHandlerMethod</span><span class="params">(Object handler, Method method, T mapping)</span> &#123;</span><br><span class="line">   <span class="comment">//调用 mappingRegistry 属性对象的register方法</span></span><br><span class="line">   <span class="built_in">this</span>.mappingRegistry.register(mapping, handler, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8.MappingRegistry类的register方法</p><p>作用：将请求条件对象、handler的名字、Mthod反射对象转化一下注册到规范的三个Map中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(T mapping, Object handler, Method method)</span> &#123;</span><br><span class="line">   <span class="comment">//1.获取写锁 （此时不允许获取读锁和写锁）</span></span><br><span class="line">   <span class="built_in">this</span>.readWriteLock.writeLock().lock();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//2.调用 createHandlerMethod方法来创建HandlerMethod</span></span><br><span class="line">      <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> createHandlerMethod(handler, method);</span><br><span class="line">      <span class="comment">//3.校验要注册的HanderMethod是否已经注册，如果注册则判断是否矛盾 </span></span><br><span class="line">      validateMethodMapping(handlerMethod, mapping);</span><br><span class="line">  <span class="comment">//4.获取请求条件对象的uri</span></span><br><span class="line">      Set&lt;String&gt; directPaths = AbstractHandlerMethodMapping.<span class="built_in">this</span>.getDirectPaths(mapping);</span><br><span class="line">      <span class="comment">//5.以uri为key，请求条件对象为value添加到 pathLookup 映射【pathLookup初始化】</span></span><br><span class="line">      <span class="keyword">for</span> (String path : directPaths) &#123;</span><br><span class="line">         <span class="built_in">this</span>.pathLookup.add(path, mapping);</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">//6.从handerMethod和mapping中获取name</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (getNamingStrategy() != <span class="literal">null</span>) &#123;</span><br><span class="line">         name = getNamingStrategy().getName(handlerMethod, mapping);</span><br><span class="line">         <span class="comment">//7.以name为key，handlerMethod为value添加到 nameLookup 映射【nameLookup初始化】 </span></span><br><span class="line">         addMappingName(name, handlerMethod);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//8. corsLookup初始化</span></span><br><span class="line">      <span class="type">CorsConfiguration</span> <span class="variable">corsConfig</span> <span class="operator">=</span> initCorsConfiguration(handler, method, mapping);</span><br><span class="line">      <span class="keyword">if</span> (corsConfig != <span class="literal">null</span>) &#123;</span><br><span class="line">         corsConfig.validateAllowCredentials();</span><br><span class="line">         <span class="built_in">this</span>.corsLookup.put(handlerMethod, corsConfig);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//9.以请求条件为key，以以上构建结果封装起来的MappingRegistration为value添加到 registry 映射【registry初始化】</span></span><br><span class="line">      <span class="built_in">this</span>.registry.put(mapping,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">MappingRegistration</span>&lt;&gt;(mapping, handlerMethod, directPaths, name, corsConfig != <span class="literal">null</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//10.释放写锁 </span></span><br><span class="line">      <span class="built_in">this</span>.readWriteLock.writeLock().unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先检查一下<strong>registry</strong>这个Map里是不是已经有这个匹配条件了，如果有而且所对应的值和现在传入的HandlerMethod不是同一个则抛出异常；否则<strong>依次添加到三个Map里</strong>。</p><h4 id="AbstractHandlerMethodMapping系列之用"><a href="#AbstractHandlerMethodMapping系列之用" class="headerlink" title="AbstractHandlerMethodMapping系列之用"></a>AbstractHandlerMethodMapping系列之用</h4><p>1.getHandlerInternal方法</p><p>作用：根据请求对象获取HandlerMethod对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerMethod <span class="title function_">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">//1.从请求对象提取 lookupPath</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">lookupPath</span> <span class="operator">=</span> initLookupPath(request);</span><br><span class="line">   <span class="comment">//2.获取读锁 </span></span><br><span class="line">   <span class="built_in">this</span>.mappingRegistry.acquireReadLock();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//3.根据请求路径查询对应的 HandlerMethod</span></span><br><span class="line">      <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> lookupHandlerMethod(lookupPath, request);</span><br><span class="line">      <span class="comment">//4.返回 </span></span><br><span class="line">      <span class="keyword">return</span> (handlerMethod != <span class="literal">null</span> ? handlerMethod.createWithResolvedBean() : <span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//5.释放读锁 </span></span><br><span class="line">      <span class="built_in">this</span>.mappingRegistry.releaseReadLock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.lookupHandlerMethod方法</p><p>作用：通过lookupPath和请求对象，从mappingRegistry查找对应最匹配的的HandlerMethod返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerMethod <span class="title function_">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//===========获取匹配项matches================    </span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//可能匹配的集合。内部类封装了 MappingRegistry的registry属性的键和值，即封装了请求条件和HandlerMethod</span></span><br><span class="line">   List&lt;Match&gt; matches = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">//1.根据lookupPath从 mappingRegistry的pathLookup属性中查找对应的多个请求条件对象集合</span></span><br><span class="line">   List&lt;T&gt; directPathMatches = <span class="built_in">this</span>.mappingRegistry.getMappingsByDirectPath(lookupPath);</span><br><span class="line">   <span class="comment">//2.如果非空，则遍历所有请求条件创建对应请求的请求条件对象，并创建对应Match将其添加到 matches集合。注意这里的请求条件已经根据请求对象发生了改变。</span></span><br><span class="line">   <span class="keyword">if</span> (directPathMatches != <span class="literal">null</span>) &#123;</span><br><span class="line">      addMatchingMappings(directPathMatches, matches, request);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3.如果matches集合为空，尝试将所有请求条件和handlerMethod的映射添加到matches，会通过请求条件对象的getMatchingCondition方法来校验当前请求是否匹配条件。</span></span><br><span class="line">   <span class="keyword">if</span> (matches.isEmpty()) &#123;</span><br><span class="line">      addMatchingMappings(<span class="built_in">this</span>.mappingRegistry.getRegistrations().keySet(), matches, request);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===============获取最匹配项bestMatch===========    </span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//4. 如果matches集合非空，即有符合的请求条件对象</span></span><br><span class="line">   <span class="keyword">if</span> (!matches.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">//5.对Match进行排序。底层是使用RequstCondition的compareTo方法实现的排序</span></span><br><span class="line">      <span class="type">Match</span> <span class="variable">bestMatch</span> <span class="operator">=</span> matches.get(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (matches.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">         Comparator&lt;Match&gt; comparator = <span class="keyword">new</span> <span class="title class_">MatchComparator</span>(getMappingComparator(request));</span><br><span class="line">         matches.sort(comparator);</span><br><span class="line">         <span class="comment">//6.取排序首位 </span></span><br><span class="line">         bestMatch = matches.get(<span class="number">0</span>);</span><br><span class="line">         <span class="comment">//7.如果是option类型请求返回一个默认的handlerMethod</span></span><br><span class="line">         <span class="keyword">if</span> (CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Match match : matches) &#123;</span><br><span class="line">               <span class="keyword">if</span> (match.hasCorsConfig()) &#123;</span><br><span class="line">                  <span class="keyword">return</span> PREFLIGHT_AMBIGUOUS_MATCH;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//7.如果是其它类型请求，获取第二匹配的匹配条件 </span></span><br><span class="line">            <span class="type">Match</span> <span class="variable">secondBestMatch</span> <span class="operator">=</span> matches.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//如果匹配程度相等，则抛出异常 </span></span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> bestMatch.getHandlerMethod().getMethod();</span><br><span class="line">               <span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> secondBestMatch.getHandlerMethod().getMethod();</span><br><span class="line">               <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                     <span class="string">&quot;Ambiguous handler methods mapped for &#x27;&quot;</span> + uri + <span class="string">&quot;&#x27;: &#123;&quot;</span> + m1 + <span class="string">&quot;, &quot;</span> + m2 + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> <span class="comment">//8.设置请求属性，将请求的handlerMethod设置进去</span></span><br><span class="line">       request.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.getHandlerMethod());</span><br><span class="line">      <span class="comment">//9. 匹配成功后的一些处理</span></span><br><span class="line">      handleMatch(bestMatch.mapping, lookupPath, request);</span><br><span class="line">      <span class="comment">//10.返回最匹配的对应的 HandlerMethod</span></span><br><span class="line">      <span class="keyword">return</span> bestMatch.getHandlerMethod();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">       </span><br><span class="line"><span class="comment">//==================匹配失败===============       </span></span><br><span class="line">       </span><br><span class="line">      <span class="comment">//4.匹配项集合为空，调用 handleNoMatch方法，匹配失败后的一些处理</span></span><br><span class="line">      <span class="keyword">return</span> handleNoMatch(<span class="built_in">this</span>.mappingRegistry.getRegistrations().keySet(), lookupPath, request);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4小结"><a href="#2-4小结" class="headerlink" title="2.4小结"></a>2.4小结</h3><p>HandlerMapping的整体结构在AbstractHandlerMapping中设计，简单来说<strong>其功能就是根据request找到Handler和Interceptors，组合成HandlerExecutionChain类型并返回</strong>。找到Handler的过程通过模板方法getHandlerInternal留给子类实现，<strong>查找Interceptors则是AbstractHandlerMapping自己完成的</strong>。</p><p>//TODO RequestMappingHandlerMapping.java源码待解析</p><h2 id="3-HandlerAdapter"><a href="#3-HandlerAdapter" class="headerlink" title="3.HandlerAdapter"></a>3.HandlerAdapter</h2><p>HandlerAdapter是具体使用Handler来干活的，<strong>每个HandlerAdapter封装了一种Handler的具体使用方法</strong>。</p><p><img src="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/image-20240325220431900.png" alt="image-20240325220431900"></p><p>RequestMappingHandlerAdapter的实现非常复杂，而其它的非常简单，因为其它三个Handler的格式都是固定的，只需要调用固定的方法即可，但是RequestMappingHandlerAdapter所处理的<strong>Handler可以是任意的方法</strong>，没有任何约束，这就极大地增加了难度。</p><h3 id="3-1RequestMappingHandlerAdapter概述"><a href="#3-1RequestMappingHandlerAdapter概述" class="headerlink" title="3.1RequestMappingHandlerAdapter概述"></a>3.1RequestMappingHandlerAdapter概述</h3><p>AbstractHandlerMethodAdapter非常简单，三个接口方法分别调用了自定义的模板方法supportsInternal、handleInternal、getLastModifiedInternal。即<strong>它只支持handler类型为HandlerMethod类型</strong>。</p><blockquote><p>RequestMappingHandlerAdapter是Spring MVC最复杂的组件！！！</p></blockquote><p><strong>核心方法就是handleInternal方法</strong>。这个方法是实际使用Handler处理请求的方法。具体过程大致分为三步：</p><ol><li><strong>准备</strong>好处理器所需要的<strong>参数</strong>。</li><li><strong>使用处理器处理请求</strong>。</li><li><strong>处理返回值</strong>，也就是将不同类型的返回值统一处理成ModelAndView类型。</li></ol><p>这三步里面第2步是最简单的，直接使用反射技术调用处理器执行就可以了，第三步也还算简单，<strong>最麻烦的是第一步</strong>。</p><p>这第一步根据处理器的需要设置参数，而参数类型、个数都是不确定的，所以难度非常大。</p><p>参数具体解析是使用<strong>HandlerMethodArgumentResolver</strong>类型的组件完成的，不同类型的参数使用不同的ArgumentResolver来解析。</p><p><strong>@InitBinder注解</strong></p><p>只用于注解在方法上，有@InitBinder注解的方法用于初始化WebDataBinder，我们可以在其中<strong>做一些WebDataBinder初始化的工作</strong>，如<strong>注册校验器、注册自己的参数编辑器</strong>等。</p><p>可以在Controller中通过以下代码<strong>注册一个转换Date类型的编辑器</strong>，这样就可以将”yyyy-MM-dd”类型的String转换成Date类型。</p><p><img src="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/image-20240326212215593.png" alt="image-20240326212215593"></p><p><strong>@ModelAttribute注解</strong></p><p><strong>@ModelAttribute注解如果用在方法上，则用于设置参数</strong>，它会在执行处理（执行HandlerMethod前）前将参数设置到Model中。</p><p><strong>@ModelAttribute注解如果用在参数上，则表示需要使用</strong>指定的ArgumentResolver来解析参数。</p><p>如果想<strong>让以上两个注解在所有处理器中都起作用</strong>，我们可以定义一个类，然后在类上加@ControllerAdvice注解，并将@InitBinder、@ModelAttribute注释的方法放进去就可以了，这样每个Handler调用前都会调用这些方法。</p><h3 id="3-2RequestMappingHandlerAdapter自身结构"><a href="#3-2RequestMappingHandlerAdapter自身结构" class="headerlink" title="3.2RequestMappingHandlerAdapter自身结构"></a>3.2RequestMappingHandlerAdapter自身结构</h3><p>RequestMappingHandlerAdapter自身的结构并不复杂，不过其中使用了很多组件。所以要准确理解各个组件的作用。</p><h4 id="创建RequestMappingHandlerAdapter之器"><a href="#创建RequestMappingHandlerAdapter之器" class="headerlink" title="创建RequestMappingHandlerAdapter之器"></a>创建RequestMappingHandlerAdapter之器</h4><p>RequestMappingHandlerAdapter的创建在<strong>afterPropertiesSet方法</strong>中实现。</p><p>1.afterPropertiesSet方法</p><p>作用：初始化 RequestMappingHandlerAdapter 的6个属性组件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//1.通过@ContorllerAdvice注解的类初始化属性modelAttributeAdviceCache、initBinderAdviceCache、requestResponseBodyAdvice</span></span><br><span class="line">   initControllerAdviceCache();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.初始化属性 argumentResolvers。用于处理参数</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.argumentResolvers == <span class="literal">null</span>) &#123;</span><br><span class="line">      List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();</span><br><span class="line">      <span class="built_in">this</span>.argumentResolvers = <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>().addResolvers(resolvers);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3.初始化属性 initBinderArgumentResolvers。</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.initBinderArgumentResolvers == <span class="literal">null</span>) &#123;</span><br><span class="line">      List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();</span><br><span class="line">      <span class="built_in">this</span>.initBinderArgumentResolvers = <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>().addResolvers(resolvers);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//4.初始化属性 returnValueHandlers。</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.returnValueHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">      List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();</span><br><span class="line">      <span class="built_in">this</span>.returnValueHandlers = <span class="keyword">new</span> <span class="title class_">HandlerMethodReturnValueHandlerComposite</span>().addHandlers(handlers);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>介绍一下这六个属性：</p><ul><li>argumentResolvers：用于给<strong>处理器方法</strong>和<strong>注解了@ModelAttribute的方法</strong>设置参数。</li><li>initBinderArgumentResolvers：用于给注解了@InitBinder的方法设置参数。</li><li>returnValueHandlers：用于将处理器的返回值处理成ModelAndVieW的类型。</li><li>modelAttributeAdviceCache和initBinderAdviceCache：分别用于缓存@ControllerAdvice注解里面注释了@ModelAttribute和@InitBinder的方法，也就是<strong>全局的@ModelAttribute和@InitBinder的方法</strong>。而每个处理器自己的@ModelAttribute和@InitBinder的方法是在第一次使用处理器处理请求时缓存起来的。</li><li>requestResponseBodyAdvice：用来保存实现了RequestBodyAdvice或者ResponseBodyAdvice接口的类。</li></ul><p>这些属性都是复数形式，也就是可以有多个，在使用的时候是按顺序调用的，所以这些属性初始化时的添加顺序就非常重要了。</p><p>2.initControllerAdviceCache方法</p><p>作用：<strong>从容器中</strong>获取bean来初始化modelAttributeAdviceCache、initBinderAdviceCache和requestResponseBodyAdvice属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initControllerAdviceCache</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (getApplicationContext() == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//1.从容器中获取所有注释了 @ControllerAdvice的bean，并封装成ControllerAdviceBean集合</span></span><br><span class="line">   List&lt;ControllerAdviceBean&gt; adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());</span><br><span class="line"></span><br><span class="line">   List&lt;Object&gt; requestResponseBodyAdviceBeans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.遍历 adviceBeans 集合</span></span><br><span class="line">   <span class="keyword">for</span> (ControllerAdviceBean adviceBean : adviceBeans) &#123;</span><br><span class="line">      <span class="comment">//2.1获取 adviceBean 的类型 beanType</span></span><br><span class="line">      Class&lt;?&gt; beanType = adviceBean.getBeanType();</span><br><span class="line">      <span class="keyword">if</span> (beanType == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unresolvable type for ControllerAdviceBean: &quot;</span> + adviceBean);</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//2.2获取 beanType 中所有的 注解了@ModelAttribute的方法 attrMethods</span></span><br><span class="line">      Set&lt;Method&gt; attrMethods = MethodIntrospector.selectMethods(beanType, MODEL_ATTRIBUTE_METHODS);</span><br><span class="line">      <span class="comment">//2.3向 【modelAttributeAdviceCache 属性】中添加 adviceBean 对 attrMethods 的映射</span></span><br><span class="line">      <span class="keyword">if</span> (!attrMethods.isEmpty()) &#123;</span><br><span class="line">         <span class="built_in">this</span>.modelAttributeAdviceCache.put(adviceBean, attrMethods);</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//2.4获取 beanType 中所有的 注解了@InitBinder的方法 binderMethods</span></span><br><span class="line">      Set&lt;Method&gt; binderMethods = MethodIntrospector.selectMethods(beanType, INIT_BINDER_METHODS);</span><br><span class="line">      <span class="comment">//2.5向 【initBinderAdviceCache 属性】中添加 adviceBean 对 binderMethods 的映射</span></span><br><span class="line">      <span class="keyword">if</span> (!binderMethods.isEmpty()) &#123;</span><br><span class="line">         <span class="built_in">this</span>.initBinderAdviceCache.put(adviceBean, binderMethods);</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//2.6如果beanType是 RequestBodyAdvice 或者 ResponseBodyAdvice，则向 requestResponseBodyAdviceBeans集合 中添加adviceBean</span></span><br><span class="line">      <span class="keyword">if</span> (RequestBodyAdvice.class.isAssignableFrom(beanType) || ResponseBodyAdvice.class.isAssignableFrom(beanType)) &#123;</span><br><span class="line">         requestResponseBodyAdviceBeans.add(adviceBean);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.如果 requestResponseBodyAdviceBeans 集合非空，则向 【requestResponseBodyAdvice 属性】中添加 requestResponseBodyAdviceBeans</span></span><br><span class="line">   <span class="keyword">if</span> (!requestResponseBodyAdviceBeans.isEmpty()) &#123;</span><br><span class="line">      <span class="built_in">this</span>.requestResponseBodyAdvice.addAll(<span class="number">0</span>, requestResponseBodyAdviceBeans);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.getDefualtXXX方法</p><p>作用：<strong>通过new</strong>直接创建组件初始化argumentResolvers、initBinderArgumentResolvers、returnValueHandlers属性。</p><p>参数解析器分为四类：通过注解解析的解析器、通过类型解析的解析器、自定义的解析器和可以解析所有类型的解析器。</p><p><strong>通过定义内置的参数解析器，也相当于定义了方法参数的来源</strong>。</p><h4 id="RequestMappingHandlerAdapter之用"><a href="#RequestMappingHandlerAdapter之用" class="headerlink" title="RequestMappingHandlerAdapter之用"></a>RequestMappingHandlerAdapter之用</h4><p>RequestMappingHandlerAdapter处理请求的<strong>入口方法是handleInternal</strong>。</p><h5 id="1-handleInternal方法"><a href="#1-handleInternal方法" class="headerlink" title="1.handleInternal方法"></a>1.handleInternal方法</h5><p>作用：校验请求、执行请求、添加Cache-Control响应头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">handleInternal</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">      HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">   ModelAndView mav;</span><br><span class="line">   <span class="comment">//1.根据请求对象的类型和session校验请求 （默认情况下校验跳过）</span></span><br><span class="line">   checkRequest(request);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">      <span class="comment">//2.获取请求session对象 </span></span><br><span class="line">      <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(<span class="literal">false</span>);</span><br><span class="line">      <span class="comment">//3.如果session非空 </span></span><br><span class="line">      <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">//3.1获取session对应的锁对象 </span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">mutex</span> <span class="operator">=</span> WebUtils.getSessionMutex(session);</span><br><span class="line">         <span class="comment">//3.2线程获取锁对象，然后调用 invokeHandlerMethod 方法</span></span><br><span class="line">         <span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">            mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// No HttpSession available -&gt; no mutex necessary</span></span><br><span class="line">         <span class="comment">//3.如果session对象为空，则直接调用 invokeHandlerMethod 方法</span></span><br><span class="line">         mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// No synchronization on session demanded at all...</span></span><br><span class="line">      <span class="comment">//2.直接调用 invokeHandlerMethod 方法</span></span><br><span class="line">      mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//4.如果响应头还没有设置Cache-Control,则处理设置相应头 (默认会进入代码块，这里设置Cache-Control响应头控制浏览器响应缓存)【实现逻辑：如果有@SessionAttributes注解则阻止使用缓存，否则什么也不做】</span></span><br><span class="line">   <span class="keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">         <span class="comment">//second = 0，阻止浏览器使用缓存 </span></span><br><span class="line">         applyCacheSeconds(response, <span class="built_in">this</span>.cacheSecondsForSessionAttributeHandlers);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//默认执行 second = -1 ，即什么也不执行</span></span><br><span class="line">         prepareResponse(response);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//5.返回modelandview </span></span><br><span class="line">   <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里真正起作用的代码只有两句，也是两个方法：checkRequest和<strong>invokeHandlerMethod</strong>方法。这个方法通过synchronizeOnSession属性设置是否通过同步session来执行方法。</p><p>如果handlerMethod方法参数中带有注解@SessionAttributes，就会执行applyCacheSeconds(response,0（默认的）)方法，如果没有就会执行prepareResponse(response) -&gt; applyCacheSeconds(response,-1（默认的）)方法。</p><p>applyCacheSeconds会调用applyCacheControl，并根据second不同设置不同的Cache-Control响应头，以控制浏览器对响应的缓存策略。</p><p>RequestMappingHandlerAdapter的cacheSecondsForSessionAttributeHandlers和cacheSeconds属性其实<strong>与服务端的Session超时并没有关系</strong>，而是<strong>用于设置客户端浏览器</strong>response<strong>缓存</strong>相关的Header参数。</p><p><strong>@SessionAttributes注解</strong></p><ul><li><p>设置：在controller类上注解@SessionAttributes()，设置模型Model中要保存到SessionAttribute的属性名和类型，然后在处理器中将参数设置到model中。</p></li><li><p>使用：后续请求直接从Model获取或者@ModelAttribute的参数获取。</p></li></ul><h5 id="2-invokeHandleMethod方法"><a href="#2-invokeHandleMethod方法" class="headerlink" title="2.invokeHandleMethod方法"></a>2.invokeHandleMethod方法</h5><p>这个方法非常重要，它具体执行请求的处理。</p><p>invokeHandlerMethod方法<strong>首先</strong>使用request和response创建了ServletWebRequest类，在<strong>ArgumentResolver解析参数时使用的request就是这个webRequest</strong>。</p><p>接着对WebDataBinderFactory、ModelFactory、ServletInvocableHandlerMethod这三个类型的变量进行了定义和初始化。</p><p><strong>WebDataBinderFactory</strong></p><p>作用：是<strong>用来创建 WebDataBinder</strong> 的，WebDataBinder用于参数绑定，主要功能就是实现参数跟String之间的类型转换。<strong>ArgumentResolver在进行参数解析的过程中会用到WebDataBinder</strong>，另外ModelFactory在更新Model时也会用到它。</p><p><strong>WebDataBinder</strong></p><p>继承自DataBinder类，有三个直接实现类。</p><p><img src="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/image-20240330210602752.png" alt="image-20240330210602752"></p><p>先来看一下DataBinder。它实现了两个接口TypeConverter、PropertyEditorRegistry，即DataBinder和WebDataBinder是一个类型转换器和属性编辑注册器。通过属性编辑注册器接口来注册属性编辑器到DataBinder，再<strong>通过属性编辑器实现类型转换器</strong>（java内置提供了一些属性编辑器来实现string=&gt;目标类型的转换）。</p><p>即DataBinder核心是类型转换器，而类型转换器的核心是属性编辑器。类型转换器提供了方便的高层封装方法。</p><p><img src="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/image-20240330214201233.png" alt="image-20240330214201233"></p><p>类型转换器接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TypeConverter</span> &#123;</span><br><span class="line">    <span class="comment">//1.将value转换为指定requiredType类型</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">convertIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> Object value, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> TypeMismatchException;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.将value转换为指定类型requiredType类型，并提供了参数反射对象的封装MethodParameter对象</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">convertIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> Object value, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> MethodParameter methodParam)</span> <span class="keyword">throws</span> TypeMismatchException;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.将value转换为指定类型requiredType类型，并提供了对象的Field属性反射对象</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">convertIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> Object value, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Field field)</span></span><br><span class="line"><span class="keyword">throws</span> TypeMismatchException;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.将value转换为指定类型requiredType类型，并提供了类型描述对象TypeDescriptor</span></span><br><span class="line">    <span class="keyword">default</span> &lt;T&gt; T <span class="title function_">convertIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> Object value, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> TypeDescriptor typeDescriptor)</span> <span class="keyword">throws</span> TypeMismatchException &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;TypeDescriptor resolution not supported&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性编辑器注册器接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PropertyEditorRegistry</span> &#123;</span><br><span class="line">    <span class="comment">//1.注册针对requiredType类型的属性编辑器</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerCustomEditor</span><span class="params">(Class&lt;?&gt; requiredType, PropertyEditor propertyEditor)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.注册针对requiredType类型和指定属性路径（属性名/嵌套属性名路径）的属性编辑器</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerCustomEditor</span><span class="params">(<span class="meta">@Nullable</span> Class&lt;?&gt; requiredType, <span class="meta">@Nullable</span> String propertyPath, PropertyEditor propertyEditor)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.查找指定类型和指定路径的属性编辑器</span></span><br><span class="line">    PropertyEditor <span class="title function_">findCustomEditor</span><span class="params">(<span class="meta">@Nullable</span> Class&lt;?&gt; requiredType, <span class="meta">@Nullable</span> String propertyPath)</span>;</span><br></pre></td></tr></table></figure><p>DataBinder的作用如下：Binder that allows for setting property values on a target object, including support for validation and binding result analysis.可以<strong>设置对象属性，并进行校验和绑定结果分析</strong>。</p><p>WebDataBinderFactory的创建过程就是将符合条件的注释了@InitBinder的方法找出来，并使用它们创建出ServletRequestDataBinderFactory类型的WebDataBinderFactory。</p><p>1.getDataBinderFactory方法</p><p>作用：使用HandlerMethod创建WebDataBinderFactory</p><p>WebDataBinderFactory的创建过程就是<strong>将符合条件的注释了@InitBinder的方法找出来</strong>，并使用它们创建出<strong>ServletRequestDataBinderFactory</strong>类型的WebDataBinderFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> WebDataBinderFactory <span class="title function_">getDataBinderFactory</span><span class="params">(HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">//1.通过 HandlerMethod 获取方法所在的bean类型，即处理器类型</span></span><br><span class="line">   Class&lt;?&gt; handlerType = handlerMethod.getBeanType();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//=====查找处理器级别的@InitBinder注解的方法============    </span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//2.以处理器类型为key在 initBinderCache 查找方法反射对象集合</span></span><br><span class="line">    Set&lt;Method&gt; methods = <span class="built_in">this</span>.initBinderCache.get(handlerType);</span><br><span class="line">   <span class="comment">//3.如果为空，则进行初始化（方法调用时初始化处理器中的@InitBinder注解的方法，懒加载机制） </span></span><br><span class="line">   <span class="keyword">if</span> (methods == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//使用 MethodIntrospector.selectMethods来查找处理器类型进行初始化</span></span><br><span class="line">      methods = MethodIntrospector.selectMethods(handlerType, INIT_BINDER_METHODS);</span><br><span class="line">      <span class="built_in">this</span>.initBinderCache.put(handlerType, methods);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//4.创建一个 【initBinderMethods 集合】。存储元素类型为InvocableHandlerMethod</span></span><br><span class="line">   List&lt;InvocableHandlerMethod&gt; initBinderMethods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//=====查找全局级别的@InitBinder注解的方法===========    </span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//5.从 initBinderAdviceCache 获取@InitBinder注解的方法，并封装到 initBinderMethods 集合</span></span><br><span class="line"><span class="built_in">this</span>.initBinderAdviceCache.forEach((controllerAdviceBean, methodSet) -&gt; &#123;</span><br><span class="line">      <span class="comment">//5.1如果 controllerAdviceBean 支持该 handlerType</span></span><br><span class="line">      <span class="keyword">if</span> (controllerAdviceBean.isApplicableToBeanType(handlerType)) &#123;</span><br><span class="line">         <span class="comment">//5.2从 controllerAdviceBean 解析出对应的bean对象</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> controllerAdviceBean.resolveBean();</span><br><span class="line">         <span class="comment">//5.3遍历反射方法，封装添加到 initBinderMethods【全局方法添加】</span></span><br><span class="line">         <span class="keyword">for</span> (Method method : methodSet) &#123;</span><br><span class="line">      initBinderMethods.add(createInitBinderMethod(bean, method));</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//======封装处理器级别的@InitBinder注解的方法===========</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//6.遍历处理器级别的 @InitBinder注解的方法反射对象</span></span><br><span class="line">   <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">      <span class="comment">//6.1获取方法所属bean对象/名字 </span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> handlerMethod.getBean();</span><br><span class="line">      <span class="comment">//6.2封装添加到 initBinderMethods【处理器级别方法添加】</span></span><br><span class="line">      initBinderMethods.add(createInitBinderMethod(bean, method));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> createDataBinderFactory(initBinderMethods);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入方法所属bean和方法反射对象，创建InvocableHandlerMethod</span></span><br><span class="line"><span class="comment">//InvocableHandlerMethod 是 HandlerMethod 的子类</span></span><br><span class="line"><span class="keyword">private</span> InvocableHandlerMethod <span class="title function_">createInitBinderMethod</span><span class="params">(Object bean, Method method)</span> &#123;</span><br><span class="line">    <span class="comment">//1.直接new创建InvocableHandlerMethod</span></span><br><span class="line">    <span class="type">InvocableHandlerMethod</span> <span class="variable">binderMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocableHandlerMethod</span>(bean, method);</span><br><span class="line">    <span class="comment">//2.设置binderMethod initBinderArgumentResolvers参数解析器，用于解析@InitBinder注解的方法参数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.initBinderArgumentResolvers != <span class="literal">null</span>) &#123;</span><br><span class="line">        binderMethod.setHandlerMethodArgumentResolvers(<span class="built_in">this</span>.initBinderArgumentResolvers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.设置binderMethod DataBinderFactory，用于参数绑定</span></span><br><span class="line">    binderMethod.setDataBinderFactory(<span class="keyword">new</span> <span class="title class_">DefaultDataBinderFactory</span>(<span class="built_in">this</span>.webBindingInitializer));</span><br><span class="line">    <span class="comment">//4.设置binderMethod 参数名发现器</span></span><br><span class="line">    binderMethod.setParameterNameDiscoverer(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line">    <span class="keyword">return</span> binderMethod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终创建的是 ServletRequestDataBinderFactory 类型的 InitBinderDataBinderFactory</span></span><br><span class="line"><span class="keyword">protected</span> InitBinderDataBinderFactory <span class="title function_">createDataBinderFactory</span><span class="params">(List&lt;InvocableHandlerMethod&gt; binderMethods)</span></span><br><span class="line"><span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServletRequestDataBinderFactory</span>(binderMethods, getWebBindingInitializer());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ModelFactory</strong></p><p>ModelFactory 是用来处理Model的，主要包含两个功能：1.<strong>在处理器具体处理之前对Model进行初始化</strong>，2.<strong>在处理完请求后对Model参数进行更新</strong>。</p><p>对Model初始化具体包括三部分内容：1.将原来的SessionAttributes中的值设置到Model；2.执行相应注释了@ModelAttribute的方法并将其设置到Model;3.处理器中注释了@ModelAttribute的参数如果同时在SessionAttributes也配置了，而且在mavContainer中还没有值则从全部SessionAttributes（可能是其它处理器设置的值）中查找出并设置进去。</p><p>2.getModelFactory方法</p><p>作用：使用HandlerMethod和WebDataBinderFactory创建ModelFactory</p><p>ModelFactory的创建过程就是<strong>将注释了@ModelAttribute却没有注释@RequestMapping的方法找出来</strong>，<strong>并使用它们创建出ModelFactory对象</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ModelFactory <span class="title function_">getModelFactory</span><span class="params">(HandlerMethod handlerMethod, WebDataBinderFactory binderFactory)</span> &#123;</span><br><span class="line">   <span class="comment">//1.从sessionAttributesHandlerCache根据 handlerMethod获取SessionAttributesHandler对象</span></span><br><span class="line">   <span class="type">SessionAttributesHandler</span> <span class="variable">sessionAttrHandler</span> <span class="operator">=</span> getSessionAttributesHandler(handlerMethod);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=========查找处理器级别的@ModelAttribute方法=========== </span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//2.从 handlerMethod获取处理器类型</span></span><br><span class="line">   Class&lt;?&gt; handlerType = handlerMethod.getBeanType();</span><br><span class="line">   <span class="comment">//3.从 modelAttributeCache 根据handlerType获取@ModelAttribute的反射方法</span></span><br><span class="line">    Set&lt;Method&gt; methods = <span class="built_in">this</span>.modelAttributeCache.get(handlerType);</span><br><span class="line">   <span class="comment">//4.若为空，则进行初始化（方法调用时初始化处理器中的@ModelAttribute注解的方法，懒加载机制）</span></span><br><span class="line">   <span class="keyword">if</span> (methods == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//从方法反射对象中获取没有@RequestMapping注解但有@ModelAttribute注解的方法</span></span><br><span class="line">      methods = MethodIntrospector.selectMethods(handlerType, MODEL_ATTRIBUTE_METHODS);</span><br><span class="line">    <span class="comment">//将处理器类型和反射方法映射放入 modelAttributeCache缓存</span></span><br><span class="line">      <span class="built_in">this</span>.modelAttributeCache.put(handlerType, methods);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//5.创建 【InvocableHandlerMethod 的集合】</span></span><br><span class="line">   List&lt;InvocableHandlerMethod&gt; attrMethods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//============处理器全局级别@ModelAttribute方法=========</span></span><br><span class="line">    </span><br><span class="line"> <span class="comment">//6.遍历 modelAttributeAdviceCache</span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">this</span>.modelAttributeAdviceCache.forEach((controllerAdviceBean, methodSet) -&gt; &#123;</span><br><span class="line">      <span class="comment">//6.1如果controllerAdviceBean支持handlerType</span></span><br><span class="line">      <span class="keyword">if</span> (controllerAdviceBean.isApplicableToBeanType(handlerType)) &#123;</span><br><span class="line">         <span class="comment">//6.2获取 controllerAdviceBean 的bean对象</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> controllerAdviceBean.resolveBean();</span><br><span class="line">         <span class="comment">//6.3遍历对应的 methodSet</span></span><br><span class="line">         <span class="keyword">for</span> (Method method : methodSet) &#123;</span><br><span class="line"><span class="comment">//6.4调用createModelAttributeMethod方法创建InvocableHandlerMethod并添加到 attrMethods集合。</span></span><br><span class="line">             attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//============处理处理器级别@ModelAttribute方法===========</span></span><br><span class="line">   <span class="comment">//7.遍历处理器级别的 @ModelAttribute反射方法</span></span><br><span class="line">   <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">      <span class="comment">//7.1获取处理器的bean对象 </span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> handlerMethod.getBean();</span><br><span class="line">     <span class="comment">//7.2调用createModelAttributeMethod方法创建InvocableHandlerMethod并添加到 attrMethods集合。</span></span><br><span class="line">       attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//8.创建 ModelFactory 对象，封装attrMethods、binderFactory、sessionAttrHandler</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelFactory</span>(attrMethods, binderFactory, sessionAttrHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取HandlerMethod对应的SessionAttributesHandler</span></span><br><span class="line"><span class="keyword">private</span> SessionAttributesHandler <span class="title function_">getSessionAttributesHandler</span><span class="params">(HandlerMethod handlerMethod)</span> &#123;</span><br><span class="line">    <span class="comment">//依据HandlerMethod的beanType从sessionAttributesHandlerCache获取，如果获取不到，则new 创建指定type的SessionAttributesHandler</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.sessionAttributesHandlerCache.computeIfAbsent(</span><br><span class="line">            handlerMethod.getBeanType(),</span><br><span class="line">            type -&gt; <span class="keyword">new</span> <span class="title class_">SessionAttributesHandler</span>(type, <span class="built_in">this</span>.sessionAttributeStore));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ServletInvocableHandlerMethod</strong></p><p><strong>非常重要</strong>，它继承自HandlerMethod，并且可以直接执行。<strong>实际请求的处理就是通过它来执行的，参数绑定、处理请求以及返回值处理都在它里边完成</strong>。</p><p>3.createInvocableHandlerMethod方法</p><p>作用：封装HandlerMethod为ServletInvocableHandlerMethod对象，提供执行方法、绑定参数、处理返回值的场所。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ServletInvocableHandlerMethod <span class="title function_">createInvocableHandlerMethod</span><span class="params">(HandlerMethod handlerMethod)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServletInvocableHandlerMethod</span>(handlerMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建三个变量(binderFactory、modelFactory、invocableMethod)后，还有三步（这里省略了异步处理）：<br>1.新建传递参数的ModelAndViewContainer容器，并将相应参数设置到Model中，<br>2.执行请求，<br>3.请求处理完后进行一些后置处理。</p><p><strong>4.invokeHandlerMethod方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">      HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1.使用 request、response封装成ServletWebRequest</span></span><br><span class="line">   <span class="type">ServletWebRequest</span> <span class="variable">webRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//2.使用 handlerMethod 创建 binderFactory 对象（处理@InitBinder注解）</span></span><br><span class="line">      <span class="type">WebDataBinderFactory</span> <span class="variable">binderFactory</span> <span class="operator">=</span> getDataBinderFactory(handlerMethod);</span><br><span class="line">      <span class="comment">//3.使用 handlerMethod、binderFactory创建 ModelFactory（处理@ModelAttribute注解）</span></span><br><span class="line">      <span class="type">ModelFactory</span> <span class="variable">modelFactory</span> <span class="operator">=</span> getModelFactory(handlerMethod, binderFactory);</span><br><span class="line">  <span class="comment">//4.使用 handlerMethod 创建 invocableMethod</span></span><br><span class="line">      <span class="type">ServletInvocableHandlerMethod</span> <span class="variable">invocableMethod</span> <span class="operator">=</span> createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">      <span class="comment">//4.1设置 invocableMethod 的方法参数解析器，将adapter的参数解析器传递给invocableMethod</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.argumentResolvers != <span class="literal">null</span>) &#123;</span><br><span class="line">         invocableMethod.setHandlerMethodArgumentResolvers(<span class="built_in">this</span>.argumentResolvers);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//4.2设置 invocableMethod 的方法返回值处理器</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.returnValueHandlers != <span class="literal">null</span>) &#123;</span><br><span class="line">         invocableMethod.setHandlerMethodReturnValueHandlers(<span class="built_in">this</span>.returnValueHandlers);</span><br><span class="line">      &#125;</span><br><span class="line"> <span class="comment">//4.3设置 invocableMethod 的参数绑定工厂</span></span><br><span class="line">      invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line"> <span class="comment">//4.4设置 invocableMethod 的参数名发现器</span></span><br><span class="line">       invocableMethod.setParameterNameDiscoverer(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//5.创建  ModelAndViewContainer 对象</span></span><br><span class="line">      <span class="type">ModelAndViewContainer</span> <span class="variable">mavContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndViewContainer</span>();</span><br><span class="line">     <span class="comment">//6.将request请求中inputfalshmap的重定向传递属性添加到mavContainer</span></span><br><span class="line">       mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">      <span class="comment">//7. 使用modelFactory初始化mavContainer中的model</span></span><br><span class="line">      modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">     <span class="comment">//8.设置mavContainer属性ignoreDefaultModelOnRedirect</span></span><br><span class="line">       mavContainer.setIgnoreDefaultModelOnRedirect(<span class="built_in">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line">  <span class="comment">//9.异步处理</span></span><br><span class="line">      <span class="type">AsyncWebRequest</span> <span class="variable">asyncWebRequest</span> <span class="operator">=</span> WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">      asyncWebRequest.setTimeout(<span class="built_in">this</span>.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">      <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">      asyncManager.setTaskExecutor(<span class="built_in">this</span>.taskExecutor);</span><br><span class="line">      asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">      asyncManager.registerCallableInterceptors(<span class="built_in">this</span>.callableInterceptors);</span><br><span class="line">      asyncManager.registerDeferredResultInterceptors(<span class="built_in">this</span>.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">         <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> asyncManager.getConcurrentResult();</span><br><span class="line">         mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">         asyncManager.clearConcurrentResult();</span><br><span class="line">         LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">formatted</span> <span class="operator">=</span> LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Resume with async result [&quot;</span> + formatted + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">         &#125;);</span><br><span class="line">         invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//10.使用 invocableMethod 调用invokeAndHandle方法真正调用处理器方法</span></span><br><span class="line">      invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">      <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//11.方法调用后处理，返回ModelAndView</span></span><br><span class="line">      <span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      webRequest.requestCompleted();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.getModelAndView方法</p><p>作用：使用ModelAndViewContainer、ModelFactory、NativeWebRequest创建ModelAndView对象，对请求调用进行后处理</p><p>1.调用ModelFactory的updateModel方法更新Model<br>2.根据mavContainer创建MdoelAndView<br>3.如果mavContainer里的model是RedirectAttributes类型，将其设置到FlashMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ModelAndView <span class="title function_">getModelAndView</span><span class="params">(ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">      ModelFactory modelFactory, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">//1.使用modelFactory来更新mavContainer中的Model（包括更新Model对应的SessionAttributes和Model设置BindingResult）</span></span><br><span class="line">   modelFactory.updateModel(webRequest, mavContainer);</span><br><span class="line">   <span class="comment">//2.使用mavContainer来判断请求是否已经被处理，已被处理则直接返回null</span></span><br><span class="line">   <span class="keyword">if</span> (mavContainer.isRequestHandled()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3.从 mavContainer 获取model</span></span><br><span class="line">   <span class="type">ModelMap</span> <span class="variable">model</span> <span class="operator">=</span> mavContainer.getModel();</span><br><span class="line">   <span class="comment">//4.依据mavContainer的视图名称、model模型内容、状态创建ModelAndView对象</span></span><br><span class="line">   <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(mavContainer.getViewName(), model, mavContainer.getStatus());</span><br><span class="line">   <span class="comment">//5.如果 mavContainer的view属性不是字符串，则直接设置到mav的view属性中</span></span><br><span class="line">   <span class="keyword">if</span> (!mavContainer.isViewReference()) &#123;</span><br><span class="line">      mav.setView((View) mavContainer.getView());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//6.如果 mavContainer 中的model是RedirectAttributes类型，则获取model中的flashAttributes，并设置到请求属性中。(只有返回redirct视图时此块代码才会调用)</span></span><br><span class="line">   <span class="keyword">if</span> (model <span class="keyword">instanceof</span> RedirectAttributes) &#123;</span><br><span class="line">      Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();</span><br><span class="line">      <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">      <span class="keyword">if</span> (request != <span class="literal">null</span>) &#123;</span><br><span class="line">         RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//7.返回创建的mav </span></span><br><span class="line">   <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<strong>model只有处理器在返回redirect类型的视图才可能是RedirectAttributes类型</strong>，否则不会是RedirectAttributes类型，也就是说在不返回redirect类型视图的处理器中即使使用RedirectAttributes设置了变量也不会保存到FlashMap中。</p><h3 id="3-3ModelAndViewContainer"><a href="#3-3ModelAndViewContainer" class="headerlink" title="3.3ModelAndViewContainer"></a>3.3ModelAndViewContainer</h3><p>在 RequestMappingHandlerAdapter 的 invokeHandlerMethod方法 中创建并使用。</p><p>ModelAndViewContainer承担着整个请求过程中数据的传递工作。</p><ul><li>在处理器中使用了 Model 或者 ModelMap 时<strong>ArgumentResolver会传入defaultModel</strong>，它是BindingAwareModelMap类型，既继承了ModelMap又实现了Model接口，所以Model或者ModelMap其实使用的是同一个对象。</li><li>处理器中RedirectAttributes类型的参数<strong>ArgumentResolver会传入redirectModel</strong>，它实际上是RedirectAttributesModelMap类型。</li></ul><p><strong>getModel方法</strong>返回redirectModel的情况下，在处理器中设置到Model的参数就不会被mav使用了（设置SessionAttributes除外）。</p><p><strong>getModel方法</strong>返回defaultModel，设置到RedirectAttributes中的参数也将丢弃，也就是说在返回的view不是redirect类型时，即使处理器使用RedirectAttributes参数设置了值也不会传递到下一个请求。</p><p>只有将参数设置到Model或者ModelMap里才能使用SessionAttributes缓存，设置到RedirectAttributes里的参数不行。</p><h3 id="3-4SessionAttributesHandler和SessionAttributeStore"><a href="#3-4SessionAttributesHandler和SessionAttributeStore" class="headerlink" title="3.4SessionAttributesHandler和SessionAttributeStore"></a>3.4SessionAttributesHandler和SessionAttributeStore</h3><p>在 RequestMappingHandlerAdapter 的 getModelFactory方法中创建并缓存到其属性<strong>sessionAttributesHandlerCache</strong>中，<strong>每个controller对应一个自己的SessionAttributesHandler</strong>。且每个SessionAttributesHandler都封装了其属性sessionAttributeStore。</p><p>SessionAttributesHandler用来处理@SessionAttributes注解的参数，来创建SessionAttributesHandler对象。</p><p><strong>SessionAttributesHandler的具体存储工作是交给SessionAttributeStore去做的</strong>，而且使用的统一为 RequestMappingHandlerAdapter 的SessionAttributeStore。SessionAttributeStore并不是保存数据的容器，而是保存数据的工具，具体保存数据的容器使用的是Session。</p><p>SessionAttributeHandler是在ModelFactory中使用的。</p><h3 id="3-5ModelFactory"><a href="#3-5ModelFactory" class="headerlink" title="3.5ModelFactory"></a>3.5ModelFactory</h3><p>是用来维护Model的，具体包含两个功能：1.初始化Model,2.处理器执行后将Model中相应的参数更新到SessionAttributes中。</p><h4 id="初始化Model"><a href="#初始化Model" class="headerlink" title="初始化Model"></a>初始化Model</h4><p>主要是在处理器执行前将相应数据设置到Model中，是通过调用initModel方法完成的。</p><p><strong>initModel方法</strong></p><p>1.从sessionAttributes中取出保存的参数，并合并到mavContainer的Model中<br>2.执行注解了@ModelAttribute的方法并将结果设置到mavContainer的Model中<br>3.判断既注解了@ModelAttribute又在@SessionAttributes注解中（参数名或者参数类型在注解中设置了）的参数是否已经设置到mavContainer的Model中，如果没有则使用sessionAttributesHandler从sessionAttributeStore中获取并设置到mavContainer中。</p><p>第三步跟第一步的区别是<strong>第一步</strong>是将当前处理器保存的所有SessionAttributes属性合并到了mavContainer，而<strong>第三步</strong>可以使用其它处理器中保存的SessionAttributes属性来设置注解了@ModelAttribute的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initModel</span><span class="params">(NativeWebRequest request, ModelAndViewContainer container, HandlerMethod handlerMethod)</span></span><br><span class="line">      <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1.从sessionAttributes中获取已经保存的参数，并保存到mavContainer中</span></span><br><span class="line">   Map&lt;String, ?&gt; sessionAttributes = <span class="built_in">this</span>.sessionAttributesHandler.retrieveAttributes(request);</span><br><span class="line">   container.mergeAttributes(sessionAttributes);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//2.执行注解了@ModelAttribute的方法并将结果设置到mavContainer的Model中</span></span><br><span class="line">   invokeModelAttributeMethods(request, container);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.遍历既注解了@ModelAttribute又在@SessionAttributes注解中出现的方法参数</span></span><br><span class="line">   <span class="keyword">for</span> (String name : findSessionAttributeArguments(handlerMethod)) &#123;</span><br><span class="line">      <span class="comment">//如果当前Model中没有此参数 </span></span><br><span class="line">      <span class="keyword">if</span> (!container.containsAttribute(name)) &#123;</span><br><span class="line">         <span class="comment">//3.1从sessionAttributes获取参数值 </span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.sessionAttributesHandler.retrieveAttribute(request, name);</span><br><span class="line">         <span class="comment">//3.2如果获取不到，则抛出异常 </span></span><br><span class="line">         <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HttpSessionRequiredException</span>(<span class="string">&quot;Expected session attribute &#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&quot;</span>, name);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//3.2获取到则添加到Model中 </span></span><br><span class="line">         container.addAttribute(name, value);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>invokeModelAttributeMethods方法</strong></p><p>作用：遍历的方式执行注解了@ModelAttribute的方法并将结果设置到mavContainer的Model中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeModelAttributeMethods</span><span class="params">(NativeWebRequest request, ModelAndViewContainer container)</span></span><br><span class="line">      <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//如果 modelMethods 属性非空</span></span><br><span class="line">   <span class="keyword">while</span> (!<span class="built_in">this</span>.modelMethods.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">//1.获取下一个注释了@ModelAttribute注解的方法 </span></span><br><span class="line">      <span class="type">InvocableHandlerMethod</span> <span class="variable">modelMethod</span> <span class="operator">=</span> getNextModelMethod(container).getHandlerMethod();</span><br><span class="line">      <span class="comment">//2.获取方法上的@ModelAttribute注解对象</span></span><br><span class="line">      <span class="type">ModelAttribute</span> <span class="variable">ann</span> <span class="operator">=</span> modelMethod.getMethodAnnotation(ModelAttribute.class);</span><br><span class="line">      <span class="comment">//3.如果@ModelAttribute注解设置了name且mavContainer中存在此参数则直接跳过后续处理</span></span><br><span class="line">      <span class="keyword">if</span> (container.containsAttribute(ann.name())) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!ann.binding()) &#123;</span><br><span class="line">            container.setBindingDisabled(ann.name());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.【执行@ModelAttribute注解的方法】</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> modelMethod.invokeForRequest(request, container);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//5.如果@ModelAttribute注解的方法返回类型为void，跳过后续处理（因为在执行方法时就设置好了Model）</span></span><br><span class="line">      <span class="keyword">if</span> (modelMethod.isVoid()) &#123;</span><br><span class="line">         <span class="comment">//如果 @ModelAttribute注解设置了value值，此时无效，因为没有返回值用于设置值</span></span><br><span class="line">         <span class="keyword">if</span> (StringUtils.hasText(ann.value())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">               logger.debug(<span class="string">&quot;Name in @ModelAttribute is ignored because method returns void: &quot;</span> +</span><br><span class="line">                     modelMethod.getShortLogMessage());</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//跳过后续处理 </span></span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//6.调用 getNameForReturnValue方法获取参数名</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">returnValueName</span> <span class="operator">=</span> getNameForReturnValue(returnValue, modelMethod.getReturnType());</span><br><span class="line">      <span class="comment">//获取@ModelAttribute注解的binding设置，来设置是否允许绑定此参数</span></span><br><span class="line">      <span class="keyword">if</span> (!ann.binding()) &#123;</span><br><span class="line">         container.setBindingDisabled(returnValueName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//7.如果mavContainer中没有此属性，则添加到mavContainer中</span></span><br><span class="line">      <span class="keyword">if</span> (!container.containsAttribute(returnValueName)) &#123;</span><br><span class="line">         container.addAttribute(returnValueName, returnValue);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>getNameForReturnValue方法</strong></p><p>作用：根据方法返回值和返回类型/@ModelAttribute注解获取Model的参数名，<strong>此方法主要实现基于@ModelAttribute注解获取Model的参数名</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getNameForReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType)</span> &#123;</span><br><span class="line">   <span class="comment">//1.根据返回类型对象获取方法注解@ModelAttribute</span></span><br><span class="line">   <span class="type">ModelAttribute</span> <span class="variable">ann</span> <span class="operator">=</span> returnType.getMethodAnnotation(ModelAttribute.class);</span><br><span class="line">   <span class="comment">//2.如果注解非空且注解中设置了 value，则直接返回value值</span></span><br><span class="line">   <span class="keyword">if</span> (ann != <span class="literal">null</span> &amp;&amp; StringUtils.hasText(ann.value())) &#123;</span><br><span class="line">      <span class="keyword">return</span> ann.value();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//2.如果注解中没有设置 value，则根据方法类型获取参数名</span></span><br><span class="line">      <span class="comment">//获取方法反射对象 </span></span><br><span class="line">      <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> returnType.getMethod();</span><br><span class="line">      <span class="comment">//获取此方法所在的类class对象</span></span><br><span class="line">      Class&lt;?&gt; containingClass = returnType.getContainingClass();</span><br><span class="line">      <span class="comment">//解析方法真实的返回类型class对象 </span></span><br><span class="line">      Class&lt;?&gt; resolvedType = GenericTypeResolver.resolveReturnType(method, containingClass);</span><br><span class="line">      <span class="comment">//调用Conventions.getVariableNameForReturnType方法根据方法返回类型获取参数名</span></span><br><span class="line">      <span class="keyword">return</span> Conventions.getVariableNameForReturnType(method, resolvedType, returnValue);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Conventions.getVariableNameForReturnType方法</strong></p><p>作用：根据方法<strong>返回类型</strong>和<strong>返回值</strong>获取参数名称。1.如果方法返回类型为Object，则<strong>基于返回值获取参数名称</strong>2.如果方法返回类型非Object则<strong>基于返回类型获取参数名称</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Conventions.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getVariableNameForReturnType</span><span class="params">(Method method, Class&lt;?&gt; resolvedType, <span class="meta">@Nullable</span> Object value)</span> &#123;</span><br><span class="line">   <span class="comment">//1.如果方法返回类型为Object</span></span><br><span class="line">   <span class="keyword">if</span> (Object.class == resolvedType) &#123;</span><br><span class="line">      <span class="comment">//如果方法返回值为null，则抛出异常 </span></span><br><span class="line">      <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">               <span class="string">&quot;Cannot generate variable name for an Object return type with null value&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//调用getVariableName方法，根据返回值获取参数名，即根据返回值的真实类型获取参数名</span></span><br><span class="line">      <span class="keyword">return</span> getVariableName(value);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1.如果方法返回类型非Object类型 </span></span><br><span class="line">   Class&lt;?&gt; valueClass;</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">pluralize</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">reactiveSuffix</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//2.如果方法返回类型为数组类型 </span></span><br><span class="line">   <span class="keyword">if</span> (resolvedType.isArray()) &#123;</span><br><span class="line">      <span class="comment">//获取数组的元素类型 </span></span><br><span class="line">      valueClass = resolvedType.getComponentType();</span><br><span class="line">      <span class="comment">//标记复数形式命名 </span></span><br><span class="line">      pluralize = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (Collection.class.isAssignableFrom(resolvedType)) &#123;</span><br><span class="line">   <span class="comment">//2.如果方法返回类型为Collection集合类型</span></span><br><span class="line">      <span class="comment">//获取集合元素的类型 </span></span><br><span class="line">      valueClass = ResolvableType.forMethodReturnType(method).asCollection().resolveGeneric();</span><br><span class="line">      <span class="keyword">if</span> (valueClass == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!(value <span class="keyword">instanceof</span> Collection)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot generate variable name &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;for non-typed Collection return type and a non-Collection value&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         Collection&lt;?&gt; collection = (Collection&lt;?&gt;) value;</span><br><span class="line">         <span class="keyword">if</span> (collection.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot generate variable name &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;for non-typed Collection return type and an empty Collection value&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="type">Object</span> <span class="variable">valueToCheck</span> <span class="operator">=</span> peekAhead(collection);</span><br><span class="line">         valueClass = getClassForValue(valueToCheck);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//标记复数命名 </span></span><br><span class="line">      pluralize = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//2.其它类型，则直接使用resolvedType方法返回类型 </span></span><br><span class="line">      valueClass = resolvedType;</span><br><span class="line">      <span class="comment">//获取响应式编程的适配器 </span></span><br><span class="line">      <span class="type">ReactiveAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> ReactiveAdapterRegistry.getSharedInstance().getAdapter(valueClass);</span><br><span class="line">      <span class="comment">//获取响应式编程返回值对应的后缀参数名 </span></span><br><span class="line">      <span class="keyword">if</span> (adapter != <span class="literal">null</span> &amp;&amp; !adapter.getDescriptor().isNoValue()) &#123;</span><br><span class="line">         reactiveSuffix = ClassUtils.getShortName(valueClass);</span><br><span class="line">         valueClass = ResolvableType.forMethodReturnType(method).getGeneric().toClass();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.根据方法返回类型class获取简短的参数名称</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ClassUtils.getShortNameAsProperty(valueClass);</span><br><span class="line">   <span class="comment">//4.添加复数后缀List或者响应式后缀 </span></span><br><span class="line">   <span class="keyword">return</span> (pluralize ? pluralize(name) : name + reactiveSuffix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/image-20240412213031924.png" alt="image-20240412213031924"></p><h4 id="更新Model"><a href="#更新Model" class="headerlink" title="更新Model"></a>更新Model</h4><p><strong>updateModel方法</strong></p><p>作用：1.将当前DefaultModel同步到SessionAttributes中，2.如果需要渲染页面，则给Model中相应参数设置BindingResult。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateModel</span><span class="params">(NativeWebRequest request, ModelAndViewContainer container)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">//1.从mavContainer获取defaultModel对象</span></span><br><span class="line">   <span class="type">ModelMap</span> <span class="variable">defaultModel</span> <span class="operator">=</span> container.getDefaultModel();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//2.如果SessionStatus#setComplete在处理器方法中调用了，则清空sessionAttributes</span></span><br><span class="line">   <span class="keyword">if</span> (container.getSessionStatus().isComplete())&#123;</span><br><span class="line">      <span class="built_in">this</span>.sessionAttributesHandler.cleanupAttributes(request);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">//2.没有调用SessionStatus#setComplete，则将defaultModel同步到sessionAttributes</span></span><br><span class="line">       <span class="built_in">this</span>.sessionAttributesHandler.storeAttributes(request, defaultModel);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//3. 更新BindingResult，即向defaultModel中添加BindingResult的相关参数（这里并没有校验的错误值）</span></span><br><span class="line">   <span class="keyword">if</span> (!container.isRequestHandled() &amp;&amp; container.getModel() == defaultModel) &#123;</span><br><span class="line">      updateBindingResult(request, defaultModel);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在处理器中绑定参数时<strong>如果参数注释了@Valid或者@Validated</strong>，则<strong>会将校验结果设置到跟其相邻的下一个Error或者BindingResult类型的参数中</strong>。</p><p>updateModel一共做了两件事，第一件事是维护SessionAttributes的数据，第二件是给Model中需要的参数设置BindingResult，以备视图使用。</p><h3 id="3-6ServletInvocableHandlerMethod"><a href="#3-6ServletInvocableHandlerMethod" class="headerlink" title="3.6ServletInvocableHandlerMethod"></a>3.6ServletInvocableHandlerMethod</h3><p><img src="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/image-20240412224139418.png" alt="image-20240412224139418"></p><p>ServletInvocableHandlerMethod也是一种HandlerMethod，只是<strong>增加了方法执行的功能</strong>，当然也相应的增加了<strong>参数解析、返回值处理等相关功能</strong>。</p><p>本节从HandlerMethod开始依次对这三个组件进行分析。</p><h4 id="3-6-1HandlerMethod"><a href="#3-6-1HandlerMethod" class="headerlink" title="3.6.1HandlerMethod"></a>3.6.1HandlerMethod</h4><p><strong>用于封装Handler和其中具体处理请求的Method</strong>，分别对应其中的<strong>bean和method属性</strong>。</p><p>如果Handler是String类型，将其变为容器中对应bean的过程在专门的方法createWithResolvedBean中来操作的。</p><p>HandlerMethod中属性的含义除了<strong>bridgedMethod</strong>外都比较容易理解，只是保存参数的属性parameters使用了可能不太熟悉的类型<strong>MethodParameter</strong>。</p><p><strong>MethodParameter</strong>里最重要的是method和parameterIndex，有了这两个参数后参数类型、注释等都可以获取到。不过在正常的反射技术里是不知道参数名的，所以这里专门使用了一个<strong>参数名查找的组件 parameterNameDiscoverer</strong>。</p><p>在 HandlerMethod 中定义了两个内部类来封装参数，一个封装方法调用的参数<strong>HandlerMethodParameter</strong>，一个封装方法返回的参数<strong>ReturnValueMethodParameter</strong>。</p><p>两个类都是MethodParameter的子类，而且ReturnValueMethodParameter还是HandlerMethodParameter的子类，其parameterIndex默认为-1。<strong>它们主要使用method和parameterIndex来创建MethodParamter，且它们使用的method都是bridgedMethod</strong>。</p><p><strong>bridge method(桥方法)</strong></p><p>桥方法作为一个桥将Object为参数的调用转换到了调用String为参数的方法。</p><p>在HandlerMethod中的bridgedMethod指的是被桥的方法（注意是bridged而不是bridge），也就是原来的方法。如果不涉及泛型bridgedMethod和method都是同一个方法。</p><h4 id="3-6-2InvocableHandlerMethod"><a href="#3-6-2InvocableHandlerMethod" class="headerlink" title="3.6.2InvocableHandlerMethod"></a>3.6.2InvocableHandlerMethod</h4><p>继承自HandlerMethod，在父类的基础上<strong>添加了调用的功能</strong>（核心），也就是说，InvocableHandlerMethod可以直接调用内部属性method对应的方法（严格来说应该是bridgedMethod）。</p><p>方法调用是基于<strong>从http请求中解析出来的参数</strong>，和<strong>HandlerMethod中封装的method和bean来通过反射调用的</strong>。</p><p>里面有三个属性：</p><ul><li>dataBinderFactory：WebDataBinderFactory类型，可以创建WebDataBInder，用于参数解析器ArgumentResolver中。</li><li>resolvers：HandlerMethodArgumentResolverComposite类型，用于解析参数。</li><li>parameterNameDiscoverer：ParameterNameDiscoverer类型，用来获取参数名，用于MethodParameter中。（注意是在放法调用时解析参数时才将parameterNameDiscoverer从InvocableHandlerMethod设置到MethodParameter对象中）</li></ul><p><strong>1.核心调用方法为invokeForRequest</strong></p><p>作用：getMethodArgumentValues解析方法参数（底层还是使用方法参数解析器组件解析），doInvoke调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invokeForRequest</span><span class="params">(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">      Object... providedArgs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">//1.根据请求、mavContainer获取方法参数【难理解】</span></span><br><span class="line">   Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Arguments: &quot;</span> + Arrays.toString(args));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.调用方法【核心】 </span></span><br><span class="line">   <span class="keyword">return</span> doInvoke(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.doInvoke方法</strong></p><p>作用：使用传入的方法参数执行handlermethod封装的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doInvoke</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">//1.调用父类的getBridgedMethod方法获取原始方法反射对象</span></span><br><span class="line">   <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> getBridgedMethod();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (KotlinDetector.isSuspendingFunction(method)) &#123;</span><br><span class="line">         <span class="keyword">return</span> CoroutinesUtils.invokeSuspendingFunction(method, getBean(), args);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//2.反射执行handlermethod封装的方法【核心】</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(getBean(), args);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">      <span class="comment">//非法参数异常处理 </span></span><br><span class="line">      assertTargetBean(method, getBean(), args);</span><br><span class="line">      <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> (ex.getMessage() != <span class="literal">null</span> ? ex.getMessage() : <span class="string">&quot;Illegal argument&quot;</span>);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(formatInvokeError(text, args), ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">      <span class="comment">//方法调用异常处理 </span></span><br><span class="line">      <span class="comment">// Unwrap for HandlerExceptionResolvers ...</span></span><br><span class="line">      <span class="type">Throwable</span> <span class="variable">targetException</span> <span class="operator">=</span> ex.getTargetException();</span><br><span class="line">      <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (RuntimeException) targetException;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (Error) targetException;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (Exception) targetException;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(formatInvokeError(<span class="string">&quot;Invocation failure&quot;</span>, args), targetException);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.getMethodArgumentValues</strong>（重要）</p><p>作用：使用请求、mavContainer、providedArgs（一般没有）获取方法参数数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] getMethodArgumentValues(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span><br><span class="line">      Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">//1.获取方法参数数组（封装了方法反射对象和参数索引）</span></span><br><span class="line">   MethodParameter[] parameters = getMethodParameters();</span><br><span class="line">   <span class="comment">//2.判断如果参数为空则直接返回空数组</span></span><br><span class="line">   <span class="keyword">if</span> (ObjectUtils.isEmpty(parameters)) &#123;</span><br><span class="line">      <span class="keyword">return</span> EMPTY_ARGS;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3.构建一个【参数值数组】，大小与parameters相同</span></span><br><span class="line">   Object[] args = <span class="keyword">new</span> <span class="title class_">Object</span>[parameters.length];</span><br><span class="line">   <span class="comment">//4.遍历来初始化参数值数组元素</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">      <span class="comment">//4.1获取当前索引的方法参数MethodParameter</span></span><br><span class="line">      <span class="type">MethodParameter</span> <span class="variable">parameter</span> <span class="operator">=</span> parameters[i];</span><br><span class="line">      <span class="comment">//4.2将参数名解析器从InvocableHandlerMethod设置到 MethodParameter 中</span></span><br><span class="line">      parameter.initParameterNameDiscovery(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line">      <span class="comment">//4.3如果相应类型的参数已经在providedArgs提供，则直接设置到【参数值数组】args，且直接继续设置下一个方法参数</span></span><br><span class="line">      args[i] = findProvidedArgument(parameter, providedArgs);</span><br><span class="line">      <span class="keyword">if</span> (args[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//4.4校验参数解析器是否支持当前参数，如果不支持则抛出异常</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.resolvers.supportsParameter(parameter)) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(formatArgumentError(parameter, <span class="string">&quot;No suitable resolver&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//4.5使用参数解析器解析参数</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         args[i] = <span class="built_in">this</span>.resolvers.resolveArgument(parameter, mavContainer, request, <span class="built_in">this</span>.dataBinderFactory);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">         <span class="comment">//打印异常日志，抛出异常 </span></span><br><span class="line">         <span class="comment">// Leave stack trace for later, exception may actually be resolved and handled...</span></span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">exMsg</span> <span class="operator">=</span> ex.getMessage();</span><br><span class="line">            <span class="keyword">if</span> (exMsg != <span class="literal">null</span> &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123;</span><br><span class="line">               logger.debug(formatArgumentError(parameter, exMsg));</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//5.返回解析出的参数值数组</span></span><br><span class="line">   <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InvocableHandlerMethod就是在HandlerMethod基础上<strong>添加了方法调用功能</strong>，而方法调用又需要解析参数，所以<strong>又提供了解析参数的功能</strong>。</p><p>解析的方法有两种，第一种是在providedArgs里面找，第二种是使用argumentResolvers解析，在RequestMappingHandlerAdapter中的调用并没有提供providedArgs，所以<strong>只有使用argumentResolvers解析</strong>。</p><h4 id="3-6-3ServletInvocableHandlerMethod"><a href="#3-6-3ServletInvocableHandlerMethod" class="headerlink" title="3.6.3ServletInvocableHandlerMethod"></a>3.6.3ServletInvocableHandlerMethod</h4><p>继承自InvocableHandlerMethod，在父类的基础上增加了三个功能：<strong>1.对@ResponseStatus注解的支持，2.对返回值的处理，3.对异步处理结果的处理。</strong></p><p>对返回值的处理是使用returnValueHandlers属性完成的，它是HandlerMethodReturnValueHandlerComposite类型的属性。</p><p>当一个方法注解了@ResponseStatus后，返回的response会使用注释中的Status，<strong>如果处理器返回值为空或者注解的reason不为空</strong>，则将中断处理直接返回（不再渲染页面）。</p><p><strong>1.invokeAndHandle方法</strong>（核心）</p><p>作用：1.invokeForRequest执行方法并获取方法返回值，2.setResponseStatus将解析的@ResponseStatus设置到响应对象中，3.@ResponseStatus注解时两个情况直接返回无需页面渲染（如果处理器返回值为空或者注解的reason不为空），4.返回值处理用于页面渲染</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">      Object... providedArgs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">//1.调用父类的invokeForRequest方法执行方法并获取方法返回值</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">   <span class="comment">//2.根据@ResponseStatus注解（在构造阶段就已经解析了@ResponseStatus注解设置值并设置到HandlerMethod中）设置响应对象的状态码和原因</span></span><br><span class="line">   setResponseStatus(webRequest);</span><br><span class="line">   <span class="comment">//3.如果返回值为null</span></span><br><span class="line">   <span class="keyword">if</span> (returnValue == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//同时请求 NotModified为true（默认false） 或者 使用了@ResponseStatus注解 或者 请求已处理完，则直接返回</span></span><br><span class="line">      <span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="literal">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">         disableContentCachingIfNecessary(webRequest);</span><br><span class="line">         <span class="comment">//在mavContainer设置请求处理完 </span></span><br><span class="line">         mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line">         <span class="comment">//直接返回 </span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">   <span class="comment">//3.如果@ResponseStatus注解设置了异常原因，则直接返回    </span></span><br><span class="line">      mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//4.在mavContainer设置请求未处理完</span></span><br><span class="line">   mavContainer.setRequestHandled(<span class="literal">false</span>);</span><br><span class="line">   Assert.state(<span class="built_in">this</span>.returnValueHandlers != <span class="literal">null</span>, <span class="string">&quot;No return value handlers&quot;</span>);</span><br><span class="line">   <span class="comment">//5.使用返回值处理器处理原始返回值 </span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">            returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(formatErrorForReturnValue(returnValue), ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.setResponseStatus方法</p><p>作用：根据HandlerMethod解析好的@ResponseStatus注解内容设置响应对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResponseStatus</span><span class="params">(ServletWebRequest webRequest)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="comment">//1.从父类 HandlerMethod 获取responseStatus属性</span></span><br><span class="line">   <span class="type">HttpStatus</span> <span class="variable">status</span> <span class="operator">=</span> getResponseStatus();</span><br><span class="line">   <span class="comment">//2.如果为空直接返回 </span></span><br><span class="line">   <span class="keyword">if</span> (status == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3.获取响应对象</span></span><br><span class="line">   <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> webRequest.getResponse();</span><br><span class="line">   <span class="comment">//4.如果响应对象非空 </span></span><br><span class="line">   <span class="keyword">if</span> (response != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//4.1从父类 HandlerMethod 获取responseStatusReason属性</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">reason</span> <span class="operator">=</span> getResponseStatusReason();</span><br><span class="line">      <span class="comment">//4.2如果异常原因非空，则响应返回指定状态码与原因 </span></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(reason)) &#123;</span><br><span class="line">         response.sendError(status.value(), reason);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//4.2如果异常原因为空，则设置响应状态码</span></span><br><span class="line">         response.setStatus(status.value());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//5.给请求对象设置属性，值为状态对象</span></span><br><span class="line">   webRequest.getRequest().setAttribute(View.RESPONSE_STATUS_ATTRIBUTE, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7HandlerMethodArgumentResolver"><a href="#3-7HandlerMethodArgumentResolver" class="headerlink" title="3.7HandlerMethodArgumentResolver"></a>3.7HandlerMethodArgumentResolver</h3><p>用来为处理器解析参数参数，主要用在前面讲过的InvocableHandlerMethod中。</p><p><strong>HandlerMethodArgumentResolver接口定义</strong>，只有两个方法，一个用于判断是否可以解析传入的参数，另一个就是用于实际解析参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerMethodArgumentResolver</span> &#123;</span><br><span class="line">    <span class="comment">//1.判断是否可以解析传入的参数</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span>;</span><br><span class="line">    <span class="comment">//2.解析参数，返回的就是参数值</span></span><br><span class="line">    Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>HandlerMethodArgumentResolver实现类一般有两种命名方式，<strong>一种是XXXMethodArgumentResolver，另一种是XXXMethodProcessor</strong>。前者表示一个参数解析器，后者除了可以解析参数外还可以处理相应类型的返回值，也就是同时还是后面要讲到的HandlerMethodReturnValueHandle。</p><p>另外还有个Adapter，它也不是直接解析参数的，而是用来兼容WebArgumentResolver类型的参数解析器的适配器。</p><p>解析器介绍：</p><ul><li>AbstractMessageConverterMethodArgumentResolver：使<strong>用 HttpMessageConverter 解析request body类型参数的基类</strong>。其实现类有HttpEntityMethodProcessor、RequestPartMethodArgumentResolver、RequestResponseBodyMethodProcessor。</li><li>AbstractMessageConverterMethodProcessor：AbstractMessageConverterMethodArgumentResolver的扩展，支持返回值的处理。</li><li>HttpEntityMethodProcessor：<strong>解析HttpEntity</strong>（代表请求对象或者响应对象，包含头和体）<strong>和RequestEntity</strong>（代表请求对象，还包含请求url和请求类型）<strong>类型的参数</strong>。</li><li>RequestResponseBodyMethodProcessor：解<strong>析注解了@RequestBody的参数</strong>。<strong>（核心参数解析器）</strong></li><li>RequestPartMethodArgumentResolver：<strong>解析注解了@RequestPart或者类型为MultipartFile类型以及javax.servlet.http.Part类型的参数</strong>。</li><li>AbstractNamedValueMethodArgumentResolver：<strong>解析named value类型的参数</strong>（有name的参数，如cookie、requestParam、requestHeader、pathVariable等）<strong>的基类</strong>。</li><li>AbstractCookieValueMethodArgumentResolver：是AbstractNamedValueMethodArgumentResolver的子抽象类，<strong>解析注解了@CookieValue的参数的基类</strong>。</li><li>ServletCookieValueMethodArgumentResolver：是AbstractCookieValueMethodArgumentResolver的子类实现类，<strong>实现resolveName方法，具体解析cookieValue</strong>。</li><li>ExpressionValueMethodArgumentResolver：<strong>解析注解了@Value的参数</strong>，解析过程在父类的resolveEmbeddedValuesAndExpressions方法完成。主要设置了beanFactory，并用它完成具体解析。</li><li>MatrixVariableMethodArgumentResolver：<strong>解析注解了@MatrixVariable而且类型不是Map的参数</strong>。</li><li>PathVariableMethodArgumentResolver：<strong>解析注解了@PathVariable而且类型不是Map的参数</strong>。</li><li>RequestHeaderMethodArgumentResolver：<strong>解析注解了@RequestHeader而且不是Map类型的参数</strong>。</li><li>RequestParamMethodArgumentResolver：解析注解了**@RequestParam的参数<strong>、</strong>MultipartFile类型<strong>的参数和没有注解的通用类型的参数，</strong>如果注解了@RequestParam且类型为Map的参数必须注解设置了name值否则不使用本解析器<strong>。</strong>（核心参数解析器）**</li><li>ModelAttributeMethodProcessor：<strong>解析注解了@ModelAttribute的参数</strong>，如果其中的属性annotationNotRequired为true时还可以解析没有注解的非通用类型的参数（但默认为false）。</li><li>AbstractWebArgumentResolverAdapter：用作 WebArgumentResolver（接口，不同于HandlerMethodArgumentResolver接口） 解析器的适配器。</li><li>ErrorsMethodArgumentResolver：<strong>解析Errors类型的参数</strong>。当一个参数绑定出现异常时会自动将异常设置到其相邻的下一个Errors类型的参数，设置方法就是使用了这个解析器，内部是直接从model中获取的。</li><li>MapMethodProcessor：<strong>解析Map类型参数</strong>（包括ModelMap类型，<strong>且同时要求参数上没有任何注解</strong>）。直接返回mavContainer中的model作为参数值。</li><li>ModelMethodProcessor：<strong>解析Model类型参数</strong>。直接返回mavContainer中的model作为参数值。</li><li>RedirectAttributesMethodArgumentResolver：<strong>解析RedirectAttributes类型的参数</strong>。新建RedirectAttributesModelMap类型的RedirectAttributes并设置到mavConatiner中，然后返回其作为参数值。</li><li>ServletRequestMethodArgumentResolver：解<strong>析WebRequest、ServletRequest、MultipartRequest、HttpSession、Principal、Locale、TimeZone、InputStream、Reader、HttpMethod、ZoneId类型的参数</strong>，它们都是使用request获取的。</li><li>ServletResponseMethodArgumentResolver：<strong>解析ServletResponse、OutputStream、Writer类型的参数</strong>。它们都是使用response获取的。</li><li>SessionStatusMethodArgumentResolver：解析SessionStatus类型参数，直接返回mavContainer中的SessionStatus作为参数值。</li></ul><h4 id="1-ModelMethodProcessor源码分析"><a href="#1-ModelMethodProcessor源码分析" class="headerlink" title="1.ModelMethodProcessor源码分析"></a>1.ModelMethodProcessor源码分析</h4><p>作用：用于解析Model类型的方法参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModelMethodProcessor</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodArgumentResolver</span>, HandlerMethodReturnValueHandler &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">      <span class="comment">//支持解析 Model 类型的参数</span></span><br><span class="line">      <span class="keyword">return</span> Model.class.isAssignableFrom(parameter.getParameterType());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">         NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">      Assert.state(mavContainer != <span class="literal">null</span>, <span class="string">&quot;ModelAndViewContainer is required for model exposure&quot;</span>);</span><br><span class="line">      <span class="comment">//解析参数值，直接返回 mavContainer 中的model</span></span><br><span class="line">      <span class="keyword">return</span> mavContainer.getModel();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>通过前面的分析知道，这时Model可能已经保存了一些值，如<strong>SessionAttributes中的值、FlashMap中的值、还有@ModelAttribute方法设置的值</strong>。主要是以下方法实现的初始化Model的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br></pre></td></tr></table></figure><h4 id="2-PathVariableMethodArgumentResolver源码分析"><a href="#2-PathVariableMethodArgumentResolver源码分析" class="headerlink" title="2.PathVariableMethodArgumentResolver源码分析"></a>2.PathVariableMethodArgumentResolver源码分析</h4><p>作用：解析带@PathVariable注解的方法参数。特别的参数类型为Map时还同时要求@PathVariable注解设置了value值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractNamedValueMethodArgumentResolver.java</span></span><br><span class="line"><span class="comment">//底层模板方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">      NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//=====根据MethodParameter创建NamedValueInfo=======    </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//1.根据 parameter 上的注解来创建NamedValueInfo，封装了参数注解信息（还可能封装了参数名如果注解未设置名字的情况下）</span></span><br><span class="line">   <span class="type">NamedValueInfo</span> <span class="variable">namedValueInfo</span> <span class="operator">=</span> getNamedValueInfo(parameter);</span><br><span class="line">   <span class="comment">//2.获取参数的真实 MethodParameter 对象</span></span><br><span class="line">   <span class="type">MethodParameter</span> <span class="variable">nestedParameter</span> <span class="operator">=</span> parameter.nestedIfOptional();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//====================解析参数名===================</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.解析 NamedValue 参数的名称。即通过注解的name属性值解析出参数名。name属性支持$&#123;&#125;从配置文件获取，支持#&#123;&#125;SpEL表达式，如&quot;#&#123;systemProperties[&#x27;java.vm.version&#x27;]&#125;&quot;。</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">resolvedName</span> <span class="operator">=</span> resolveEmbeddedValuesAndExpressions(namedValueInfo.name);</span><br><span class="line">   <span class="comment">//4.如果参数名为空抛出异常</span></span><br><span class="line">   <span class="keyword">if</span> (resolvedName == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">            <span class="string">&quot;Specified name must not resolve to null: [&quot;</span> + namedValueInfo.name + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//====================解析参数值===================</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//5.通过子类 resolveName 方法解析参数值</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">arg</span> <span class="operator">=</span> resolveName(resolvedName.toString(), nestedParameter, webRequest);</span><br><span class="line">   <span class="comment">//6.如果参数值解析为空 </span></span><br><span class="line">   <span class="keyword">if</span> (arg == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//6.1使用注解提供的默认值（如果注解提供了默认值） </span></span><br><span class="line">      <span class="keyword">if</span> (namedValueInfo.defaultValue != <span class="literal">null</span>) &#123;</span><br><span class="line">         arg = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) &#123;</span><br><span class="line">      <span class="comment">//6.1如果注解要求必须提供，则抛出异常 </span></span><br><span class="line">         handleMissingValue(namedValueInfo.name, nestedParameter, webRequest);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//6.2处理参数值为空值的情况。Boolean类型参数设置值为false，基本类型参数抛出异常</span></span><br><span class="line">      arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(arg) &amp;&amp; namedValueInfo.defaultValue != <span class="literal">null</span>) &#123;</span><br><span class="line">      arg = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//===================参数类型转换===================</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//7.如果 binderFactory 非空，则用它创建WebDataBinder并转换解析出的参数（如果需要转换）</span></span><br><span class="line">   <span class="keyword">if</span> (binderFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">WebDataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> binderFactory.createBinder(webRequest, <span class="literal">null</span>, namedValueInfo.name);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ConversionNotSupportedException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MethodArgumentConversionNotSupportedException</span>(arg, ex.getRequiredType(),</span><br><span class="line">               namedValueInfo.name, parameter, ex.getCause());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MethodArgumentTypeMismatchException</span>(arg, ex.getRequiredType(),</span><br><span class="line">               namedValueInfo.name, parameter, ex.getCause());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Check for null value after conversion of incoming argument value</span></span><br><span class="line">      <span class="keyword">if</span> (arg == <span class="literal">null</span> &amp;&amp; namedValueInfo.defaultValue == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) &#123;</span><br><span class="line">         handleMissingValueAfterConversion(namedValueInfo.name, nestedParameter, webRequest);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===================后置处理======================</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//8.对解析出的参数进行后置处理。pathvariable中为设置请求参数，其它子类为空实现</span></span><br><span class="line">   handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Value中的value、</p><p>@PathVariable中的name、@RequestAttribute中的name、@SessionAttribute中的name、</p><p>@RequestHeader中的name和defaultValue、@RequestParam中的name和defaultValue、@CookieValue中的name和defaultValue支持${}与#{}SpEL表达式形式。</p><p>以上注解都由AbstractNamedValueMethodArgumentResolver子类来处理。</p></blockquote><h4 id="3-RequestParamMethodArgumentResolver源码分析"><a href="#3-RequestParamMethodArgumentResolver源码分析" class="headerlink" title="3.RequestParamMethodArgumentResolver源码分析"></a>3.RequestParamMethodArgumentResolver源码分析</h4><p>RequestMappingHandlerAdapter对象的argumentResolversz属性中<strong>包含对应类型的两个对象</strong>。第一个不会解析无注解简单类型参数，第二个会解析无注解简单类型参数。</p><p><strong>作用</strong>：</p><ol><li>会解析<strong>带@RequestParam注解的参数</strong>。</li><li>会解析<strong>无@RequestPart注解MultipartFile、Part类型</strong>（包括其数组类型和集合类型）<strong>的参数</strong>。</li><li>会解析<strong>无@RequestParam注解简单类型的参数</strong>（包括基本数据类型、基本数据类型对应的包装类型、枚举类型、CharSequence字符序列类型、Date日期类型、Temporal类型即LocalDateTime日期相关类型、URI、URL、Locale、Class类型）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestParamMethodArgumentResolver</span> <span class="keyword">extends</span> <span class="title class_">AbstractNamedValueMethodArgumentResolver</span></span><br><span class="line">      <span class="keyword">implements</span> <span class="title class_">UriComponentsContributor</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是否支持解析指定参数的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">        <span class="comment">//1.如果参数带@RequestParam注解支持解析【情况一】</span></span><br><span class="line"><span class="keyword">if</span> (parameter.hasParameterAnnotation(RequestParam.class)) &#123;</span><br><span class="line">            <span class="comment">//1.1如果参数类型为Map类型，@RequestParam注解必须要指定name参数，如果没有指定则不支持而是依赖RequestParamMapMethodArgumentResolver来解析</span></span><br><span class="line"><span class="keyword">if</span> (Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) &#123;</span><br><span class="line">                <span class="comment">//1.2获取参数上的@RequestParam注解</span></span><br><span class="line"><span class="type">RequestParam</span> <span class="variable">requestParam</span> <span class="operator">=</span> parameter.getParameterAnnotation(RequestParam.class);</span><br><span class="line">                <span class="comment">//1.3判断注解非空且指定了name参数</span></span><br><span class="line"><span class="keyword">return</span> (requestParam != <span class="literal">null</span> &amp;&amp; StringUtils.hasText(requestParam.name()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//1.1如果为其它类型且带@RequestParam注解参数，一律支持 </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//1.如果没有带@RequestParam注解的参数 </span></span><br><span class="line">            <span class="comment">//2.如果参数带@RequestPart注解不支持解析</span></span><br><span class="line"><span class="keyword">if</span> (parameter.hasParameterAnnotation(RequestPart.class)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//3.获取Optional类型参数的嵌套真实参数类型</span></span><br><span class="line">parameter = parameter.nestedIfOptional();</span><br><span class="line">            <span class="comment">//4.如果参数类型为MultipartFile、Part类型支持解析（隐含条件且不允许带@RequestPart、@RequestParam注解）【情况二】</span></span><br><span class="line"><span class="keyword">if</span> (MultipartResolutionDelegate.isMultipartArgument(parameter)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.useDefaultResolution) &#123;</span><br><span class="line">            <span class="comment">//5.如果useDefaultResolution属性为true(第二个对象为true,第一个对象为false)  </span></span><br><span class="line">                <span class="comment">//如果参数类型为简单类型支持解析（隐含条件且不允许带@RequestParam、@RequestPart注解）【情况三】</span></span><br><span class="line"><span class="keyword">return</span> BeanUtils.isSimpleProperty(parameter.getNestedParameterType());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//6.如果为其它情况则不支持解析 </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据参数名、参数类型、请求对象解析参数值（注意此时解析出的参数值为String类型）（父类AbstractNamedValueMethodArgumentResolver#resolveArgument方法调用）</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">resolveName</span><span class="params">(String name, MethodParameter parameter, NativeWebRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.获取请求对象</span></span><br><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">servletRequest</span> <span class="operator">=</span> request.getNativeRequest(HttpServletRequest.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.解析MultipartFile、Part类型参数，并返回（如果不是此类型，则无效mpArg == MultipartResolutionDelegate.UNRESOLVABLE）【请求体获取方法参数值】</span></span><br><span class="line"><span class="keyword">if</span> (servletRequest != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">mpArg</span> <span class="operator">=</span> MultipartResolutionDelegate.resolveMultipartArgument(name, parameter, servletRequest);</span><br><span class="line"><span class="keyword">if</span> (mpArg != MultipartResolutionDelegate.UNRESOLVABLE) &#123;</span><br><span class="line"><span class="keyword">return</span> mpArg;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">arg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//3.解析Multipart类型请求</span></span><br><span class="line"><span class="type">MultipartRequest</span> <span class="variable">multipartRequest</span> <span class="operator">=</span> request.getNativeRequest(MultipartRequest.class);</span><br><span class="line"><span class="keyword">if</span> (multipartRequest != <span class="literal">null</span>) &#123;</span><br><span class="line">List&lt;MultipartFile&gt; files = multipartRequest.getFiles(name);</span><br><span class="line"><span class="keyword">if</span> (!files.isEmpty()) &#123;</span><br><span class="line">arg = (files.size() == <span class="number">1</span> ? files.get(<span class="number">0</span>) : files);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.如果还未解析到参数值（即不是流媒体数据类型MultipartFile、Part）（负责解析@RequestParam注解参数和不带@RequestParam注解简单类型参数）【核心】</span></span><br><span class="line"><span class="keyword">if</span> (arg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//4.1从请求参数中获取指定 参数名 的 请求参数值数组【请求参数中获取方法参数值】</span></span><br><span class="line">String[] paramValues = request.getParameterValues(name);</span><br><span class="line">            <span class="comment">//4.2如果请求参数值数组非空，将其作为方法参数值</span></span><br><span class="line"><span class="keyword">if</span> (paramValues != <span class="literal">null</span>) &#123;</span><br><span class="line">arg = (paramValues.length == <span class="number">1</span> ? paramValues[<span class="number">0</span>] : paramValues);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类<strong>AbstractNamedValueMethodArgumentResolver</strong>关键方法</p><p>注意：<strong>MethodArgumentResolver</strong>里的resolveArgument方法的参数WebDataBinderFactory是由 <strong>InvocableHandlerMethod</strong> 的dataBinderFactory属性传入的，而其属性是在RequestMappingHandlerAdapter中设置的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractNamedValueMethodArgumentResolver</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractNamedValueMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodArgumentResolver</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//HandlerMethodArgumentResolver解析参数【入口方法】</span></span><br><span class="line">    <span class="comment">//根据参数类型MethodParameter、ModelAndViewContainer、请求对象、WebDataBinderFactory解析出参数值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       </span><br><span class="line"><span class="comment">//======获取并缓存指定方法参数对应的NamedValueInfo=========</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.调用本类方法getNamedValueInfo获取NamedValueInfo,</span></span><br><span class="line">        <span class="comment">//先查属性namedValueInfoCache缓存，查不到再调用子类createNamedValueInfo(parameter)创建NamedValueInfo类型对象并缓存起来（方法执行一次，后续方法就不用解析注解创建对象了）</span></span><br><span class="line">        <span class="comment">//createNamedValueInfo(parameter)方法是根据注解信息来创建NamedValueInfo类型对象</span></span><br><span class="line"><span class="type">NamedValueInfo</span> <span class="variable">namedValueInfo</span> <span class="operator">=</span> getNamedValueInfo(parameter);</span><br><span class="line">        <span class="comment">//2.获取Optional参数类型的嵌套真实参数类型</span></span><br><span class="line"><span class="type">MethodParameter</span> <span class="variable">nestedParameter</span> <span class="operator">=</span> parameter.nestedIfOptional();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//=====================解析方法参数名===================</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.根据namedValueInfo.name（来源于 注解 或者 方法参数名）解析方法参数名（可以解析嵌套表达式$&#123;属性文件值&#125;或者SpEL表达式#&#123;SpEL表达式&#125;）</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">resolvedName</span> <span class="operator">=</span> resolveEmbeddedValuesAndExpressions(namedValueInfo.name);</span><br><span class="line">        <span class="comment">//4.如果方法参数名为空则抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (resolvedName == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line"><span class="string">&quot;Specified name must not resolve to null: [&quot;</span> + namedValueInfo.name + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//===================解析方法参数值=====================</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.根据方法参数名、MethodParameter、请求对象解析方法参数值，调用子类的resolveName方法（不同子类实现不同，方法参数值来源不同，可能来自请求参数、请求头、请求属性、session、cookie、请求路径、@Value注解表达式）【核心】</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">arg</span> <span class="operator">=</span> resolveName(resolvedName.toString(), nestedParameter, webRequest);</span><br><span class="line">        <span class="comment">//6.如果解析出方法参数值等于null</span></span><br><span class="line"><span class="keyword">if</span> (arg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//6.1namedValueInfo.defaultValue非空，即注解设置了默认值，则解析默认值作为方法参数值</span></span><br><span class="line"><span class="keyword">if</span> (namedValueInfo.defaultValue != <span class="literal">null</span>) &#123;</span><br><span class="line">arg = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) &#123;</span><br><span class="line">            <span class="comment">//6.2如果必须要参数值且参数类型非Optional（隐含条件且没有设置注解默认值），调用子类handleMissingValue方法（缺失参数值时的方法），实现为抛出异常</span></span><br><span class="line">handleMissingValue(namedValueInfo.name, nestedParameter, webRequest);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//6.3处理为null值的方法参数（如果此时参数值仍然为null才会进行处理）</span></span><br><span class="line">arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(arg) &amp;&amp; namedValueInfo.defaultValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//6.如果解析出的方法参数值为&quot;&quot;字符串且注解设置了默认值，则解析默认值作为方法参数值  </span></span><br><span class="line">arg = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=======================转换方法参数值类型===============</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.如果binderFactory非空（方法传入，一般都非空）</span></span><br><span class="line"><span class="keyword">if</span> (binderFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//7.1使用 binderFactory 来创建WebDataBinder对象，【注意：target为null,objectName为方法参数名】，即创建的WebRequestDataBinder对象target属性等于null，objectName属性为方法参数名</span></span><br><span class="line"><span class="type">WebDataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> binderFactory.createBinder(webRequest, <span class="literal">null</span>, namedValueInfo.name);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//7.2调用binder来转换方法参数值从原始类型到指定类型</span></span><br><span class="line">arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ConversionNotSupportedException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MethodArgumentConversionNotSupportedException</span>(arg, ex.getRequiredType(),</span><br><span class="line">namedValueInfo.name, parameter, ex.getCause());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MethodArgumentTypeMismatchException</span>(arg, ex.getRequiredType(),</span><br><span class="line">namedValueInfo.name, parameter, ex.getCause());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Check for null value after conversion of incoming argument value</span></span><br><span class="line"><span class="keyword">if</span> (arg == <span class="literal">null</span> &amp;&amp; namedValueInfo.defaultValue == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) &#123;</span><br><span class="line">handleMissingValueAfterConversion(namedValueInfo.name, nestedParameter, webRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//8.解析后处理，可忽略不重要</span></span><br><span class="line">handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//9.返回参数值（参数值表面类型为Object、真实类型为指定方法参数类型）</span></span><br><span class="line"><span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据MethodParameter获取NamedValueInfo对象，此方法在方法调用中会逐步构建属性namedValueInfoCache缓存</span></span><br><span class="line">    <span class="keyword">private</span> NamedValueInfo <span class="title function_">getNamedValueInfo</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">        <span class="comment">//1.从属性namedValueInfoCache缓存中获取NamedValueInfo对象，第一次调用次方法时没有缓存后续都存在缓存</span></span><br><span class="line"><span class="type">NamedValueInfo</span> <span class="variable">namedValueInfo</span> <span class="operator">=</span> <span class="built_in">this</span>.namedValueInfoCache.get(parameter);</span><br><span class="line">        <span class="comment">//2.如果缓存的namedValueInfo为空</span></span><br><span class="line"><span class="keyword">if</span> (NamedValueInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//2.1则调用子类createNamedValueInfo方法根据参数上的注解创建NamedValueInfo类型对象，如没有注解则创建一个默认对象（当然有些子类不允许没有注解）</span></span><br><span class="line">namedValueInfo = createNamedValueInfo(parameter);</span><br><span class="line">            <span class="comment">//2.2调用本类updateNamedValueInfo方法在子类创建的NamedValueInfo类型对象基础上再根据参数名创建新的NamedValueInfo对象</span></span><br><span class="line">            <span class="comment">//可能会更新NamedValueInfo对象name属性、defaultValue属性</span></span><br><span class="line">namedValueInfo = updateNamedValueInfo(parameter, namedValueInfo);</span><br><span class="line">            <span class="comment">//2.3缓存到namedValueInfoCache属性</span></span><br><span class="line"><span class="built_in">this</span>.namedValueInfoCache.put(parameter, namedValueInfo);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//3.返回NamedValueInfo对象（真实类型也为NamedValueInfo）</span></span><br><span class="line"><span class="keyword">return</span> namedValueInfo;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-ServletModelAttributeMethodProcessor源码分析"><a href="#4-ServletModelAttributeMethodProcessor源码分析" class="headerlink" title="4.ServletModelAttributeMethodProcessor源码分析"></a>4.ServletModelAttributeMethodProcessor源码分析</h4><p>RequestMappingHandlerAdapter对象的argumentResolvers属性中<strong>包含对应类型的两个对象</strong>。第一个不会解析无注解复杂类型参数，第二个会解析无注解复杂类型参数。</p><p><strong>作用</strong>：</p><ol><li>支持<strong>解析带@ModelAttribute注解的方法参数</strong>。</li><li>支持<strong>解析无@ModelAttribute注解非简单类型的方法参数</strong>。</li></ol><blockquote><p>@ModelAttribute注解方法参数值解析来源，不仅来源于Model中还来源于 请求路径 和 请求参数，且请求路径优于请求参数优于Model。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModelAttributeMethodProcessor</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodArgumentResolver</span>, HandlerMethodReturnValueHandler &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否支持指定的方法参数MethodParameter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">        <span class="comment">//1.支持带@ModelAttribute注解的方法参数 或者 无@ModelAttribute注解非简单类型的方法参数</span></span><br><span class="line"><span class="keyword">return</span> (parameter.hasParameterAnnotation(ModelAttribute.class) ||</span><br><span class="line">(<span class="built_in">this</span>.annotationNotRequired &amp;&amp; !BeanUtils.isSimpleProperty(parameter.getParameterType())));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据参数类型MethodParameter、ModelAndViewContainer、请求对象、WebDataBinderFactory解析参数值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">Assert.state(mavContainer != <span class="literal">null</span>, <span class="string">&quot;ModelAttributeMethodProcessor requires ModelAndViewContainer&quot;</span>);</span><br><span class="line">Assert.state(binderFactory != <span class="literal">null</span>, <span class="string">&quot;ModelAttributeMethodProcessor requires WebDataBinderFactory&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//========================解析参数名====================</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.调用ModelFactory静态方法getNameForParameter获取方法参数名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ModelFactory.getNameForParameter(parameter);</span><br><span class="line">        <span class="comment">//2.获取方法参数上的@ModelAttribute注解对象</span></span><br><span class="line"><span class="type">ModelAttribute</span> <span class="variable">ann</span> <span class="operator">=</span> parameter.getParameterAnnotation(ModelAttribute.class);</span><br><span class="line">        <span class="comment">//3.如果注解对象非空</span></span><br><span class="line"><span class="keyword">if</span> (ann != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//设置 mavContainer 属性的绑定情况</span></span><br><span class="line">mavContainer.setBinding(name, ann.binding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=================初步解析参数值===================</span></span><br><span class="line">        </span><br><span class="line"><span class="type">Object</span> <span class="variable">attribute</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">BindingResult</span> <span class="variable">bindingResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.如果 mavContainer 中有与方法参数名同名的属性名</span></span><br><span class="line"><span class="keyword">if</span> (mavContainer.containsAttribute(name)) &#123;</span><br><span class="line">            <span class="comment">//4.1从model中获取同名属性值（会作为方法参数值）【情况一：从mavContainer的Model中获取方法参数值】</span></span><br><span class="line">attribute = mavContainer.getModel().get(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//4.如果 mavContainer 中没有有与方法参数名同名的属性名</span></span><br><span class="line"><span class="comment">//4.1调用子类方法createAttribute创建属性对象【情况二：直接创建指定类型的参数值对象，此时没有绑定对象属性】</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">attribute = createAttribute(name, parameter, binderFactory, webRequest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BindException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (isBindExceptionRequired(parameter)) &#123;</span><br><span class="line"><span class="comment">// No BindingResult parameter -&gt; fail with BindException</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Otherwise, expose null/empty value and associated BindingResult</span></span><br><span class="line"><span class="keyword">if</span> (parameter.getParameterType() == Optional.class) &#123;</span><br><span class="line">attribute = Optional.empty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">attribute = ex.getTarget();</span><br><span class="line">&#125;</span><br><span class="line">bindingResult = ex.getBindingResult();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=============绑定嵌套的参数值，并校验参数值==========</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.如果 bindingResult 为空（异常绑定时不为空）【核心】</span></span><br><span class="line"><span class="keyword">if</span> (bindingResult == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// Bean property binding and validation;</span></span><br><span class="line"><span class="comment">// skipped in case of binding failure on construction.</span></span><br><span class="line">            <span class="comment">//5.1创建指定attribute对象的数据绑定对象binder，来绑定并校验对象中的属性值</span></span><br><span class="line"><span class="type">WebDataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> binderFactory.createBinder(webRequest, attribute, name);</span><br><span class="line">            <span class="comment">//5.2数据绑定对象binder的目标对象target非空（此时为attribute）</span></span><br><span class="line"><span class="keyword">if</span> (binder.getTarget() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//5.2.1如果mavContainer没有禁止绑定此参数名</span></span><br><span class="line"><span class="keyword">if</span> (!mavContainer.isBindingDisabled(name)) &#123;</span><br><span class="line">                    <span class="comment">//调用子类的bindRequestParameters方法，来通过request对象中的内容绑定对象属性数据</span></span><br><span class="line">bindRequestParameters(binder, webRequest);</span><br><span class="line">&#125;</span><br><span class="line">                <span class="comment">//5.2.2校验参数值</span></span><br><span class="line">validateIfApplicable(binder, parameter);</span><br><span class="line">                <span class="comment">//5.2.3校验异常则抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindException</span>(binder.getBindingResult());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//5.3转换方法参数类型</span></span><br><span class="line"><span class="comment">// Value type adaptation, also covering java.util.Optional</span></span><br><span class="line"><span class="keyword">if</span> (!parameter.getParameterType().isInstance(attribute)) &#123;</span><br><span class="line">attribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//5.4获取绑定结果</span></span><br><span class="line">bindingResult = binder.getBindingResult();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.更新mavContainer</span></span><br><span class="line"><span class="comment">// Add resolved attribute and BindingResult at the end of the model</span></span><br><span class="line">Map&lt;String, Object&gt; bindingResultModel = bindingResult.getModel();</span><br><span class="line">mavContainer.removeAttributes(bindingResultModel);</span><br><span class="line">mavContainer.addAllAttributes(bindingResultModel);</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.返回参数值</span></span><br><span class="line"><span class="keyword">return</span> attribute;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ModelFactory.getNameForParameter(parameter)方法解析</p><p>作用：根据 MethodParameter对象 解析方法参数名，即基于参数上的注解或者参数类型解析参数名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ModelFactory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getNameForParameter</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">   <span class="comment">//1.获取指定方法参数上的 @ModelAttribute 注解</span></span><br><span class="line">   <span class="type">ModelAttribute</span> <span class="variable">ann</span> <span class="operator">=</span> parameter.getParameterAnnotation(ModelAttribute.class);</span><br><span class="line">   <span class="comment">//2.如果@ModelAttribute注解存在，则【基于注解value值】获取【方法参数名】</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (ann != <span class="literal">null</span> ? ann.value() : <span class="literal">null</span>);</span><br><span class="line">   <span class="comment">//3.如果@ModelAttribute注解不存在，则【基于参数类型】获取【方法参数名】</span></span><br><span class="line">   <span class="keyword">return</span> (StringUtils.hasText(name) ? name : Conventions.getVariableNameForParameter(parameter));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createAttribute(name, parameter, binderFactory, webRequest)方法解析</p><p>作用：根据参数名、参数类型创建方法参数值。（此时未初始化嵌套的参数属性值）。</p><p>1.对于**@ModelAttribute注解的参数，且未在mavContainer得Model中发现对应名称的属性时**，会在本方法创建Model的属性值，并作为方法参数值。（本子类实现如请求路径或请求参数存在此参数名的值时以此值作为方法参数值，父类实现不存在时创建Model属性对象）</p><p>2.对于<strong>没有@ModelAttribute注解非简单类型的参数</strong>，则会在本方法根据参数类型直接使用反射构造器创建方法参数值对象，后续再使用WebDataBinder来初始化方法参数的属性值。（完全由父类实现创建）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServletModelAttributeMethodProcessor.java</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title function_">createAttribute</span><span class="params">(String attributeName, MethodParameter parameter,</span></span><br><span class="line"><span class="params">      WebDataBinderFactory binderFactory, NativeWebRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1.从请求对象中（请求路径、请求参数）获取与参数名同名的“请求值”【只使用与@ModelAttribute参数】</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> getRequestValueForAttribute(attributeName, request);</span><br><span class="line">   <span class="comment">//2.如果 “请求值” 非空，则基于”请求值“创建属性值/方法参数值，如果非空则返回</span></span><br><span class="line">   <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//2.1基于请求值通过WebDataBinder来转换值类型为方法参数值类型（一般只适用于@ModelAttribute注解的参数情况，因为WebDataBinder不支持直接将String转换为复杂对象类型）</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">attribute</span> <span class="operator">=</span> createAttributeFromRequestValue(</span><br><span class="line">            value, attributeName, parameter, binderFactory, request);</span><br><span class="line">      <span class="comment">//2.2如果 attribute非空，则返回类型转换好的方法参数值</span></span><br><span class="line">      <span class="keyword">if</span> (attribute != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> attribute;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.如果“请求值”为空，则调用父类createAttribute来创建属性值/方法参数值对象【适用于@ModelAttribute参数和复杂类型参数】</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">super</span>.createAttribute(attributeName, parameter, binderFactory, request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据【方法参数名】从请求对象中获取“请求值”字符串</span></span><br><span class="line"><span class="comment">// * 先从【请求路径】获取指定方法参数名的 请求路径值</span></span><br><span class="line"><span class="comment">// * 再从【请求参数】中获取指定方法参数名的 请求参数值</span></span><br><span class="line"><span class="comment">// * 如果从以上参数值源中无法获取到，则返回null</span></span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">getRequestValueForAttribute</span><span class="params">(String attributeName, NativeWebRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">//1.获取请求路径名字与值的映射</span></span><br><span class="line">    Map&lt;String, String&gt; variables = getUriTemplateVariables(request);</span><br><span class="line">    <span class="comment">//2.从请求路径中获取与【方法参数名】同名的【请求路径值】“请求值”，如果非空则返回</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">variableValue</span> <span class="operator">=</span> variables.get(attributeName);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(variableValue)) &#123;</span><br><span class="line">        <span class="keyword">return</span> variableValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.获取与【方法参数名】同名的【请求参数值】，如果非空则返回</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">parameterValue</span> <span class="operator">=</span> request.getParameter(attributeName);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(parameterValue)) &#123;</span><br><span class="line">        <span class="keyword">return</span> parameterValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.如果没有与方法参数名同名的请求路径与请求参数，则返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据String类型的 sourceValue 来创建属性值对象/方法参数值对象</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createAttributeFromRequestValue</span><span class="params">(String sourceValue, String attributeName,</span></span><br><span class="line"><span class="params">        MethodParameter parameter, WebDataBinderFactory binderFactory, NativeWebRequest request)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.从 binderFactory 获取 DataBinder 对象</span></span><br><span class="line">    <span class="type">DataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> binderFactory.createBinder(request, <span class="literal">null</span>, attributeName);</span><br><span class="line">    <span class="comment">//2.从DataBinder对象获取 ConversionService 对象</span></span><br><span class="line">    <span class="type">ConversionService</span> <span class="variable">conversionService</span> <span class="operator">=</span> binder.getConversionService();</span><br><span class="line">    <span class="comment">//3.如果conversionService非空,尝试进行类型转换获取方法参数值</span></span><br><span class="line">    <span class="keyword">if</span> (conversionService != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//3.1获取源数据类型TypeDescriptor对象</span></span><br><span class="line">        <span class="type">TypeDescriptor</span> <span class="variable">source</span> <span class="operator">=</span> TypeDescriptor.valueOf(String.class);</span><br><span class="line">        <span class="comment">//3.2创建方法参数类型TypeDescriptor对象</span></span><br><span class="line">        <span class="type">TypeDescriptor</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeDescriptor</span>(parameter);</span><br><span class="line">        <span class="comment">//3.3使用 conversionService 来转换数据类型，来获取正确类型的 方法参数值对象</span></span><br><span class="line">        <span class="keyword">if</span> (conversionService.canConvert(source, target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> binder.convertIfNecessary(sourceValue, parameter.getParameterType(), parameter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.如果不支持类型转换则返回null（如：String类型=》自定义类型）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类ModelAttributeMethodProcessor的createAttribute方法</p><p>作用：1.创建Model属性对象2.创建复杂类型对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ModelAttributeMethodProcessor.java</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createAttribute</span><span class="params">(String attributeName, MethodParameter parameter,</span></span><br><span class="line"><span class="params">      WebDataBinderFactory binderFactory, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1.获取非Optional类型的 MethodParameter 参数类型对象</span></span><br><span class="line">   <span class="type">MethodParameter</span> <span class="variable">nestedParameter</span> <span class="operator">=</span> parameter.nestedIfOptional();</span><br><span class="line">   <span class="comment">//2.获取方法参数类型 </span></span><br><span class="line">   Class&lt;?&gt; clazz = nestedParameter.getNestedParameterType();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.获取 方法参数反射构造器对象（可用的构造器对象）</span></span><br><span class="line">   Constructor&lt;?&gt; ctor = BeanUtils.getResolvableConstructor(clazz);</span><br><span class="line">   <span class="comment">//4.通过构造器创建方法参数值对象 【核心】</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">attribute</span> <span class="operator">=</span> constructAttribute(ctor, attributeName, parameter, binderFactory, webRequest);</span><br><span class="line">   <span class="keyword">if</span> (parameter != nestedParameter) &#123;</span><br><span class="line">      attribute = Optional.of(attribute);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//5.返回方法参数值对象 </span></span><br><span class="line">   <span class="keyword">return</span> attribute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数据绑定器工厂</strong></p><p><strong>核心绑定不同类型参数</strong>的组件<strong>ServletRequestDataBinderFactory</strong>，每次调用方法就会创建一个此 WebDataBinderFactory 工厂对象。</p><p><img src="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/image-20240420004623145.png" alt="image-20240420004623145"></p><p>ServletRequestDataBinderFactory组件有两个作用:</p><ol><li>对于<strong>简单</strong>类型，将String类型值（来源于请求）<strong>转换</strong>为方法参数值类型。</li><li>对于<strong>复杂</strong>类型，将string类型值（来源于请求）<strong>设置</strong>到方法参数对象的属性中。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServletRequestDataBinderFactory工厂对象的顶层设计</span></span><br><span class="line"><span class="comment">//主要实现了创建ExtendedServletRequestDataBinder对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletRequestDataBinderFactory</span> <span class="keyword">extends</span> <span class="title class_">InitBinderDataBinderFactory</span> &#123;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServletRequestDataBinderFactory</span><span class="params">(<span class="meta">@Nullable</span> List&lt;InvocableHandlerMethod&gt; binderMethods,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> WebBindingInitializer initializer)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">super</span>(binderMethods, initializer);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取 ExtendedServletRequestDataBinder类型的 DataBinder 对象（非单例的）</span></span><br><span class="line">    <span class="keyword">protected</span> ServletRequestDataBinder <span class="title function_">createBinderInstance</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> Object target, String objectName, NativeWebRequest request)</span> <span class="keyword">throws</span> Exception  &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExtendedServletRequestDataBinder</span>(target, objectName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主要存储了InitBinder方法集合、和实现了其相关方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitBinderDataBinderFactory</span> <span class="keyword">extends</span> <span class="title class_">DefaultDataBinderFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//InitBinderDataBinderFactory子类核心属性，封装了构造器传入的InitBinder方法对象集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;InvocableHandlerMethod&gt; binderMethods;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器，初始化binderMethods属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InitBinderDataBinderFactory</span><span class="params">(<span class="meta">@Nullable</span> List&lt;InvocableHandlerMethod&gt; binderMethods,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> WebBindingInitializer initializer)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">super</span>(initializer);</span><br><span class="line"><span class="built_in">this</span>.binderMethods = (binderMethods != <span class="literal">null</span> ? binderMethods : Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用本对象的binderMethods属性来初始化传入的 WebDataBinder 参数对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initBinder</span><span class="params">(WebDataBinder dataBinder, NativeWebRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">for</span> (InvocableHandlerMethod binderMethod : <span class="built_in">this</span>.binderMethods) &#123;</span><br><span class="line"><span class="keyword">if</span> (isBinderMethodApplicable(binderMethod, dataBinder)) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> binderMethod.invokeForRequest(request, <span class="literal">null</span>, dataBinder);</span><br><span class="line"><span class="keyword">if</span> (returnValue != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line"><span class="string">&quot;@InitBinder methods must not return a value (should be void): &quot;</span> + binderMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是否可以对指定WebDataBinder使用指定HandlerMethod</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isBinderMethodApplicable</span><span class="params">(HandlerMethod initBinderMethod, WebDataBinder dataBinder)</span> &#123;</span><br><span class="line"><span class="type">InitBinder</span> <span class="variable">ann</span> <span class="operator">=</span> initBinderMethod.getMethodAnnotation(InitBinder.class);</span><br><span class="line">Assert.state(ann != <span class="literal">null</span>, <span class="string">&quot;No InitBinder annotation&quot;</span>);</span><br><span class="line">String[] names = ann.value();</span><br><span class="line"><span class="keyword">return</span> (ObjectUtils.isEmpty(names) || ObjectUtils.containsElement(names, dataBinder.getObjectName()));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主要存储了WebBindingInitializer对象，并实现了使用它来初始化WebRequestDataBinder对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultDataBinderFactory</span> <span class="keyword">implements</span> <span class="title class_">WebDataBinderFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化器属性（构造器传入）</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> WebBindingInitializer initializer;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DefaultDataBinderFactory</span><span class="params">(<span class="meta">@Nullable</span> WebBindingInitializer initializer)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.initializer = initializer;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接口实现，底层模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> WebDataBinder <span class="title function_">createBinder</span><span class="params">(</span></span><br><span class="line"><span class="params">NativeWebRequest webRequest, <span class="meta">@Nullable</span> Object target, String objectName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.使用子类ServletRequestDataBinderFactory工厂对象方法创建WebDataBinder对象</span></span><br><span class="line"><span class="type">WebDataBinder</span> <span class="variable">dataBinder</span> <span class="operator">=</span> createBinderInstance(target, objectName, webRequest);</span><br><span class="line">        <span class="comment">//2.使用 initializer 属性对象中的属性来【初始化 dataBinder】的属性</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.initializer != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="built_in">this</span>.initializer.initBinder(dataBinder, webRequest);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//3.调用父类InitBinderDataBinderFactory的initBinder方法，使用initBinder方法集合来【初始化 dataBinder】</span></span><br><span class="line">initBinder(dataBinder, webRequest);</span><br><span class="line"><span class="keyword">return</span> dataBinder;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口 WebDataBinderFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WebDataBinderFactory</span> &#123;</span><br><span class="line">    <span class="comment">//创建 WebDataBinder</span></span><br><span class="line">    <span class="comment">//Params:</span></span><br><span class="line"><span class="comment">//webRequest – the current request</span></span><br><span class="line"><span class="comment">//target – the object to create a data binder for, or null if creating a binder for a simple type</span></span><br><span class="line"><span class="comment">//objectName – the name of the target object</span></span><br><span class="line">    WebDataBinder <span class="title function_">createBinder</span><span class="params">(NativeWebRequest webRequest, <span class="meta">@Nullable</span> Object target, String objectName)</span></span><br><span class="line"><span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>数据绑定器</strong></p><p><img src="/2024/04/21/Spring-MVC%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/image-20240420005124008.png" alt="image-20240420005124008"></p><p>核心入口方法是<strong>bind(ServletRequest request)方法</strong>！</p><p>方法位于ServletRequestDataBinder类中。</p><p>作用：</p><ol><li>收集【请求参数】中的数据创建 ServletRequestParameterPropertyValues 对象，</li><li>调用父类addBindValues(mpvs, request)方法收集【请求路径】中的数据填充ServletRequestParameterPropertyValues数据，</li><li>调用子类WebDataBinder的doBind(mpvs)方法来真正执行数据绑定。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入口方法所在类（从请求对象执行数据绑定到目标参数对象（这里是此对象的target属性））</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletRequestDataBinder</span> <span class="keyword">extends</span> <span class="title class_">WebDataBinder</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//入口方法。将【请求对象中的数据】绑定到【绑定器属性target中】。绑定支持multipart file</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(ServletRequest request)</span> &#123;</span><br><span class="line"><span class="comment">//==============查询数据绑定源数据=============</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.创建 ServletRequestParameterPropertyValues 对象，基于【请求参数数据】创建对象</span></span><br><span class="line"><span class="type">MutablePropertyValues</span> <span class="variable">mpvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRequestParameterPropertyValues</span>(request);</span><br><span class="line">        <span class="comment">//2.处理 文件类型的 方法参数数据绑定</span></span><br><span class="line"><span class="type">MultipartRequest</span> <span class="variable">multipartRequest</span> <span class="operator">=</span> WebUtils.getNativeRequest(request, MultipartRequest.class);</span><br><span class="line"><span class="keyword">if</span> (multipartRequest != <span class="literal">null</span>) &#123;</span><br><span class="line">bindMultipart(multipartRequest.getMultiFileMap(), mpvs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.startsWithIgnoreCase(request.getContentType(), MediaType.MULTIPART_FORM_DATA_VALUE)) &#123;</span><br><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> WebUtils.getNativeRequest(request, HttpServletRequest.class);</span><br><span class="line"><span class="keyword">if</span> (httpServletRequest != <span class="literal">null</span> &amp;&amp; HttpMethod.POST.matches(httpServletRequest.getMethod())) &#123;</span><br><span class="line">StandardServletPartUtils.bindParts(httpServletRequest, mpvs, isBindEmptyMultipartFiles());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//3.基于【请求路径数据】将绑定数据源添加到创建的 mpvs 对象中</span></span><br><span class="line">addBindValues(mpvs, request);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=============使用mpvs来执行数据绑定==========</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.使用收集到的绑定数据来真正执行数据绑定</span></span><br><span class="line">doBind(mpvs);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebDataBinder的doBind(mpvs)方法</p><p>作用：1.校验mpvs中的默认字段2.校验mpvs中的空白字段3.将mpvs中的[]名字后缀去掉4.真正执行数据绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WebDataBinder.java</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">fieldMarkerPrefix</span> <span class="operator">=</span> DEFAULT_FIELD_MARKER_PREFIX;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">fieldDefaultPrefix</span> <span class="operator">=</span> DEFAULT_FIELD_DEFAULT_PREFIX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">bindEmptyMultipartFiles</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBind</span><span class="params">(MutablePropertyValues mpvs)</span> &#123;</span><br><span class="line">   <span class="comment">//1.从 mpvs 查找以 &quot;！&quot;开头的PropertyValue，并将其item移除，且可能会添加新的item。即检查有无默认值并视情况使用</span></span><br><span class="line">   checkFieldDefaults(mpvs);</span><br><span class="line">   <span class="comment">//2.从 mpvs 查找以 &quot;_&quot;开头的PropertyValue，并将其item移除，且可能会添加新的item。即检查有无空白值并视情况使用</span></span><br><span class="line">   checkFieldMarkers(mpvs);</span><br><span class="line">   <span class="comment">//3.从 mpvs 查找以 &quot;[]&quot;结束的PropertyValue，并将其item移除，且可能会添加新的item。</span></span><br><span class="line">   adaptEmptyArrayIndices(mpvs);</span><br><span class="line">   <span class="comment">//4.调用父类DataBinder.dobind(mpvs)真正执行数据绑定</span></span><br><span class="line">   <span class="built_in">super</span>.doBind(mpvs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DataBinder的dobind(mpvs)方法</p><p>作用：1.校验是否允许绑定2.校验是否必须绑定3.指定数据绑定</p><p>是基于<strong>BeanWrapperImpl</strong>来实现的bean属性的数据类型转换，更核心的是<strong>AbstractNestablePropertyAccessor</strong>.java类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBind</span><span class="params">(MutablePropertyValues mpvs)</span> &#123;</span><br><span class="line">   <span class="comment">//1.通过本类属性allowedFields、disallowedFields来校验指定字段是否允许绑定 </span></span><br><span class="line">   checkAllowedFields(mpvs);</span><br><span class="line">   <span class="comment">//2.通过本类属性requiredFields来校验指定必须绑定的字段 </span></span><br><span class="line">   checkRequiredFields(mpvs);</span><br><span class="line">   <span class="comment">//3.真正执行数据绑定 </span></span><br><span class="line">   applyPropertyValues(mpvs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真正执行数据绑定的我方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">applyPropertyValues</span><span class="params">(MutablePropertyValues mpvs)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Bind request parameters onto target object.</span></span><br><span class="line">        <span class="comment">//1.首先从bindingResult属性中获取beanWrapper属性即得到ConfigurablePropertyAccessor（真实类型BeanWrapperImpl）；然后调用其setPropertyValues方法【核心是BeanWrapperImpl类的实现】</span></span><br><span class="line">        getPropertyAccessor().setPropertyValues(mpvs, isIgnoreUnknownFields(), isIgnoreInvalidFields());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (PropertyBatchUpdateException ex) &#123;</span><br><span class="line">        <span class="comment">// Use bind error processor to create FieldErrors.</span></span><br><span class="line">        <span class="keyword">for</span> (PropertyAccessException pae : ex.getPropertyAccessExceptions()) &#123;</span><br><span class="line">            getBindingErrorProcessor().processPropertyAccessException(pae, getInternalBindingResult());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> ConfigurablePropertyAccessor <span class="title function_">getPropertyAccessor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getInternalBindingResult().getPropertyAccessor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> AbstractPropertyBindingResult <span class="title function_">getInternalBindingResult</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.bindingResult == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.bindingResult = (<span class="built_in">this</span>.directFieldAccess ?</span><br><span class="line">                createDirectFieldBindingResult(): createBeanPropertyBindingResult());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.bindingResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BeanWrapperImpl的核心</strong>转换数据类型是基于：<strong>ConversionService</strong>（TODO：分析BeanWrapperImpl、与WebConversionService组件）</p><p>对象参数转换核心：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConversionService接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConversionService</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">canConvert</span><span class="params">(<span class="meta">@Nullable</span> Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">canConvert</span><span class="params">(<span class="meta">@Nullable</span> TypeDescriptor sourceType, TypeDescriptor targetType)</span>;</span><br><span class="line">    &lt;T&gt; T <span class="title function_">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, Class&lt;T&gt; targetType)</span>;</span><br><span class="line">    Object <span class="title function_">convert</span><span class="params">(<span class="meta">@Nullable</span> Object source, <span class="meta">@Nullable</span> TypeDescriptor sourceType, TypeDescriptor targetType)</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>核心实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GenericConversionService（WebConversionService父类）</span></span><br><span class="line"><span class="comment">//WebConversionService(WebMvcAutoConfiguration自动注入)</span></span><br></pre></td></tr></table></figure><h4 id="5-RequestResponseBodyMethodProcessor源码分析"><a href="#5-RequestResponseBodyMethodProcessor源码分析" class="headerlink" title="5.RequestResponseBodyMethodProcessor源码分析"></a>5.RequestResponseBodyMethodProcessor源码分析</h4>]]></content>
      
      
      <categories>
          
          <category> Spring MVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA中maven多模块打包方式与机制</title>
      <link href="/2024/04/21/IDEA%E4%B8%ADmaven%E5%A4%9A%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/04/21/IDEA%E4%B8%ADmaven%E5%A4%9A%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>使用IDEA中的Maven打包是一个很频繁的操作，在<strong>多模块下Maven打包</strong>流程就会变得有些复杂，我们就来浅分析一下其中涉及的机制。</p><p>多模块打包方式有三种：</p><ol><li><strong>一键打包</strong>（多模块批量打包）</li><li><strong>逐步打包</strong>（单模块多次打包）</li><li><strong>混合打包</strong>（部分多次，部分批量）</li></ol><p>当然我们推荐一键打包，毕竟更加智能快捷~，有利于CI/CD一键部署。</p><blockquote><p>结论先行：一键打包先clean再package</p></blockquote><h1 id="1-准备模块"><a href="#1-准备模块" class="headerlink" title="1.准备模块"></a>1.准备模块</h1><p>读者无需准备啦，有个项目框架往下看就行啦~本文根据项目框架来进行讲解</p><p>首先我们准备<strong>模块设计</strong>如下：</p><p><img src="/2024/04/21/IDEA%E4%B8%ADmaven%E5%A4%9A%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%9C%BA%E5%88%B6/image-20240319201615496.png" alt="image-20240319201615496"></p><p>具体<strong>工程目录</strong>如下：</p><p><img src="/2024/04/21/IDEA%E4%B8%ADmaven%E5%A4%9A%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%9C%BA%E5%88%B6/image-20240319174713437.png" alt="image-20240319174713437"></p><p>后续我们采用<strong>打包方式</strong>为：直接通过根目录<strong>一键打包</strong>所有模块，采用的插件是spring-boot-maven-plugin来打包各个子boot项目。且直接在idea中生成jar包，<strong>不将任何子模块install到本地Maven仓库中</strong>，以<strong>避免本地mven仓库冗余</strong>我们自己编写的代码，直接存在idea的target目录就足够了。</p><h1 id="2-编写pom文件内容"><a href="#2-编写pom文件内容" class="headerlink" title="2.编写pom文件内容"></a>2.编写pom文件内容</h1><p>在父模块wzyapi引入<strong>modules标签</strong>。以<strong>控制maven需要编译打包的子模块</strong>。没有引入modules的模块不会被编译打包。如果你部分模块想直接使用本地仓库的，而不使用idea中编写的就不要引入到modules中。</p><p>例如本地仓库有wzyapi-common完整模块代码了，即使idea中改动了我也不想用，我就要用本地代码，那么modules标签中一定不要包含wzyapi-common模块，让maven自己在本地寻找依赖，否则你打包出来的永远是idea中代码编译出来的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>wzyapi-dependencies<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>wzyapi-common<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>wzyapi-client-sdk<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>wzyapi-framework<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>wzyapi-backend-api<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>wzyapi-interface<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>wzyapi-gateway<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>wzyapi-backend<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上我们实现了一个小功能，控制maven需要囊括编译的模块，和控<strong>制不需要囊括编译的模块</strong>（即不在modules中声明），或者说控制maven使用本地仓库代码的模块。</p><p>当然我们可以写一个模块install一个模块，来多次编译获取最新的jar包，这样就与单模块编写代码无异，这样虽然<strong>同步性强</strong>但人工操作就急剧增多，不智能^^。这种打包方式我称为<strong>逐步打包</strong>/单模块打包。</p><p>既然逐步部署同步性强，那么一键部署就会同步性较差，如果不注意就会导致代码未同步到jar包中。</p><blockquote><p> 先行结论，如果要保证一键部署的强同步性，在每次打包时建议先clean再打包。</p></blockquote><h2 id="2-1父模块pom"><a href="#2-1父模块pom" class="headerlink" title="2.1父模块pom"></a>2.1父模块pom</h2><p>父模块完整pom.xml文件内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.wzy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>wzyapi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>wzyapi<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>一个面向开发者的api开放平台<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--子模块版本管理--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">reversion</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">reversion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--plugin版本管理--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven-compiler-plugin.version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">maven-compiler-plugin.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-boot-maven-plugin.version</span>&gt;</span>2.7.6<span class="tag">&lt;/<span class="name">spring-boot-maven-plugin.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>wzyapi-dependencies<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>wzyapi-common<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>wzyapi-client-sdk<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>wzyapi-framework<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>wzyapi-backend-api<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>wzyapi-interface<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>wzyapi-gateway<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>wzyapi-backend<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.wzy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>wzyapi-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;maven-compiler-plugin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot-maven-plugin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-2子模块pom"><a href="#2-2子模块pom" class="headerlink" title="2.2子模块pom"></a>2.2子模块pom</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;com.wzy&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;wzyapi&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;artifactId&gt;wzyapi-backend&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;reversion&#125;&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;wzyapi_backend&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;wzyapi开放平台的【api后台管理系统】&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        。。。省略了依赖。。。</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;!--war包打包插件 --&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">                    &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;!--jar包打包插件--&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;mainClass&gt;com.wzy.project.MyApplication&lt;/mainClass&gt;</span><br><span class="line">                    &lt;excludes&gt;</span><br><span class="line">                        &lt;exclude&gt;</span><br><span class="line">                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">                        &lt;/exclude&gt;</span><br><span class="line">                    &lt;/excludes&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class="line">                            &lt;goal&gt;build-info&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;!--git属性文件生成插件--&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;pl.project13.maven&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;git-commit-id-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;revision&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;generateGitPropertiesFile&gt;true&lt;/generateGitPropertiesFile&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">                &lt;!--开启过滤，用来指定的参数替换directory下的文件中的参数--&gt;</span><br><span class="line">                &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">            &lt;/resource&gt;</span><br><span class="line">        &lt;/resources&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><h2 id="2-3总结"><a href="#2-3总结" class="headerlink" title="2.3总结"></a>2.3总结</h2><p>1.父模块在 <code>dependencyManagement</code> 标签引入<strong>版本管理依赖 wzyapi-dependencies</strong>，这样就可以在父模块管理许多依赖的版本了。</p><p>但需要注意的是，在父模块引入 wzyapi-dependencies ，它内部的properties标签并不能传递，我们需要使用父模块来传递properties标签。即wzyapi-dependencies管理 dependencies中的依赖版本，父模块管理一些额外需要使用的properties标签。</p><p>2.子模块编写 <code>dependencies</code> 标签且无需版本号，<strong>定义子模块需要使用的依赖</strong>，一旦引入新的依赖就加到 wzyapi-dependencies 进行管理。</p><p>3.子模块编写 <code>build</code> 标签，定义打包需要的插件。对于boot模块即<strong>运行模块</strong>使用spring-boot-maven-plugin插件，对于jar模块和pom模块即<strong>无需启动的模块</strong>无需定义插件。</p><p>至此我们就可以实现一键打包了^^。</p><blockquote><p>父模块依赖版本管理、插件版本管理；子模块定义依赖、定义插件。</p><p>父模块pom，子模块jar。</p><p>额外一个dependencies专门依赖版本管理模块为pom，并添加到父模块的dependencyManagement标签中。</p></blockquote><h1 id="3-一些问题"><a href="#3-一些问题" class="headerlink" title="3.一些问题"></a>3.一些问题</h1><p>1.如果我们本地有某个模块的jar包，然后idea中也有某个模块的jar包，会优先使用哪个？</p><p>答案是：如果modules管理了这个模块，就优先idea中的jar包；如果modules没有管理这个模块就使用本地jar包。</p><p>2.如果我们更新B模块代码然后立即一键打包，那么依赖B模块的A模块jar包中能得到最新的B模块代码吗？</p><p>答案是：不能。至于为什么我还没有找到说法，估计是maven为了优化打包速度导致的，没有代码改变的模块明显打包速度更快，导致打包的代码是上次缓存的代码，即同步性差。这样的话我们clean一下同步性就好了，咱就是手动删除缓存呗。</p><p>我们进一步说明一下这个问题：</p><p><strong>第一次打包</strong></p><p>这是第一次打包项目时的耗时输出：</p><p><img src="/2024/04/21/IDEA%E4%B8%ADmaven%E5%A4%9A%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%9C%BA%E5%88%B6/image-20240319193908727.png" alt="image-20240319193908727"></p><p>第一次<strong>backend模块打包：9 S左右，common模块2秒左右</strong>。</p><p>我们再查看一下backend模块依赖的common模块的jar包，内容如下：</p><p><img src="/2024/04/21/IDEA%E4%B8%ADmaven%E5%A4%9A%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%9C%BA%E5%88%B6/image-20240319194034527.png" alt="image-20240319194034527"></p><p>我们在IDEA更改一下common模块代码，然后立即再次打包package，且不进行clean（注意package不会包含clean操作的！！！网上有人误认子弟啊）。</p><p><img src="/2024/04/21/IDEA%E4%B8%ADmaven%E5%A4%9A%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%9C%BA%E5%88%B6/image-20240319194432201.png" alt="image-20240319194432201"></p><p><strong>第二次打包</strong></p><p>这次我们只更改了common模块代码，其它模块会感应到变化更新打包内容吗？不会**</p><p>这是第二次打包项目时的耗时输出：</p><p><img src="/2024/04/21/IDEA%E4%B8%ADmaven%E5%A4%9A%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%9C%BA%E5%88%B6/image-20240319194636006.png" alt="image-20240319194636006"></p><p>第二次<strong>backend模块打包：1 S左右，common模块2秒左右</strong>。</p><p>从时间上看也就知道了common模块代码变化了，打包时感应到了就完全<strong>重新打包</strong>；其它模块代码无变化，打包时就感应不到别的模块代码变化，就会<strong>缓存打包</strong>。即模块变化是隔离的，maven模块打包缓存清空是隔离的。</p><p>我们再查看一下backend模块依赖的common模块的jar包，内容如下：</p><p><img src="/2024/04/21/IDEA%E4%B8%ADmaven%E5%A4%9A%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%9C%BA%E5%88%B6/image-20240319195133738.png" alt="image-20240319195133738"></p><p>(⊙﹏⊙)代码没有变化。。。其它模块查看一下common的jar包同样如上图。</p><p>那么我们再查看一下common模块自己生成的jar包，内容如下：</p><p><img src="/2024/04/21/IDEA%E4%B8%ADmaven%E5%A4%9A%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%9C%BA%E5%88%B6/image-20240319195456880.png" alt="image-20240319195456880"></p><p>哇~找到了我们更新的代码</p><blockquote><p>所以，听话先clean再package，避免缓存生效，确保java代码和jar包代码的同步性。</p><p>或者我们不用idea的按钮了，直接控制台 mvn clean install package ‘-Dmaven.test.skip=true’。当然这样我们需要手动输入还要记忆命令**</p></blockquote><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><ol><li><strong>父模块依赖版本管理、插件版本管理、子模块版本管理</strong>；<strong>子模块定义依赖、定义插件</strong>。父模块pom，子模块jar。额外一个dependencies专门依赖版本管理模块为pom，并添加到父模块的dependencyManagement标签中。</li><li><strong>先clean再package</strong>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Security源码解析与实战（持续更新）</title>
      <link href="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
      <url>/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Spring Security是一个提供了<strong>认证、授权、常见攻击保护</strong>的框架。适用于非响应式、响应式编程的项目。是基于 <strong>Spring AOP</strong> 和 <strong>Servlet 过滤器</strong>的安全框架，提供全面的安全性解决方案。</p><p>Spring Security 中<a href="https://www.javaboy.org/2020/0617/authorize-springsecurity.html">四种常见的权限控制方式</a>。</p><ul><li>表达式控制 URL 路径权限</li><li>表达式控制方法权限</li><li>使用过滤注解</li><li>动态权限</li></ul><h1 id="一、过滤器解析"><a href="#一、过滤器解析" class="headerlink" title="一、过滤器解析"></a>一、过滤器解析</h1><p>过滤器链<strong>采用的是责任链的设计模式</strong>，它有一条很长的过滤器链。</p><h2 id="1-ChannelProcessingFilter"><a href="#1-ChannelProcessingFilter" class="headerlink" title="1.ChannelProcessingFilter"></a>1.ChannelProcessingFilter</h2><p>通常是用来过滤哪些请求必须用 https 协议， 哪些请求必须用 http协议， 哪些请求随便用哪个协议都行。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) req;</span><br><span class="line">   <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) res;</span><br><span class="line">   <span class="type">FilterInvocation</span> <span class="variable">filterInvocation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterInvocation</span>(request, response, chain);</span><br><span class="line">   Collection&lt;ConfigAttribute&gt; attributes = <span class="built_in">this</span>.securityMetadataSource.getAttributes(filterInvocation);</span><br><span class="line">   <span class="keyword">if</span> (attributes != <span class="literal">null</span>) &#123;</span><br><span class="line">      。。。日志</span><br><span class="line">      <span class="built_in">this</span>.channelDecisionManager.decide(filterInvocation, attributes);</span><br><span class="line">      <span class="keyword">if</span> (filterInvocation.getResponse().isCommitted()) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-WebAsyncManagerIntegrationFilter"><a href="#2-WebAsyncManagerIntegrationFilter" class="headerlink" title="2.WebAsyncManagerIntegrationFilter"></a>2.WebAsyncManagerIntegrationFilter</h2><p>用于<strong>集成 SecurityContext 到Spring异步执行机制中</strong>。通过 SecurityContextCallableProcessingInterceptor.beforeConcurrentHandling()就可以将 SecurityContext 传递给异步线程。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><br><span class="line">      <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">   <span class="comment">//1.获取 WebAsyncManager异步管理器</span></span><br><span class="line">   <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">   <span class="comment">//2.从异步管理器获取过滤器对应的SecurityContextCallableProcessingInterceptor</span></span><br><span class="line">   <span class="comment">// 检查异步管理器是否设置了此过滤器对应的SecurityContextCallableProcessingInterceptor，如果没有设置则会进行设置</span></span><br><span class="line">   <span class="type">SecurityContextCallableProcessingInterceptor</span> <span class="variable">securityProcessingInterceptor</span> <span class="operator">=</span> (SecurityContextCallableProcessingInterceptor) asyncManager</span><br><span class="line">         .getCallableInterceptor(CALLABLE_INTERCEPTOR_KEY);</span><br><span class="line">   <span class="comment">//3.如果为空，将新的 SecurityContextCallableProcessingInterceptor注册进去</span></span><br><span class="line">   <span class="keyword">if</span> (securityProcessingInterceptor == <span class="literal">null</span>) &#123;</span><br><span class="line">      asyncManager.registerCallableInterceptor(CALLABLE_INTERCEPTOR_KEY,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SecurityContextCallableProcessingInterceptor</span>());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//4.执行下一个过滤器 </span></span><br><span class="line">   filterChain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-SecurityContextPersistenceFilter"><a href="#3-SecurityContextPersistenceFilter" class="headerlink" title="3.SecurityContextPersistenceFilter"></a>3.SecurityContextPersistenceFilter</h2><p>主要<strong>控制 SecurityContext 的在一次请求中的生命周期</strong> 。请求来临时，创建SecurityContext 安全上下文信息，请求结束时清空 SecurityContextHolder 。</p><blockquote><p>请求 / 线程 &lt; 会话 &lt; 应用</p></blockquote><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="comment">//1.如果过滤器执行过一次则跳过此过滤器</span></span><br><span class="line">   <span class="keyword">if</span> (request.getAttribute(FILTER_APPLIED) != <span class="literal">null</span>) &#123;</span><br><span class="line">      chain.doFilter(request, response);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.设置请求属性 &quot;__spring_security_scpf_applied&quot; 为 true </span></span><br><span class="line">   request.setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">   。。。创建session</span><br><span class="line">   <span class="type">HttpRequestResponseHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpRequestResponseHolder</span>(request, response);</span><br><span class="line">   <span class="comment">//3.从 SecurityContextRepository 加载 SecurityContext，默认为HttpSessionSecurityContextRepository</span></span><br><span class="line">   <span class="comment">//如果SecurityContextRepository没有则创建一个新的。（从会话中获取SecurityContext供当前线程使用）</span></span><br><span class="line">   <span class="type">SecurityContext</span> <span class="variable">contextBeforeChainExecution</span> <span class="operator">=</span> <span class="built_in">this</span>.repo.loadContext(holder);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//4.设置 SecurityContext 到 SecurityContextHolder（设置ThreadLocal）</span></span><br><span class="line">      SecurityContextHolder.setContext(contextBeforeChainExecution);</span><br><span class="line">      。。。日志</span><br><span class="line">      <span class="comment">//5.继续执行下一个过滤器</span></span><br><span class="line">      chain.doFilter(holder.getRequest(), holder.getResponse());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//6.将SecurityContext保存到repo，并清空当前SecurityContextHolder（清理ThreadLocal）</span></span><br><span class="line">      <span class="type">SecurityContext</span> <span class="variable">contextAfterChainExecution</span> <span class="operator">=</span> SecurityContextHolder.getContext();</span><br><span class="line">      SecurityContextHolder.clearContext();</span><br><span class="line">      <span class="built_in">this</span>.repo.saveContext(contextAfterChainExecution, holder.getRequest(), holder.getResponse());</span><br><span class="line">      <span class="comment">//7.移除请求属性</span></span><br><span class="line">      request.removeAttribute(FILTER_APPLIED);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结以上出现的部件概念，如下：</p><ul><li><strong>SecurityContextRepository</strong>：负责<strong>保证在一个用户级会话的过程中，维护住相关的安全上下文信息</strong>。这个问题主要发生在web应用中，由于http的无状态性，所以每次request都需要重复加载安全上下文信息。默认情况下，将基于HTTP Session来完成这方面的工作。</li><li><strong>SecurityContext</strong>：安全上下文信息。</li><li><strong>SecurityContextHolder</strong>：<strong>维护一个线程的SecurityContext</strong>，用户请求处理过程中的各种程序调用能够使用到SecurityContext。默认使用线程变量机制，对于Web应用比较合适。如果是swing程序等，可以换用文件机制。</li></ul><blockquote><p>实现每次请求/每个线程设置 SecurityContextHolder 的 SecurityContext，并在结束后清理SecurityContextHolder 。</p></blockquote><h2 id="4-HeaderWriterFilter"><a href="#4-HeaderWriterFilter" class="headerlink" title="4.HeaderWriterFilter"></a>4.HeaderWriterFilter</h2><p>用于添加响应头，比如 X-Frame-Options（防止点击劫持） , X-XSSProtection（防止xss注入脚本攻击）， X-Content-Type-Options（防止基于 MIME 类型混淆的攻击）。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><br><span class="line">      <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">   <span class="comment">//1.查看过滤器属性为true(默认为false)，则在之前添加响应头 </span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.shouldWriteHeadersEagerly) &#123;</span><br><span class="line">      doHeadersBefore(request, response, filterChain);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//2.过滤器属性为false，则在之后添加响应头（这里使用了装饰者模式增强功能）</span></span><br><span class="line">      doHeadersAfter(request, response, filterChain);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doHeadersAfter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">//1.装饰 Response、Request</span></span><br><span class="line">    <span class="type">HeaderWriterResponse</span> <span class="variable">headerWriterResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeaderWriterResponse</span>(request, response);</span><br><span class="line">    <span class="type">HeaderWriterRequest</span> <span class="variable">headerWriterRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeaderWriterRequest</span>(request, headerWriterResponse);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//2.执行下一个过滤器</span></span><br><span class="line">        filterChain.doFilter(headerWriterRequest, headerWriterResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3.调用装饰后的响应对象方法写响应头</span></span><br><span class="line">        headerWriterResponse.writeHeaders();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真正的写响应头方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">writeHeaders</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">//调用过滤器属性 headerWriters来写响应头（过滤器属性在HeadersConfigurer中注入）</span></span><br><span class="line">    <span class="keyword">for</span> (HeaderWriter writer : <span class="built_in">this</span>.headerWriters) &#123;</span><br><span class="line">        writer.writeHeaders(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有如下 headerWriters 对象</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HeaderWriter&gt; <span class="title function_">getHeaderWriters</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;HeaderWriter&gt; writers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.contentTypeOptions.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.xssProtection.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.cacheControl.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.hsts.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.frameOptions.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.hpkp.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.contentSecurityPolicy.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.referrerPolicy.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.featurePolicy.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.permissionsPolicy.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.crossOriginOpenerPolicy.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.crossOriginEmbedderPolicy.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.crossOriginResourcePolicy.writer);</span><br><span class="line">    writers.addAll(<span class="built_in">this</span>.headerWriters);</span><br><span class="line">    <span class="keyword">return</span> writers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-CorsFilter"><a href="#5-CorsFilter" class="headerlink" title="5.CorsFilter"></a>5.CorsFilter</h2><p>跨域相关的过滤器。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">      FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">   <span class="comment">//1.从configSource属性获取 CorsConfiguration对象 </span></span><br><span class="line">   <span class="type">CorsConfiguration</span> <span class="variable">corsConfiguration</span> <span class="operator">=</span> <span class="built_in">this</span>.configSource.getCorsConfiguration(request);</span><br><span class="line">   <span class="comment">//2.使用 processor属性处理跨域</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">isValid</span> <span class="operator">=</span> <span class="built_in">this</span>.processor.processRequest(corsConfiguration, request, response);</span><br><span class="line">   <span class="comment">//3.一些跨域请求如option请求处理直接返回</span></span><br><span class="line">   <span class="keyword">if</span> (!isValid || CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//4.继续下一个过滤器 </span></span><br><span class="line">   filterChain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-LogoutFilter"><a href="#6-LogoutFilter" class="headerlink" title="6.LogoutFilter"></a>6.LogoutFilter</h2><p>注销过滤器，<strong>专门用于处理注销请求</strong>，默认处理的请求路径为/logout，否则则跳过此过滤器。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="comment">//1.根据请求和过滤器属性来决定是否进行注销过滤，如果是则执行过滤 </span></span><br><span class="line">   <span class="keyword">if</span> (requiresLogout(request, response)) &#123;</span><br><span class="line">      <span class="comment">//2.获取认证对象 </span></span><br><span class="line">      <span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">      <span class="comment">//3.处理注销 </span></span><br><span class="line">      <span class="built_in">this</span>.handler.logout(request, response, auth);</span><br><span class="line">      <span class="comment">//4.注销成功后处理 </span></span><br><span class="line">      <span class="built_in">this</span>.logoutSuccessHandler.onLogoutSuccess(request, response, auth);</span><br><span class="line">      <span class="comment">//5.返回 </span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.无需过滤的请求，执行下一个过滤器</span></span><br><span class="line">   chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">requiresLogout</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">//根据请求路径来匹配，若匹配则返回true</span></span><br><span class="line">    <span class="comment">// 先委托给AntPathRequestMatcher.matches(request)(处理类型匹配)，再委托给 SpringAntMatcher.matches(url)， //最后委托给AntPathMatcher.match(String pattern, String path)（处理路径匹配）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.logoutRequestMatcher.matches(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    。。。日志</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-ConcurrentSessionFilter"><a href="#7-ConcurrentSessionFilter" class="headerlink" title="7.ConcurrentSessionFilter"></a>7.ConcurrentSessionFilter</h2><p>用于同步SessionRegistry中注册的SessionInformation状态。1.从SessionRegistry获取 SessionInformation并检查是否过期2.每次请求就更新sessioninformation的时间。SessionRegistry默认使用内存对象 <code>SessionRegistryImpl</code> ，它是一个监听器监听session相关的事件然后注册到其内部。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="comment">//1.获取session对象</span></span><br><span class="line">   <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(<span class="literal">false</span>);</span><br><span class="line">   <span class="comment">//2.如果没有session就跳过此过滤器 （如禁用了session）</span></span><br><span class="line">   <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//3.从内存sessionRegistry中获取 SessionInformation</span></span><br><span class="line">      <span class="type">SessionInformation</span> <span class="variable">info</span> <span class="operator">=</span> <span class="built_in">this</span>.sessionRegistry.getSessionInformation(session.getId());</span><br><span class="line">      <span class="comment">//4.如果非空进行更新 </span></span><br><span class="line">      <span class="keyword">if</span> (info != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">//5.如果过期，执行登出</span></span><br><span class="line">         <span class="keyword">if</span> (info.isExpired()) &#123;</span><br><span class="line">            。。。日志</span><br><span class="line">            doLogout(request, response);</span><br><span class="line">            。。。发布登出事件</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//6.更新 SessionInformation时间</span></span><br><span class="line">         <span class="built_in">this</span>.sessionRegistry.refreshLastRequest(info.getSessionId());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//7.执行下一个过滤器</span></span><br><span class="line">   chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-UsernamePasswordAuthenticationFilter"><a href="#8-UsernamePasswordAuthenticationFilter" class="headerlink" title="8.UsernamePasswordAuthenticationFilter"></a>8.UsernamePasswordAuthenticationFilter</h2><p>处理<strong>用户以及密码认证</strong>的核心过滤器。认证请求提交的username 和 password 被封装成 <code>UsernamePasswordAuthenticationToken</code> 进行一系列的认证。 <code>UsernamePasswordAuthenticationToken</code> 实际上就是 <code>Authentication</code> 类型。</p><p>过滤器<strong>默认只会处理 <code>/login POST</code> 请求</strong>，可以配置请求路径。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   doFilter((HttpServletRequest) request, (HttpServletResponse) response, chain);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"><span class="comment">//1.不需要认证直接跳过过滤器（按请求路径和类型匹配）</span></span><br><span class="line">    <span class="keyword">if</span> (!requiresAuthentication(request, response)) &#123;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//2.进行认证</span></span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authenticationResult</span> <span class="operator">=</span> attemptAuthentication(request, response);</span><br><span class="line">        <span class="keyword">if</span> (authenticationResult == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        。。。</span><br><span class="line">        <span class="comment">//3.是否支持成功后继续执行过滤链，如果支持认证成功，继续下一个过滤</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.continueChainBeforeSuccessfulAuthentication) &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.认证成功后处理</span></span><br><span class="line">        successfulAuthentication(request, response, chain, authenticationResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;</span><br><span class="line">        <span class="comment">//5.异常后处理</span></span><br><span class="line">        unsuccessfulAuthentication(request, response, failed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AuthenticationException ex) &#123;</span><br><span class="line">        <span class="comment">//5.认证失败后处理</span></span><br><span class="line">        unsuccessfulAuthentication(request, response, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-doFilter方法"><a href="#4-1-doFilter方法" class="headerlink" title="4.1.doFilter方法"></a>4.1.doFilter方法</h3><p>AbstractAuthenticationProcessingFilter类有过滤器方法doFilter来过滤处理post方式的/login请求。</p><p>方法来源：由UsernamePasswordAuthenticationFilter组件直接调用，但本类没有此方法，调用继承的父类AbstractAuthenticationProcessingFilter方法。</p><p>方法逻辑：判断是否需要过滤、尝试认证、设置会话、认证成功处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractAuthenticationProcessingFilter类doFilter方法源码解析</span></span><br><span class="line"><span class="comment">//外部过滤器调用的方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">doFilter((HttpServletRequest) request, (HttpServletResponse) response, chain);<span class="comment">//方法重载调用私有doFilter方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内部真正调用重载方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">//1.判断是否需要过滤器处理，不需要跳过此过滤器。判断依据封装在requiresAuthentication，依据方法路径和类型判断。</span></span><br><span class="line">    <span class="keyword">if</span> (!requiresAuthentication(request, response)) &#123;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.尝试认证</span></span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">authenticationResult</span> <span class="operator">=</span> attemptAuthentication(request, response);</span><br><span class="line">    <span class="keyword">if</span> (authenticationResult == <span class="literal">null</span>) &#123;<span class="comment">//认证返回为null中止过滤链返回</span></span><br><span class="line">        <span class="comment">// return immediately as subclass has indicated that it hasn&#x27;t completed</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.认证成功后依据会话策略设置会话。在CompositeSessionAuthenticationStrategy中处理会话</span></span><br><span class="line">    <span class="built_in">this</span>.sessionStrategy.onAuthentication(authenticationResult, request, response);</span><br><span class="line">    <span class="comment">// Authentication success</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.continueChainBeforeSuccessfulAuthentication) &#123;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.认证成功处理</span></span><br><span class="line">    successfulAuthentication(request, response, chain, authenticationResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的比较重要的方法：</p><ul><li>attemptAuthentication</li><li>successfulAuthentication</li></ul><h3 id="4-2-attemptAuthentication方法"><a href="#4-2-attemptAuthentication方法" class="headerlink" title="4.2.attemptAuthentication方法"></a>4.2.attemptAuthentication方法</h3><p>UsernamePasswordAuthenticationFilter类通过attemptAuthentication方法来尝试认证，本质是认证前的一些处理并委托给authenticationManager进行认证。</p><p>方法来源：UsernamePasswordAuthenticationFilter类的doFilter调用。</p><p>方法逻辑：只处理post的认证请求，从请求中解析出用户名和密码，并使用UsernamePasswordAuthenticationToken类封装作为认证令牌，传入认证令牌并委托<strong>authenticationManager</strong>的authenticate方法进行认证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UsernamePasswordAuthenticationFilter类attemptAuthentication方法源码解析</span></span><br><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span><span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    <span class="comment">//1.只处理post请求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.postOnly &amp;&amp; !request.getMethod().equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationServiceException</span>(<span class="string">&quot;Authentication method not supported: &quot;</span> + request.getMethod());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.解析用户名和密码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> obtainUsername(request);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> obtainPassword(request);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//3.把用户名密码封装成UsernamePasswordAuthenticationToken认证令牌</span></span><br><span class="line">    <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(username, password);</span><br><span class="line">    <span class="comment">//4.为令牌设置Details</span></span><br><span class="line">    setDetails(request, authRequest);</span><br><span class="line">    <span class="comment">//5.委托给AuthenticationManager认证处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-ProviderManager类authenticate方法"><a href="#4-3-ProviderManager类authenticate方法" class="headerlink" title="4.3.ProviderManager类authenticate方法"></a>4.3.ProviderManager类authenticate方法</h3><p>ProviderManager类是==AuthenticationManager接口==的默认实现类，通过authenticate方法来实现多种认证方式尝试认证。</p><p>方法来源：来源于ProviderManager类，但UsernamePasswordAuthenticationFilter类attemptAuthentication方法是通过AuthenticationManager接口调用authenticate方法，故是通过<strong>多态</strong>实现了源于ProviderManager类的authenticate方法的调用。</p><p>方法逻辑：遍历所有的AuthenticationProvider进行认证provider.authenticate(authentication)。其中默认包含DaoAuthhenticationProvider组件。ProviderManager中管理了诸多用于认证的AuthenticationProvider组件。<strong>依据认证令牌的类型来使用不同的AuthenticationProvider（认证登录真正的逻辑）</strong>。这样spring security就通过ProviderManager扩展了登录认证的方式，具有良好的扩展性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ProviderManager类的authenticate方法</span></span><br><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    <span class="comment">//1.记录authentication认证令牌类的类型</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Authentication</span>&gt; toTest = authentication.getClass();</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">parentResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//2.依据令牌类型，遍历AuthenticationProvider来进行认证处理</span></span><br><span class="line">    <span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line">        <span class="comment">//3.判断是否能处理该类型令牌</span></span><br><span class="line">        <span class="keyword">if</span> (!provider.supports(toTest)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.委托DaoAuthenticationProvider来处理认证</span></span><br><span class="line">        result = provider.authenticate(authentication);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;<span class="comment">//认证成功复制details给result，并退出遍历循环</span></span><br><span class="line">            copyDetails(authentication, result);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父AuthenticationManager尝试机制</span></span><br><span class="line">     <span class="keyword">if</span> (result == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">         parentResult = <span class="built_in">this</span>.parent.authenticate(authentication);</span><br><span class="line">         result = parentResult;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//5.返回认证主体。去除密码信息</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.eraseCredentialsAfterAuthentication &amp;&amp; (result <span class="keyword">instanceof</span> CredentialsContainer)) &#123;</span><br><span class="line">            ((CredentialsContainer) result).eraseCredentials();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.没有获得认证后的主体，抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> lastException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-AbstractUserDetailsAuthenticationProvider类authenticate方法"><a href="#4-4-AbstractUserDetailsAuthenticationProvider类authenticate方法" class="headerlink" title="4.4.AbstractUserDetailsAuthenticationProvider类authenticate方法"></a>4.4.AbstractUserDetailsAuthenticationProvider类authenticate方法</h3><p>AbstractUserDetailsAuthenticationProvider类authenticate方法功能是登录认证使用数据库来认证用户名和密码。</p><p>方法来源：直接调用者是DaoAuthhenticationProvider组件。其继承了AbstractUserDetailsAuthenticationProvider，由于没有authenticate方法在本类中所以使用继承的父类authenticate方法。</p><p>方法逻辑：先从令牌中提取username，然后提供了用户信息本地缓存机制，然后查询数据库，然后检查查询到的结果（检查用户状态、检查密码、检查密码状态），然后添加缓存，然后按需求返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractUserDetailsAuthenticationProvider类authenticate方法源码解析</span></span><br><span class="line"><span class="comment">//其本质上充当/login的service层，实现了查询数据库用户信息、校验密码、返回</span></span><br><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> determineUsername(authentication);<span class="comment">//1.提取username</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">cacheWasUsed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> <span class="built_in">this</span>.userCache.getUserFromCache(username);<span class="comment">//2.查缓存</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheWasUsed = <span class="literal">false</span>;</span><br><span class="line">        user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);<span class="comment">//3.查数据库</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.preAuthenticationChecks.check(user);<span class="comment">//4.前置认证检查，检查用户状态信息（包括锁定状态、可用状态、过期状态），检查失败会递归调用retrieveUser然后再前置检查。</span></span><br><span class="line">    additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);<span class="comment">//4.密码检查</span></span><br><span class="line">    <span class="built_in">this</span>.postAuthenticationChecks.check(user);<span class="comment">//4.后置认证检查，检查密码过期状态。</span></span><br><span class="line">    <span class="keyword">if</span> (!cacheWasUsed) &#123;</span><br><span class="line"><span class="built_in">this</span>.userCache.putUserInCache(user);<span class="comment">//5.添加缓存用户信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">principalToReturn</span> <span class="operator">=</span> user;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.forcePrincipalAsString) &#123;</span><br><span class="line">        principalToReturn = user.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);<span class="comment">//6.依据用户信息等封装合法的主体信息结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的重要方法：</p><ul><li>retrieveUser</li><li>preAuthenticationChecks.check</li><li>additionalAuthenticationChecks</li><li>postAuthenticationChecks.check</li><li>createSuccessAuthentication</li></ul><h3 id="4-5-retrieveUser方法"><a href="#4-5-retrieveUser方法" class="headerlink" title="4.5.retrieveUser方法"></a>4.5.retrieveUser方法</h3><p>DaoAuthhenticationProvider中提供了查询数据库的方法retrieveUser。</p><p>方法来源：DaoAuthhenticationProvider组件。由AbstractUserDetailsAuthenticationProvider类authenticate方法调用。</p><p>方法逻辑：定时攻击保护、委托给<strong>UserDetailsService组件进行数据库查询</strong>包括用户信息和用户权限、用户名是否存在检查。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DaoAuthhenticationProvider类retrieveUser方法源码解析</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> UserDetails <span class="title function_">retrieveUser</span><span class="params">(String username, UsernamePasswordAuthenticationToken authentication)</span></span><br><span class="line"><span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    prepareTimingAttackProtection();<span class="comment">//1.定时攻击保护</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="type">UserDetails</span> <span class="variable">loadedUser</span> <span class="operator">=</span> <span class="built_in">this</span>.getUserDetailsService().loadUserByUsername(username);<span class="comment">//2.委托给UserDetailsService组件进行数据库查询用户信息，包括用户信息和用户权限</span></span><br><span class="line"><span class="keyword">if</span> (loadedUser == <span class="literal">null</span>) &#123;<span class="comment">//3.用户名是否存在检查</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalAuthenticationServiceException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> loadedUser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-createSuccessAuthentication方法"><a href="#4-6-createSuccessAuthentication方法" class="headerlink" title="4.6.createSuccessAuthentication方法"></a>4.6.createSuccessAuthentication方法</h3><p>DaoAuthhenticationProvider中提供了依据查询结果封装为Authentication认证后主体的方法createSuccessAuthentication。</p><p>方法来源：直接来源DaoAuthhenticationProvider，但同时方法本身调用了父类AbstractUserDetailsAuthenticationProvider的createSuccessAuthentication来最终生成Authentication。由（被）AbstractUserDetailsAuthenticationProvider类authenticate方法调用。</p><p>方法逻辑：1.依据查询到的userDetail创建认证后主体。2.设置认证后主体details。3.返回认证后主体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DaoAuthhenticationProvider类createSuccessAuthentication方法源码解析</span></span><br><span class="line"><span class="keyword">protected</span> Authentication <span class="title function_">createSuccessAuthentication</span><span class="params">(Object principal, Authentication authentication,UserDetails user)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.createSuccessAuthentication(principal, authentication, user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AbstractUserDetailsAuthenticationProvider类createSuccessAuthentication方法源码解析</span></span><br><span class="line"><span class="keyword">protected</span> Authentication <span class="title function_">createSuccessAuthentication</span><span class="params">(Object principal, Authentication authentication,UserDetails user)</span> &#123;</span><br><span class="line"><span class="comment">// Ensure we return the original credentials the user supplied,</span></span><br><span class="line"><span class="comment">// so subsequent attempts are successful even with encoded passwords.</span></span><br><span class="line"><span class="comment">// Also ensure we return the original getDetails(), so that future</span></span><br><span class="line"><span class="comment">// authentication events after cache expiry contain the details</span></span><br><span class="line">    <span class="comment">//1.依据查询到的userDetail创建认证后主体。</span></span><br><span class="line">    <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(principal,</span><br><span class="line">            authentication.getCredentials(), <span class="built_in">this</span>.authoritiesMapper.mapAuthorities(user.getAuthorities()));</span><br><span class="line">    <span class="comment">//2.设置认证后主体details</span></span><br><span class="line">    result.setDetails(authentication.getDetails());</span><br><span class="line">    <span class="built_in">this</span>.logger.debug(<span class="string">&quot;Authenticated user&quot;</span>);</span><br><span class="line">    <span class="comment">//3.返回</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-successfulAuthentication方法"><a href="#4-7-successfulAuthentication方法" class="headerlink" title="4.7.successfulAuthentication方法"></a>4.7.successfulAuthentication方法</h3><p>AbstractAuthenticationProcessingFilter类有方法successfulAuthentication来处理认证成功。</p><p>方法来源：AbstractAuthenticationProcessingFilter类。由AbstractAuthenticationProcessingFilter类的doFilter方法调用。</p><p>方法逻辑：1.初始化设置SecurityContextHolder和SecurityContext。2.通知rememberMeServices服务认证成功。3.发布认证成功消息。4.委托给AuthenticationSuccessHandler来处理认证成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractAuthenticationProcessingFilter类successfulAuthentication方法源码分析。</span></span><br><span class="line"><span class="comment">//默认初始化的认证成功处理器为SavedRequestAwareAuthenticationSuccessHandler</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">AuthenticationSuccessHandler</span> <span class="variable">successHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SavedRequestAwareAuthenticationSuccessHandler</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">successfulAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain,Authentication authResult)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">//1.初始化设置SecurityContextHolder和SecurityContext，将认证后主体保存到SecurityContextHolder中的SecurityContext中。</span></span><br><span class="line"><span class="type">SecurityContext</span> <span class="variable">context</span> <span class="operator">=</span> SecurityContextHolder.createEmptyContext();</span><br><span class="line">    context.setAuthentication(authResult);</span><br><span class="line">    SecurityContextHolder.setContext(context);</span><br><span class="line">   <span class="comment">//。。。</span></span><br><span class="line">    <span class="comment">//2.通知rememberMeServices服务认证成功</span></span><br><span class="line">    <span class="built_in">this</span>.rememberMeServices.loginSuccess(request, response, authResult);</span><br><span class="line">    <span class="comment">//3.发布认证成功消息</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.eventPublisher != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">InteractiveAuthenticationSuccessEvent</span>(authResult, <span class="built_in">this</span>.getClass()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.委托给AuthenticationSuccessHandler来处理认证成功。</span></span><br><span class="line">    <span class="built_in">this</span>.successHandler.onAuthenticationSuccess(request, response, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-8-子类onAuthenticationSuccess方法"><a href="#4-8-子类onAuthenticationSuccess方法" class="headerlink" title="4.8.子类onAuthenticationSuccess方法"></a>4.8.子类onAuthenticationSuccess方法</h3><p>SavedRequestAwareAuthenticationSuccessHandler类有方法onAuthenticationSuccess来处理认证成功。具体处理的是解析<strong>重定向到哪个url</strong>。即：认证后重定向到认证前url问题。</p><p>方法来源：SavedRequestAwareAuthenticationSuccessHandler类。由AbstractAuthenticationProcessingFilter类successfulAuthentication方法调用。</p><p>方法逻辑：1.获取对应认证请求缓存的认证前请求（即要访问的未认证请求）。2.没有缓存，调用父类方法返回配置的重定向url。3.是否配置重定向url在请求参数中或配置使用默认重定向url。调用父类方法返回配置的重定向url。4.获取缓存的重定向地址。5.重定向。总结：若从认证页面进行认证，则直接依据配置的默认重定向地址进行重定向；从未认证页面进行认证，则会重定向到未认证页面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SavedRequestAwareAuthenticationSuccessHandler类onAuthenticationSuccess方法源码解析</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response,Authentication authentication)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//1.获取对应认证请求缓存的认证前请求（即要访问的未认证请求）。</span></span><br><span class="line">    <span class="type">SavedRequest</span> <span class="variable">savedRequest</span> <span class="operator">=</span> <span class="built_in">this</span>.requestCache.getRequest(request, response);</span><br><span class="line">    <span class="comment">//2.没有缓存，调用父类方法返回配置的重定向url。</span></span><br><span class="line">    <span class="keyword">if</span> (savedRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">super</span>.onAuthenticationSuccess(request, response, authentication);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.是否配置重定向url在请求参数中或配置使用默认重定向url。调用父类方法返回配置的重定向url。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">targetUrlParameter</span> <span class="operator">=</span> getTargetUrlParameter();</span><br><span class="line">    <span class="keyword">if</span> (isAlwaysUseDefaultTargetUrl()</span><br><span class="line">            || (targetUrlParameter != <span class="literal">null</span> &amp;&amp; StringUtils.hasText(request.getParameter(targetUrlParameter)))) &#123;</span><br><span class="line">        <span class="built_in">this</span>.requestCache.removeRequest(request, response);</span><br><span class="line">        <span class="built_in">super</span>.onAuthenticationSuccess(request, response, authentication);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    clearAuthenticationAttributes(request);</span><br><span class="line">    <span class="comment">// Use the DefaultSavedRequest URL</span></span><br><span class="line">    <span class="comment">//4.获取缓存的重定向地址。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">targetUrl</span> <span class="operator">=</span> savedRequest.getRedirectUrl();</span><br><span class="line">    <span class="comment">//5.重定向。</span></span><br><span class="line">    getRedirectStrategy().sendRedirect(request, response, targetUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-9-父类onAuthenticationSuccess方法"><a href="#4-9-父类onAuthenticationSuccess方法" class="headerlink" title="4.9.父类onAuthenticationSuccess方法"></a>4.9.父类onAuthenticationSuccess方法</h3><p>父类onAuthenticationSuccess方法源码解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleUrlAuthenticationSuccessHandler类onAuthenticationSuccess方法源码解析</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleUrlAuthenticationSuccessHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstractAuthenticationTargetUrlRequestHandler</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationSuccessHandler</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response,Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//处理认证成功</span></span><br><span class="line">handle(request, response, authentication);</span><br><span class="line">clearAuthenticationAttributes(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractAuthenticationTargetUrlRequestHandler类haanle方法源码解析</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">//1.确定重新url</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">targetUrl</span> <span class="operator">=</span> determineTargetUrl(request, response, authentication);</span><br><span class="line">   <span class="comment">//。。。</span></span><br><span class="line">    <span class="comment">//2.重定向到目标url</span></span><br><span class="line">    <span class="built_in">this</span>.redirectStrategy.sendRedirect(request, response, targetUrl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AbstractAuthenticationTargetUrlRequestHandler类determineTargetUrl方法源码解析</span></span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">determineTargetUrl</span><span class="params">(HttpServletRequest request, HttpServletResponse response,Authentication authentication)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> determineTargetUrl(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">determineTargetUrl</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">//1.检查配置一直使用默认重定向地址，直接返回默认重定向地址</span></span><br><span class="line">    <span class="keyword">if</span> (isAlwaysUseDefaultTargetUrl()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.defaultTargetUrl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check for the parameter and use that if available</span></span><br><span class="line">    <span class="comment">//2.检查配置请求参数中获取重定向地址，则返回请求参数中的重定向地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">targetUrl</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.targetUrlParameter != <span class="literal">null</span>) &#123;</span><br><span class="line">        targetUrl = request.getParameter(<span class="built_in">this</span>.targetUrlParameter);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(targetUrl)) &#123;</span><br><span class="line">            <span class="keyword">return</span> targetUrl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.检查配置请求头Referer获取重定向地址</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.useReferer &amp;&amp; !StringUtils.hasLength(targetUrl)) &#123;</span><br><span class="line">        targetUrl = request.getHeader(<span class="string">&quot;Referer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.没有获取到重定向地址，直接复制默认重定向地址</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(targetUrl)) &#123;</span><br><span class="line">        targetUrl = <span class="built_in">this</span>.defaultTargetUrl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.返回</span></span><br><span class="line">    <span class="keyword">return</span> targetUrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-10-详细的认证流程时序图"><a href="#4-10-详细的认证流程时序图" class="headerlink" title="4.10.详细的认证流程时序图"></a>4.10.详细的认证流程时序图</h3><p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/springsecurity%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90.png" alt="springsecurity认证过程分析"></p><blockquote><p>HttpSecurity.formLogin()注入过滤器，实现了指定路径认证过滤其它路径跳过此过滤器。</p></blockquote><h2 id="9-RequestCacheAwareFilter"><a href="#9-RequestCacheAwareFilter" class="headerlink" title="9.RequestCacheAwareFilter"></a>9.RequestCacheAwareFilter</h2><p>用于<strong>缓存未认证成功的请求</strong>。且<a href="https://juejin.cn/post/7273758446113128502#heading-1">默认只能缓存 GET 类型请求</a>，在异常处理过滤器中执行缓存，在账号密码登录过滤器认证成功时使用缓存重定向到缓存的请求。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="comment">//1.从缓存中获取 与当前请求匹配的保存的 wrappedSavedRequest</span></span><br><span class="line">   <span class="type">HttpServletRequest</span> <span class="variable">wrappedSavedRequest</span> <span class="operator">=</span> <span class="built_in">this</span>.requestCache.getMatchingRequest((HttpServletRequest) request, (HttpServletResponse) response);</span><br><span class="line">   <span class="comment">//2.如果获取不到，则该过滤器无效；如果获取到了则执行缓存的请求 </span></span><br><span class="line">   chain.doFilter((wrappedSavedRequest != <span class="literal">null</span>) ? wrappedSavedRequest : request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-SecurityContextHolderAwareRequestFilter"><a href="#10-SecurityContextHolderAwareRequestFilter" class="headerlink" title="10.SecurityContextHolderAwareRequestFilter"></a>10.SecurityContextHolderAwareRequestFilter</h2><p>包装原始请求和响应对象生成一个新的请求对象。<strong>增强了请求对象的能力</strong>、增加了功能。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="comment">//调用 HttpServlet3RequestFactory对象 包装请求和响应为 Servlet3SecurityContextHolderAwareRequestWrapper</span></span><br><span class="line">   chain.doFilter(<span class="built_in">this</span>.requestFactory.create((HttpServletRequest) req, (HttpServletResponse) res), res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//过滤器属性初始化完成后自动执行的方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="built_in">super</span>.afterPropertiesSet();</span><br><span class="line">    updateFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置过滤器的 requestFactory对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">rolePrefix</span> <span class="operator">=</span> <span class="built_in">this</span>.rolePrefix;</span><br><span class="line">    <span class="built_in">this</span>.requestFactory = createServlet3Factory(rolePrefix);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//底层创建的 HttpServlet3RequestFactory对象</span></span><br><span class="line"><span class="keyword">private</span> HttpServletRequestFactory <span class="title function_">createServlet3Factory</span><span class="params">(String rolePrefix)</span> &#123;</span><br><span class="line">    <span class="type">HttpServlet3RequestFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpServlet3RequestFactory</span>(rolePrefix);</span><br><span class="line">    factory.setTrustResolver(<span class="built_in">this</span>.trustResolver);</span><br><span class="line">    factory.setAuthenticationEntryPoint(<span class="built_in">this</span>.authenticationEntryPoint);</span><br><span class="line">    factory.setAuthenticationManager(<span class="built_in">this</span>.authenticationManager);</span><br><span class="line">    factory.setLogoutHandlers(<span class="built_in">this</span>.logoutHandlers);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-RememberMeAuthenticationFilter"><a href="#11-RememberMeAuthenticationFilter" class="headerlink" title="11.RememberMeAuthenticationFilter"></a>11.RememberMeAuthenticationFilter</h2><p>记住我认证过滤器。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="comment">//1.如果已经认证成功，则跳过此过滤器 </span></span><br><span class="line">   <span class="keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() != <span class="literal">null</span>) &#123;</span><br><span class="line">      。。。日志</span><br><span class="line">      chain.doFilter(request, response);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.调用 rememberMeServices获取 Authentication待认证&quot;token&quot;对象</span></span><br><span class="line">   <span class="type">Authentication</span> <span class="variable">rememberMeAuth</span> <span class="operator">=</span> <span class="built_in">this</span>.rememberMeServices.autoLogin(request, response);</span><br><span class="line">   <span class="comment">//3.非空执行rememberMe认证</span></span><br><span class="line">   <span class="keyword">if</span> (rememberMeAuth != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//认证 </span></span><br><span class="line">         rememberMeAuth = <span class="built_in">this</span>.authenticationManager.authenticate(rememberMeAuth);</span><br><span class="line">         <span class="type">SecurityContext</span> <span class="variable">context</span> <span class="operator">=</span> SecurityContextHolder.createEmptyContext();</span><br><span class="line">         context.setAuthentication(rememberMeAuth);</span><br><span class="line">         SecurityContextHolder.setContext(context);</span><br><span class="line">         <span class="comment">//认证成功处理</span></span><br><span class="line">         onSuccessfulAuthentication(request, response, rememberMeAuth);</span><br><span class="line">         。。。日志</span><br><span class="line">         <span class="built_in">this</span>.securityContextRepository.saveContext(context, request, response);</span><br><span class="line">         。。。发布事件</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">this</span>.successHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//认证成功处理 </span></span><br><span class="line">            <span class="built_in">this</span>.successHandler.onAuthenticationSuccess(request, response, rememberMeAuth);</span><br><span class="line">            <span class="comment">//4.返回 </span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (AuthenticationException ex) &#123;</span><br><span class="line">         。。。日志</span><br><span class="line">         <span class="comment">//认证失败处理    </span></span><br><span class="line">         <span class="built_in">this</span>.rememberMeServices.loginFail(request, response);</span><br><span class="line">         onUnsuccessfulAuthentication(request, response, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//4.执行下一个过滤器 </span></span><br><span class="line">   chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>已认证跳过，rememberMeServices.autoLogin(request, response)返回空跳过，否组执行rememberMe认证。</p></blockquote><h2 id="12-AnonymousAuthenticationFilter"><a href="#12-AnonymousAuthenticationFilter" class="headerlink" title="12.AnonymousAuthenticationFilter"></a>12.AnonymousAuthenticationFilter</h2><p>匿名登录认证过滤器，未认证设置一个匿名认证对象到SecurityContextHolder。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="comment">//1.如果没有经过认证，创建一个匿名的Authentication认证对象设置到SecurityContextHolder。</span></span><br><span class="line">   <span class="keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> createAuthentication((HttpServletRequest) req);</span><br><span class="line">      <span class="type">SecurityContext</span> <span class="variable">context</span> <span class="operator">=</span> SecurityContextHolder.createEmptyContext();</span><br><span class="line">      context.setAuthentication(authentication);</span><br><span class="line">      SecurityContextHolder.setContext(context);</span><br><span class="line">      。。。日志</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      。。。日志</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.继续下一个过滤器</span></span><br><span class="line">   chain.doFilter(req, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-SessionManagementFilter"><a href="#13-SessionManagementFilter" class="headerlink" title="13.SessionManagementFilter"></a>13.SessionManagementFilter</h2><p>Session 管理器过滤器，内部维护了一个SessionAuthenticationStrategy 用于管理 Session。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="comment">//1.如果已被调用过跳过过滤器 </span></span><br><span class="line">   <span class="keyword">if</span> (request.getAttribute(FILTER_APPLIED) != <span class="literal">null</span>) &#123;</span><br><span class="line">      chain.doFilter(request, response);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.设置请求属性已调用 </span></span><br><span class="line">   request.setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">   <span class="comment">//3.如果 securityContextRepository 没有该请求对应的 securityContext，就需要进行处理</span></span><br><span class="line">   <span class="keyword">if</span> (!<span class="built_in">this</span>.securityContextRepository.containsContext(request)) &#123;</span><br><span class="line">      <span class="comment">//4.获取已认证的Authentication对象 </span></span><br><span class="line">      <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">      <span class="comment">//5.如果已认证，会话认证策略对象 进行相关处理（比如同一用户并发的会话/同时登录会话处理、比如会话对象是否存在、比如更  //  改会话sessionid）</span></span><br><span class="line">       <span class="keyword">if</span> (authentication != <span class="literal">null</span> &amp;&amp; !<span class="built_in">this</span>.trustResolver.isAnonymous(authentication)) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//会话处理 </span></span><br><span class="line">            <span class="built_in">this</span>.sessionAuthenticationStrategy.onAuthentication(authentication, request, response);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (SessionAuthenticationException ex) &#123;</span><br><span class="line">            <span class="comment">//会话拒绝了认证对象，处理认证失败</span></span><br><span class="line">            SecurityContextHolder.clearContext();</span><br><span class="line">            <span class="built_in">this</span>.failureHandler.onAuthenticationFailure(request, response, ex);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//存储 SecurityContext 到securityContextRepository</span></span><br><span class="line">         <span class="built_in">this</span>.securityContextRepository.saveContext(SecurityContextHolder.getContext(), request, response);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//5.如果会话失效，则 会话失效策略对象 执行失效逻辑</span></span><br><span class="line">         <span class="keyword">if</span> (request.getRequestedSessionId() != <span class="literal">null</span> &amp;&amp; !request.isRequestedSessionIdValid()) &#123;</span><br><span class="line">            。。。日志</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.invalidSessionStrategy != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="built_in">this</span>.invalidSessionStrategy.onInvalidSessionDetected(request, response);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//4.执行下一个过滤器 </span></span><br><span class="line">   chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对会话相关进行处理。只有当前请求没有存储 securityContext 时才会进行会话处理。<strong>即是否存储好 securityContext 到会话级别标志着会话是否进行了处理</strong>。</p><p>认证会话处理可以包括许多内容：如更改会话id防止攻击、检查会话对象是否存在、同一用户多个会话处理等等。</p></blockquote><h2 id="14-ExceptionTranslationFilter"><a href="#14-ExceptionTranslationFilter" class="headerlink" title="14.ExceptionTranslationFilter"></a>14.ExceptionTranslationFilter</h2><p>主要来<strong>捕获异常进行合理的处理</strong>，传输异常事件。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//1.继续执行下一个过滤器</span></span><br><span class="line">      chain.doFilter(request, response);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">     。。。</span><br><span class="line">      <span class="comment">//2.处理异常</span></span><br><span class="line">     handleSpringSecurityException(request, response, chain, securityException);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleSpringSecurityException</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">        FilterChain chain, RuntimeException exception)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">//1.如果是未认证异常，委托给handleAuthenticationException</span></span><br><span class="line">    <span class="comment">// AuthenticationEntryPoint组件处理</span></span><br><span class="line">    <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> AuthenticationException) &#123;</span><br><span class="line">        handleAuthenticationException(request, response, chain, (AuthenticationException) exception);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.如果是权限异常，委托给handleAccessDeniedException</span></span><br><span class="line">    <span class="comment">// AccessDeniedHandler组件处理</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> AccessDeniedException) &#123;</span><br><span class="line">        handleAccessDeniedException(request, response, chain, (AccessDeniedException) exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>合理的异常响应返回需要我们配置AuthenticationEntryPoint、AccessDeniedHandler组件。</p></blockquote><h2 id="15-FilterSecurityInterceptor（重点）"><a href="#15-FilterSecurityInterceptor（重点）" class="headerlink" title="15.FilterSecurityInterceptor（重点）"></a>15.FilterSecurityInterceptor（重点）</h2><p><strong>过滤web请求并在拒绝请求时抛出异常</strong>。这个<strong>过滤器</strong>决定了访问特定<strong>路径</strong>应该具备的权限，如果要实现动态权限控制就必须研究该类 。<strong>只处理过滤器层面的权限控制，并不处理注解AOP层面的权限控制</strong>。</p><p>其主要过程为：拦截<code>Authentication</code>对”secured object”的访问，依据“<strong>安全元信息属性</strong>”列表来决定<code>Authentication</code>对象是否可以访问”secured object”。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   invoke(<span class="keyword">new</span> <span class="title class_">FilterInvocation</span>(request, response, chain));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(FilterInvocation filterInvocation)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">//1.不是第一次执行，跳过此过滤器</span></span><br><span class="line">    <span class="keyword">if</span> (isApplied(filterInvocation) &amp;&amp; <span class="built_in">this</span>.observeOncePerRequest) &#123;</span><br><span class="line">        filterInvocation.getChain().doFilter(filterInvocation.getRequest(), filterInvocation.getResponse());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.第一次执行，设置请求属性 __spring_security_filterSecurityInterceptor_filterApplied 为true</span></span><br><span class="line">    <span class="keyword">if</span> (filterInvocation.getRequest() != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.observeOncePerRequest) &#123;</span><br><span class="line">        filterInvocation.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.委托 beforeInvocation 执行“鉴权”过滤逻辑</span></span><br><span class="line">    <span class="type">InterceptorStatusToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="built_in">super</span>.beforeInvocation(filterInvocation);</span><br><span class="line">    <span class="comment">//4.过滤结束，执行下一个过滤器</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        filterInvocation.getChain().doFilter(filterInvocation.getRequest(), filterInvocation.getResponse());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//5.请求调用结束后执行</span></span><br><span class="line">        <span class="built_in">super</span>.finallyInvocation(token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.请求调用完成后执行</span></span><br><span class="line">    <span class="built_in">super</span>.afterInvocation(token, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>AbstractSecurityInterceptor</code>中已经规划了安全控制过程的抽象</strong>，<code>FilterSecurityInterceptor</code>是针对<strong>web request</strong>的基于filter技术实现，<code>MethodSecurityInterceptor</code>和<code>AspectJMethodSecurityInterceptor</code>是针对<strong>method invocation</strong>的基于两种java aop技术实现。</p><p>组件关系类图如下：</p><p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20240224223030340.png" alt="image-20240224223030340"></p><p><strong><code>AbstractSecurityInterceptor</code>中的抽象过程基本如下</strong>：</p><ol><li>寻找关联当前“secure object”的配置属性（“configuration attributes”）</li><li><strong>把<code>authentication</code>\secure object\configuration attributes提交给<code>AccessDecisionManager</code>.decide()</strong></li><li>可以在此机会对Authentication对象进行变更</li><li>如果授权成功，则允许请求\调用继续往下进行</li><li>如果配置了<code>AfterInvocaitonManager</code>，那么就调用该管理器的相关操作</li></ol><p><strong>而 AccessDecisionManager.decide()又委托给多个Voter去vote()，然后AccessDecisionManager综合意见返回。</strong></p><p>AccessDecisionManager有一个抽象实现类AbstractAccessDecisionManager，这个抽象实现面向了一种vote机制，其中维护了一个vote器列表。</p><p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20240224225955647.png" alt="image-20240224225955647"></p><p><code>AbstractAccessDecisionManager</code>的子类专注于一件事情：从它的vote器们的vote结果中决定，是否最终给予授权。不同的子类实现了不同的决策策略：</p><ol><li><code>AffirmativeBased</code>：任何一个vote器给予ACCESS_GRANTED，那么最终结果就给予授权；否则不授权；</li><li><code>ConsensusBased</code>：按少数服从多数策略，给予授权决定；</li><li><code>UnanimousBased</code>：一Piao否决制。</li><li>注意全部弃权票委托给抽象类方法checkAllowIfAllAbstainDecisions()来处理。</li></ol><h3 id="10-1-doFilter方法"><a href="#10-1-doFilter方法" class="headerlink" title="10.1.doFilter方法"></a>10.1.doFilter方法</h3><p>FilterSecurityInterceptor类方法doFilter来实现过滤处理。</p><p>方法来源：FilterSecurityInterceptor类</p><p>方法逻辑：封装一下方法参数为FilterInvocation转发给本类invoke方法处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FilterSecurityInterceptor类doFilter方法源码分析</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">invoke(<span class="keyword">new</span> <span class="title class_">FilterInvocation</span>(request, response, chain));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-2-invoke方法"><a href="#10-2-invoke方法" class="headerlink" title="10.2.invoke方法"></a>10.2.invoke方法</h3><p>FilterSecurityInterceptor类方法invoke来实现过滤处理。</p><p>方法来源：FilterSecurityInterceptor类</p><p>方法逻辑：1.检查是否已经经过安全校验（对于该用户的该请求）2.设置请求属性已安全校验3.过滤器访问控制前处理（即处理其它后续过滤器前<strong>该过滤器的前处理</strong>）4.放行给下一个过滤器处理5.请求调用后处理6.过滤器后处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FilterSecurityInterceptor类invoke方法源码分析</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(FilterInvocation filterInvocation)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"><span class="comment">//1.检查是否已经经过安全校验（对于该用户的该请求）</span></span><br><span class="line">    <span class="keyword">if</span> (isApplied(filterInvocation) &amp;&amp; <span class="built_in">this</span>.observeOncePerRequest) &#123;</span><br><span class="line">        filterInvocation.getChain().doFilter(filterInvocation.getRequest(), filterInvocation.getResponse());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.设置请求属性已安全校验</span></span><br><span class="line">    <span class="keyword">if</span> (filterInvocation.getRequest() != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.observeOncePerRequest) &#123;</span><br><span class="line">        filterInvocation.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.过滤器访问控制前处理</span></span><br><span class="line">    <span class="type">InterceptorStatusToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="built_in">super</span>.beforeInvocation(filterInvocation);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//4.放行给下一个过滤器处理</span></span><br><span class="line">        filterInvocation.getChain().doFilter(filterInvocation.getRequest(), filterInvocation.getResponse());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//5.请求调用后处理，由于位于finally代码块，即使请求调用异常该方法仍然执行。</span></span><br><span class="line">        <span class="built_in">super</span>.finallyInvocation(token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.过滤器后处理</span></span><br><span class="line">    <span class="built_in">super</span>.afterInvocation(token, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的重要方法：</p><ul><li>beforeInvocation</li><li>finallyInvocation</li><li>afterInvocation</li></ul><h3 id="10-3-beforeInvocation方法-鉴权核心"><a href="#10-3-beforeInvocation方法-鉴权核心" class="headerlink" title="10.3.beforeInvocation方法(鉴权核心)"></a>10.3.beforeInvocation方法(鉴权核心)</h3><p>AbstractSecurityInterceptor类beforeInvocation方法来进行安全检查校验权限。</p><p>方法来源：FilterSecurityInterceptor类的父类AbstractSecurityInterceptor。直接由FilterSecurityInterceptor调用super.beforeInvocation来调用父类的方法。</p><p>方法逻辑：1.查询获取配置的匹配该请求的权限规则2.无权限规则，则返回null3.校验是否已经认证，未认证抛出异常4.从SecurityContextHolder获取认证主体5.尝试授权6.返回一个封装SecurityContext、请求的安全规则、请求的InterceptorStatusToken</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractSecurityInterceptor类beforeInvocation方法源码分析</span></span><br><span class="line"><span class="keyword">protected</span> InterceptorStatusToken <span class="title function_">beforeInvocation</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="comment">//1.从DefaultFilterInvocationSecurityMetadataSource中查询获取配置的匹配该请求的权限规则</span></span><br><span class="line">Collection&lt;ConfigAttribute&gt; attributes = <span class="built_in">this</span>.obtainSecurityMetadataSource().getAttributes(object);</span><br><span class="line">    <span class="comment">//2.无权限规则，则返回null</span></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(attributes)) &#123;</span><br><span class="line">        publishEvent(<span class="keyword">new</span> <span class="title class_">PublicInvocationEvent</span>(object));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// no further work post-invocation</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.校验是否已经认证，未认证抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() == <span class="literal">null</span>) &#123;</span><br><span class="line">credentialsNotFound(<span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;AbstractSecurityInterceptor.authenticationNotFound&quot;</span>,<span class="string">&quot;An Authentication object was not found in the SecurityContext&quot;</span>), object, attributes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.从SecurityContextHolder获取认证主体</span></span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">authenticated</span> <span class="operator">=</span> authenticateIfRequired();</span><br><span class="line">    <span class="comment">//5.尝试授权</span></span><br><span class="line">    attemptAuthorization(object, attributes, authenticated);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.publishAuthorizationSuccess) &#123;<span class="comment">//发布授权成功</span></span><br><span class="line">        publishEvent(<span class="keyword">new</span> <span class="title class_">AuthorizedEvent</span>(object, attributes, authenticated));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//默认runAsManager什么都不做返回null,可以自定义runAsManager</span></span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">runAs</span> <span class="operator">=</span> <span class="built_in">this</span>.runAsManager.buildRunAs(authenticated, object, attributes);</span><br><span class="line">    <span class="keyword">if</span> (runAs != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">SecurityContext</span> <span class="variable">origCtx</span> <span class="operator">=</span> SecurityContextHolder.getContext();</span><br><span class="line">        <span class="type">SecurityContext</span> <span class="variable">newCtx</span> <span class="operator">=</span> SecurityContextHolder.createEmptyContext();</span><br><span class="line">        newCtx.setAuthentication(runAs);</span><br><span class="line">        SecurityContextHolder.setContext(newCtx);</span><br><span class="line">        <span class="comment">// need to revert to token.Authenticated post-invocation</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InterceptorStatusToken</span>(origCtx, <span class="literal">true</span>, attributes, object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.返回一个封装SecurityContext、请求的安全规则、请求的InterceptorStatusToken</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InterceptorStatusToken</span>(SecurityContextHolder.getContext(), <span class="literal">false</span>, attributes, object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的重要方法：</p><ul><li>getAttributes</li><li>attemptAuthorization</li></ul><h3 id="10-4-getAttributes方法"><a href="#10-4-getAttributes方法" class="headerlink" title="10.4.getAttributes方法"></a>10.4.getAttributes方法</h3><p>DefaultFilterInvocationSecurityMetadataSource类方法getAttributes来获取配置的该请求映射的安全规则集合。</p><p>方法来源：直接来源于DefaultFilterInvocationSecurityMetadataSource类。但由AbstractSecurityInterceptor类beforeInvocation方法调用，且调用时是基于<strong>SecurityMetadataSource接口</strong>调用具有<strong>多态</strong>的特性。默认使用该DefaultFilterInvocationSecurityMetadataSource类。</p><p>方法逻辑：1.获取请求2.遍历requestMap（代码生成）获取匹配该请求的权限规则3.没有相关权限规则返回null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultFilterInvocationSecurityMetadataSource类getAttributes方法源码解析</span></span><br><span class="line"><span class="keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="title function_">getAttributes</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="comment">//1.获取请求</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ((FilterInvocation) object).getRequest();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//2.遍历requestMap（代码生成）获取匹配该请求的安全规则</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;RequestMatcher, Collection&lt;ConfigAttribute&gt;&gt; entry : <span class="built_in">this</span>.requestMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getKey().matches(request)) &#123;</span><br><span class="line">            <span class="keyword">return</span> entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) &#123;<span class="comment">//日志打印不匹配的信息</span></span><br><span class="line">                <span class="built_in">this</span>.logger.trace(LogMessage.format(<span class="string">&quot;Did not match request to %s - %s (%d/%d)&quot;</span>, entry.getKey(),</span><br><span class="line">                        entry.getValue(), ++count, <span class="built_in">this</span>.requestMap.size()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.没有相关安全规则返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-5attemptAuthorization方法"><a href="#10-5attemptAuthorization方法" class="headerlink" title="10.5attemptAuthorization方法"></a>10.5attemptAuthorization方法</h3><p>AbstractSecurityInterceptor类方法attemptAuthorization来委托accessDecisionManager进行<strong>权限检查</strong>，即比对用户拥有的权限和访问该方法需要符合的安全规则。<strong>无权限就抛异常结束过滤器的处理</strong>。</p><p>方法来源：AbstractSecurityInterceptor类，由AbstractSecurityInterceptor类beforeInvocation方法调用。</p><p>方法逻辑：1.委托accessDecisionManager进行授权决策，无法授权就抛出异常2.异常时打印日志3.异常时发布授权失败消息4.再次抛出原异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractSecurityInterceptor类attemptAuthorization方法源码解析</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">attemptAuthorization</span><span class="params">(Object object, Collection&lt;ConfigAttribute&gt; attributes,</span></span><br><span class="line"><span class="params">        Authentication authenticated)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.委托accessDecisionManager进行授权决策，无法授权就抛出异常</span></span><br><span class="line">        <span class="built_in">this</span>.accessDecisionManager.decide(authenticated, object, attributes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AccessDeniedException ex) &#123;</span><br><span class="line">        <span class="comment">//2.打印Trace日志</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.trace(LogMessage.format(<span class="string">&quot;Failed to authorize %s with attributes %s using %s&quot;</span>, object,</span><br><span class="line">                    attributes, <span class="built_in">this</span>.accessDecisionManager));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.打印Debug日志</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.debug(LogMessage.format(<span class="string">&quot;Failed to authorize %s with attributes %s&quot;</span>, object, attributes));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.发布授权失败消息</span></span><br><span class="line">        publishEvent(<span class="keyword">new</span> <span class="title class_">AuthorizationFailureEvent</span>(object, attributes, authenticated, ex));</span><br><span class="line">        <span class="comment">//4.再次抛出原异常</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-6-decide方法"><a href="#10-6-decide方法" class="headerlink" title="10.6.decide方法"></a>10.6.decide方法</h3><p>AffirmativeBased类方法decide来进行授权决策（几个投票者如何投票代表成功授权），即解析该主体对该请求的访问权限。而AffirmativeBased是一种解析策略。</p><p>方法来源：默认调用AffirmativeBased类的decide。但此方法是源于AbstractSecurityInterceptor的attemptAuthorization方法调用，调用也是基于<strong>AccessDecisionManager接口</strong>调用，即this.accessDecisionManager.decide。</p><p>方法逻辑：1.遍历所有DecisionVoters来让它们投票，一旦有人投赞成票则授权成功（即有一种类型的配置权限合法）2.没有赞成票时，否定票&gt;0，授权失败抛出异常3.所有人弃权，依据配置AllowIfAllAbstainDecisions来决定是否授权成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decide</span><span class="params">(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes)</span><span class="keyword">throws</span> AccessDeniedException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">deny</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1.遍历所有DecisionVoters来让它们投票，一旦有人投赞成票则授权成功</span></span><br><span class="line">    <span class="keyword">for</span> (AccessDecisionVoter voter : getDecisionVoters()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> voter.vote(authentication, object, configAttributes);<span class="comment">//重要调用方法</span></span><br><span class="line">        <span class="keyword">switch</span> (result) &#123;</span><br><span class="line">        <span class="keyword">case</span> AccessDecisionVoter.ACCESS_GRANTED:</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//授权成功</span></span><br><span class="line">        <span class="keyword">case</span> AccessDecisionVoter.ACCESS_DENIED:</span><br><span class="line">            deny++;<span class="comment">//计数否定票</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.没有赞成票时，否定票&gt;0，授权失败抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (deny &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccessDeniedException</span>(</span><br><span class="line">                <span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;AbstractAccessDecisionManager.accessDenied&quot;</span>, <span class="string">&quot;Access is denied&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//3.所有人弃权，依据配置AllowIfAllAbstainDecisions来决定是否授权成功</span></span><br><span class="line">    checkAllowIfAllAbstainDecisions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AffirmativeBased默认包括的所有voters</strong>:</p><ul><li>PreInvocationAuthorizationAdviceVoter</li><li>RoleVoter</li><li>AuthenticatedVoter</li></ul><p>重要调用方法：voter.vote</p><h3 id="10-7-vote方法"><a href="#10-7-vote方法" class="headerlink" title="10.7.vote方法"></a>10.7.vote方法</h3><p>WebExpressionVoter类方法vote会执行真正的权限投票（权限对比检查）。</p><p>注意：在<strong>WebSecurityConfigurerAdapter子类配置的权限规则</strong>会被封装为WebExpressionConfigAttribute由<strong>WebExpressionVoter</strong>来进行处理；<strong>注解配置的权限规则</strong>会被封装成PreInvocationAttribute由<strong>PreInvocationAuthorizationAdviceVoter</strong>来进行处理；带“ROLE_”前缀的会被<strong>RoleVoter</strong>进行处理。</p><p>方法来源：WebExpressionVoter类。由AffirmativeBased类的decide方法调用。基于接口AccessDecisionVoter调用。</p><p>方法逻辑：1.从权限规则集合中提取该投票者能处理的权限规则2.没找到符合的返回弃权（没有使用该方法配置权限）3.构造EL表达式上下文4.使用ExpressionUtils工具类来判断EL表达式的值5.EL表达式为true返回授权成功6.否则返回授权失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WebExpressionVoter类vote方法源代码分析</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">vote</span><span class="params">(Authentication authentication, FilterInvocation filterInvocation,</span></span><br><span class="line"><span class="params">Collection&lt;ConfigAttribute&gt; attributes)</span> &#123;</span><br><span class="line">    <span class="comment">//1.从权限规则集合中提取该投票者能处理的权限规则，即获取http配置项</span></span><br><span class="line">    <span class="type">WebExpressionConfigAttribute</span> <span class="variable">webExpressionConfigAttribute</span> <span class="operator">=</span> findConfigAttribute(attributes);</span><br><span class="line">    <span class="comment">//2.没找到符合的返回弃权</span></span><br><span class="line">    <span class="keyword">if</span> (webExpressionConfigAttribute == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ACCESS_ABSTAIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.构造EL表达式上下文</span></span><br><span class="line">    <span class="type">EvaluationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> webExpressionConfigAttribute.postProcess(</span><br><span class="line">            <span class="built_in">this</span>.expressionHandler.createEvaluationContext(authentication, filterInvocation), filterInvocation);</span><br><span class="line">    <span class="comment">//4.使用ExpressionUtils工具类来判断EL表达式的值（这里是EL表达式的难点）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">granted</span> <span class="operator">=</span> ExpressionUtils.evaluateAsBoolean(webExpressionConfigAttribute.getAuthorizeExpression(), ctx);</span><br><span class="line">    <span class="comment">//5.EL表达式为true返回授权成功</span></span><br><span class="line">    <span class="keyword">if</span> (granted) &#123;</span><br><span class="line">        <span class="keyword">return</span> ACCESS_GRANTED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.否则返回授权失败</span></span><br><span class="line">    <span class="built_in">this</span>.logger.trace(<span class="string">&quot;Voted to deny authorization&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ACCESS_DENIED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> WebExpressionConfigAttribute <span class="title function_">findConfigAttribute</span><span class="params">(Collection&lt;ConfigAttribute&gt; attributes)</span> &#123;</span><br><span class="line">    <span class="comment">//遍历所有权限规则找第一个符合要求的，在一个地方重复配置会被第一个权限规则覆盖</span></span><br><span class="line">    <span class="keyword">for</span> (ConfigAttribute attribute : attributes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (attribute <span class="keyword">instanceof</span> WebExpressionConfigAttribute) &#123;</span><br><span class="line">            <span class="keyword">return</span> (WebExpressionConfigAttribute) attribute;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-8-finallyInvocation方法"><a href="#10-8-finallyInvocation方法" class="headerlink" title="10.8.finallyInvocation方法"></a>10.8.finallyInvocation方法</h3><p>AbstractSecurityInterceptor类方法finallyInvocation来处理是否更新SecurityContext。该方法只要通过了授权就会被调用，即使请求调用抛出了异常。</p><p>方法来源：AbstractSecurityInterceptor类，由FilterSecurityInterceptor调用super.beforeInvocation来调用父类的方法。</p><p>方法逻辑：授权后令牌不为null且isContextHolderRefreshRequired设置为true时更新ecurityContext</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractSecurityInterceptor类finallyInvocation方法源码解析</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finallyInvocation</span><span class="params">(InterceptorStatusToken token)</span> &#123;</span><br><span class="line">    <span class="comment">//授权后令牌不为null且isContextHolderRefreshRequired设置为true时更新ecurityContext</span></span><br><span class="line">    <span class="keyword">if</span> (token != <span class="literal">null</span> &amp;&amp; token.isContextHolderRefreshRequired()) &#123;</span><br><span class="line">        SecurityContextHolder.setContext(token.getSecurityContext());</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.debug(LogMessage.of(</span><br><span class="line">                    () -&gt; <span class="string">&quot;Reverted to original authentication &quot;</span> + token.getSecurityContext().getAuthentication()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-9-afterInvocation方法"><a href="#10-9-afterInvocation方法" class="headerlink" title="10.9.afterInvocation方法"></a>10.9.afterInvocation方法</h3><p>AbstractSecurityInterceptor类方法afterInvocation来进行过滤器后处理。</p><p>方法来源：AbstractSecurityInterceptor类，由FilterSecurityInterceptor调用super.afterInvocation来调用父类的方法。</p><p>方法逻辑：1.若无需权限就直接返回null无处理2.清理SecurityContext3.若afterInvocationManager存在，委托afterInvocationManager进行过滤器后处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractSecurityInterceptor类afterInvocation方法源码解析</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">afterInvocation</span><span class="params">(InterceptorStatusToken token, Object returnedObject)</span> &#123;</span><br><span class="line">    <span class="comment">//1.若无需权限就直接返回null无处理</span></span><br><span class="line">    <span class="keyword">if</span> (token == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// public object</span></span><br><span class="line">        <span class="keyword">return</span> returnedObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.清理SecurityContext</span></span><br><span class="line">    finallyInvocation(token); <span class="comment">// continue to clean in this method for passivity</span></span><br><span class="line">    <span class="comment">//3.若afterInvocationManager存在，委托afterInvocationManager进行过滤器后处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.afterInvocationManager != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Attempt after invocation handling</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            returnedObject = <span class="built_in">this</span>.afterInvocationManager.decide(token.getSecurityContext().getAuthentication(),</span><br><span class="line">                    token.getSecureObject(), token.getAttributes(), returnedObject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AccessDeniedException ex) &#123;</span><br><span class="line">            publishEvent(<span class="keyword">new</span> <span class="title class_">AuthorizationFailureEvent</span>(token.getSecureObject(), token.getAttributes(),</span><br><span class="line">                    token.getSecurityContext().getAuthentication(), ex));</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回null或后处理结果</span></span><br><span class="line">    <span class="keyword">return</span> returnedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-10-详细的授权流程时序图"><a href="#10-10-详细的授权流程时序图" class="headerlink" title="10.10.详细的授权流程时序图"></a>10.10.详细的授权流程时序图</h3><p>![spring security授权过程分析](spring security授权过程分析.png)</p><blockquote><p>FilterSecurityInterceptor过滤器原理为servlet过滤器，实现了请求路径过滤器层面的权限控制，请求路径权限配置来源于Spring Security的配置类。</p></blockquote><h2 id="16-MethodSecurityInterceptor（重点）"><a href="#16-MethodSecurityInterceptor（重点）" class="headerlink" title="16.MethodSecurityInterceptor（重点）"></a>16.MethodSecurityInterceptor（重点）</h2><p><strong>拦截方法调用并在拒绝请求时抛出异常</strong>。这个<strong>拦截器</strong>决定了访问特定<strong>方法</strong>应具备的权限，如果要实现动态权限控制就必须研究该类。</p><p><strong>只处理注解AOP层面的权限控制，不处理过滤器层面的权限控制</strong>。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">   <span class="comment">//1.委托 beforeInvocation 执行“鉴权”过滤逻辑</span></span><br><span class="line">   <span class="type">InterceptorStatusToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="built_in">super</span>.beforeInvocation(mi);</span><br><span class="line">   Object result;</span><br><span class="line">   <span class="comment">//2.执行方法调用</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      result = mi.proceed();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//3.方法调用结束后执行</span></span><br><span class="line">      <span class="built_in">super</span>.finallyInvocation(token);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//4.方法调用完成后执行 </span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">super</span>.afterInvocation(token, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 FilterSecurityInterceptor 继承的同一个父类 <code>AbstractSecurityInterceptor</code> 。其逻辑源码与 FilterSecurityInterceptor 几乎一样，但是其 <code>SecurityMetadataSource</code> 的真实类型与之不同，是 <code>MethodSecurityMetadataSource</code> 类型。类图如下：</p><p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20240224175844626.png" alt="image-20240224175844626"></p><p>即<strong>拦截器的权限数据源</strong>与FilterSecurityInterceptor 过滤器的数据源不同，<strong>拦截器的权限数据源来源于方法上的注解</strong>。总结拦截器数据源有如下<strong>四种</strong>：</p><p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20240224181132139.png" alt="image-20240224181132139"></p><p>而<strong>过滤器数据源</strong>只有<strong>一种</strong>：ExpressionBasedFilterInvocationSecurityMetadataSource</p><p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20240224181443840.png" alt="image-20240224181443840"></p><p>以上拦截器 <code>MethodSecurityInterceptor</code> 与 <code>MethodSecurityMetadataSource</code> 都是由 <code>GlobalMethodSecurityConfiguration</code> 配置类装配到IOC容器的。源码比较多，这里就不分析了还是比较简单。</p><blockquote><p>MethodSecurityInterceptor拦截器原理为AOP，实现了方法层面的权限控制，方法权限配置来源于注解和xml配置文件。</p></blockquote><h1 id="二、注解解析"><a href="#二、注解解析" class="headerlink" title="二、注解解析"></a>二、注解解析</h1><h2 id="1-EnableWebSecurity"><a href="#1-EnableWebSecurity" class="headerlink" title="1.EnableWebSecurity"></a>1.EnableWebSecurity</h2><p>在非<code>Springboot</code>的应用中，该注解<code>@EnableWebSecurity</code>需要开发人员自己引入以启用<code>Web</code>安全。</p><p><strong>在<code>Springboot</code>的应用中,开发人员没有必要再次引用该注解</strong>，<code>Springboot</code>的自动配置机制<code>WebSecurityEnablerConfiguration</code>已经引入了该注解。</p><p><code>@EnableWebSecurity</code>引入了WebSecurityConfiguration、<code>HttpSecurityConfiguration</code>、AuthenticationConfiguration的bean对象和SpringWebMvcImportSelector、OAuth2ImportSelector选择引入的bean对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Import(&#123; WebSecurityConfiguration.class, SpringWebMvcImportSelector.class, OAuth2ImportSelector.class,</span><br><span class="line">      HttpSecurityConfiguration.class &#125;)</span><br><span class="line">@EnableGlobalAuthentication</span><br></pre></td></tr></table></figure><p>其中 <code>HttpSecurityConfiguration</code> 的装配最重要，它帮我们装配了一个默认的 <code>HttpSecurity</code> 组件，这是配置Spring Security的关键组件。其中对 HttpSecurity 组件进行了默认的配置，<strong>配置开启了许多的过滤器组件</strong>，这些<strong>过滤器在 HttpSecurity .build() 时创建</strong>。</p><blockquote><p>springboot应用无需使用这个注解。它帮我们准备好了许多默认的过滤器组件，我们只需要httpSecurity.build()就可以使<strong>Http安全相关过滤器</strong>注入生效。它还帮我们调用了webSecurity.build()装配好了<strong>web安全相关的过滤器</strong>。</p><p>注意：<strong>先执行httpSecurity.build()再执行webSecurity.build()。webSecurity层次更高。</strong></p></blockquote><h1 id="三、组件解析"><a href="#三、组件解析" class="headerlink" title="三、组件解析"></a>三、组件解析</h1><h2 id="1-DelegatingFilterProxy"><a href="#1-DelegatingFilterProxy" class="headerlink" title="1.DelegatingFilterProxy"></a>1.DelegatingFilterProxy</h2><p><strong>用于给Servlet Filter做代理</strong>(代理方)，代理到 spring bean（被代理方），这样可以将spring bean中的过滤器通过 <code>DelegatingFilterProxy</code> 来注册到servlet容器的过滤器中。</p><p><code>DelegatingFilterProxy</code> 是由 <code>DelegatingFilterProxyRegistrationBean</code> 来创建的，并将其注册到 Servlet 容器中。而这个注册bean是由 <code>SecurityFilterAutoConfiguration</code> 自动配置类装配的。</p><p>所以依赖关系如下：<code>DelegatingFilterProxy</code>  –&gt;  <code>DelegatingFilterProxyRegistrationBean</code> –&gt;  <code>SecurityFilterAutoConfiguration</code></p><p><strong>DelegatingFilterProxy</strong>：用于给Servlet Filter做代理。代理的 targetBeanName 名字为 “springSecurityFilterChain”。</p><p><strong>DelegatingFilterProxyRegistrationBean</strong>：用于注册 Servlet filter。</p><p><strong>SecurityFilterAutoConfiguration</strong>：用于装配 DelegatingFilterProxyRegistrationBean 到 IOC容器。</p><h2 id="2-FilterChainProxy"><a href="#2-FilterChainProxy" class="headerlink" title="2. FilterChainProxy"></a>2. FilterChainProxy</h2><p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20240225140054659.png" alt="image-20240225140054659"></p><p>是一个代理类，代理了 <code>List&lt;SecurityFilterChain&gt; filterChains</code> 多个 <code>SecurityFilterChain</code> 。同时这个对象被注入到DelegatingFilterProxy对象。</p><p><strong>FilterChainProxy由 WebSecurity.buid() 创建出来</strong>。并<strong>由 <code>WebSecurityConfiguration</code> 配置类来控制这个构建过程</strong>。这个组件会将程序中所有由 httpSecurity.build() 构建的 SecurityFilterChain 全部重新整合构建为 <code>FilterChainProxy</code>。</p><blockquote><p><strong>The WebSecurity is created by WebSecurityConfiguration to create the FilterChainProxy</strong> known as the Spring Security Filter Chain (<strong>springSecurityFilterChain</strong>). The springSecurityFilterChain is the Filter that the DelegatingFilterProxy delegates to.</p><p>所以 <strong>WebSecurityConfiguration 组件控制了 FilterChainProxy 的创建过程！</strong></p></blockquote><h2 id="3-SecurityFilterChain"><a href="#3-SecurityFilterChain" class="headerlink" title="3.SecurityFilterChain"></a>3.SecurityFilterChain</h2><p>是一个过滤器链，其中又包含多个过滤器对象。并被 <code>FilterChainProxy</code> 所使用。</p><p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20240225155634811.png" alt="image-20240225155634811"></p><p><strong>SecurityFilterChain由 http.build()创建出来</strong>。当然 webSecurity在构建 FilterChainProxy 过程中也会创建SecurityFilterChain。但这里主要是指我们自定义的配置类控制 HttpSecurity 创建 SecurityFilterChain。</p><p>我们可以对 <strong>HttpSecurity 调用 requestMatcher() 方法控制此过滤链匹配的路径</strong>，但<strong>默认是匹配所有路径</strong>。</p><blockquote><p>HttpSecurityConfiguration创建了默认的 HttpSecurity 组件，但并没有通过HttpSecurity创建SecurityFilterChain。</p><p>所以我们自己配置的组件控制了 SecurityFilterChain 的创建过程。</p></blockquote><h2 id="4-WebSecurityConfiguration和WebSecurity"><a href="#4-WebSecurityConfiguration和WebSecurity" class="headerlink" title="4.WebSecurityConfiguration和WebSecurity"></a>4.WebSecurityConfiguration和WebSecurity</h2><p>WebSecurityConfiguration 是 Spring Security的配置类。</p><ol><li><strong>注入了</strong>容器中<strong>所有的 SecurityFilterChain 组件</strong></li><li>使用ObjectPostProcessor组件<strong>创建了 webSecurity 组件</strong></li><li>使用 webSecurity组件和所有的 SecurityFilterChain 组件 <strong>创建了 FilterChainProxy</strong>。</li></ol><p><strong>WebSecurity组件实现了具体构建 FilterChainProxy的逻辑。</strong></p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)</span></span><br><span class="line"><span class="keyword">public</span> Filter <span class="title function_">springSecurityFilterChain</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">hasConfigurers</span> <span class="operator">=</span> <span class="built_in">this</span>.webSecurityConfigurers != <span class="literal">null</span> &amp;&amp; !<span class="built_in">this</span>.webSecurityConfigurers.isEmpty();</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">hasFilterChain</span> <span class="operator">=</span> !<span class="built_in">this</span>.securityFilterChains.isEmpty();</span><br><span class="line">   。。。</span><br><span class="line">   <span class="keyword">if</span> (!hasConfigurers &amp;&amp; !hasFilterChain) &#123;</span><br><span class="line">      <span class="type">WebSecurityConfigurerAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="built_in">this</span>.objectObjectPostProcessor</span><br><span class="line">            .postProcess(<span class="keyword">new</span> <span class="title class_">WebSecurityConfigurerAdapter</span>() &#123;</span><br><span class="line">            &#125;);</span><br><span class="line">      <span class="built_in">this</span>.webSecurity.apply(adapter);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//1.遍历所有的过滤器链 </span></span><br><span class="line">   <span class="keyword">for</span> (SecurityFilterChain securityFilterChain : <span class="built_in">this</span>.securityFilterChains) &#123;</span><br><span class="line">      <span class="comment">//2.将过滤器链添加到 webSecurity，准备重新整合构建</span></span><br><span class="line">      <span class="built_in">this</span>.webSecurity.addSecurityFilterChainBuilder(() -&gt; securityFilterChain);</span><br><span class="line">      <span class="comment">//遍历过滤器，将 FilterSecurityInterceptor 过滤器设置到 webSecurity属性中</span></span><br><span class="line">      <span class="keyword">for</span> (Filter filter : securityFilterChain.getFilters()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (filter <span class="keyword">instanceof</span> FilterSecurityInterceptor) &#123;</span><br><span class="line">            <span class="built_in">this</span>.webSecurity.securityInterceptor((FilterSecurityInterceptor) filter);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (WebSecurityCustomizer customizer : <span class="built_in">this</span>.webSecurityCustomizers) &#123;</span><br><span class="line">      customizer.customize(<span class="built_in">this</span>.webSecurity);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3.整合构建，最终会创建出 FilterChainProxy 对象。</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.webSecurity.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-HttpSecurityConfiguration和HttpSecurity"><a href="#5-HttpSecurityConfiguration和HttpSecurity" class="headerlink" title="5.HttpSecurityConfiguration和HttpSecurity"></a>5.HttpSecurityConfiguration和HttpSecurity</h2><p>HttpSecurityConfiguration是 Spring Security的配置类。主要就<strong>创建了 HttpSecurity 组件</strong>。内部<strong>对HttpSecurity进行了一些默认配置，配置了默认的过滤器链在构建时生效</strong>。</p><p><strong>HttpSecurity组件实现了具体构建 SecurityFilterChain/DefaultSecurityFilterChain 的逻辑。</strong>还具有许多方法可以灵活的配置过滤器和权限规则。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(HTTPSECURITY_BEAN_NAME)</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">HttpSecurity <span class="title function_">httpSecurity</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   。。。</span><br><span class="line">   <span class="comment">//1.创建了 HttpSecurity对象    </span></span><br><span class="line">   <span class="type">HttpSecurity</span> <span class="variable">http</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpSecurity</span>(<span class="built_in">this</span>.objectPostProcessor, authenticationBuilder, createSharedObjects());</span><br><span class="line">   <span class="comment">//2.配置了 HttpSecurity对象</span></span><br><span class="line">   http</span><br><span class="line">      .csrf(withDefaults()) <span class="comment">//csrf过滤器</span></span><br><span class="line">      .addFilter(<span class="keyword">new</span> <span class="title class_">WebAsyncManagerIntegrationFilter</span>()) <span class="comment">//WebAsyncManagerIntegrationFilter过滤器</span></span><br><span class="line">      .exceptionHandling(withDefaults()) <span class="comment">//ExceptionTranslationFilter</span></span><br><span class="line">      .headers(withDefaults()) <span class="comment">//HeaderWriterFilter</span></span><br><span class="line">      .sessionManagement(withDefaults()) <span class="comment">//SessionManagementFilter、ConcurrentSessionFilter</span></span><br><span class="line">      .securityContext(withDefaults()) <span class="comment">//SecurityContextPersistenceFilter</span></span><br><span class="line">      .requestCache(withDefaults()) <span class="comment">//RequestCacheAwareFilter</span></span><br><span class="line">      .anonymous(withDefaults()) <span class="comment">//AnonymousAuthenticationFilter</span></span><br><span class="line">      .servletApi(withDefaults()) <span class="comment">//SecurityContextHolderAwareRequestFilter</span></span><br><span class="line">      .apply(<span class="keyword">new</span> <span class="title class_">DefaultLoginPageConfigurer</span>&lt;&gt;()); </span><br><span class="line">   http.logout(withDefaults()); <span class="comment">//LogoutFilter</span></span><br><span class="line">   applyDefaultConfigurers(http);</span><br><span class="line">   <span class="keyword">return</span> http;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-SecurityAutoConfiguration"><a href="#6-SecurityAutoConfiguration" class="headerlink" title="6.SecurityAutoConfiguration"></a>6.SecurityAutoConfiguration</h2><p><strong>是 Spring Boot 的自动配置类</strong>。为我们引入了组件 <code>SpringBootWebSecurityConfiguration</code> 和 <code>SecurityDataConfiguration</code> ，还引入了 <code>DefaultAuthenticationEventPublisher</code> 认证事件发布组件。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfiguration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DefaultAuthenticationEventPublisher.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(SecurityProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; SpringBootWebSecurityConfiguration.class, SecurityDataConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean(AuthenticationEventPublisher.class)</span></span><br><span class="line">   <span class="keyword">public</span> DefaultAuthenticationEventPublisher <span class="title function_">authenticationEventPublisher</span><span class="params">(ApplicationEventPublisher publisher)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultAuthenticationEventPublisher</span>(publisher);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-SpringBootWebSecurityConfiguration"><a href="#7-SpringBootWebSecurityConfiguration" class="headerlink" title="7.SpringBootWebSecurityConfiguration"></a>7.SpringBootWebSecurityConfiguration</h2><p><strong>是 Spring Boot 的自动配置类</strong>。</p><ol><li>如果我们没有配置 SecurityFilterChain 组件，会为我们<strong>默认配置一个 <code>SecurityFilterChain</code> 组件</strong>，否则就不配置。</li><li><strong>配置一个 ErrorPageSecurityFilter 过滤器</strong>到 servlet filter 中。</li><li><strong>使用注解 @EnableWebSecurity</strong>。</li></ol><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnDefaultWebSecurity</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SecurityFilterChainConfiguration</span> &#123;</span><br><span class="line"><span class="comment">//默认提供的 SecurityFilterChain</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@Order(SecurityProperties.BASIC_AUTH_ORDER)</span></span><br><span class="line">   SecurityFilterChain <span class="title function_">defaultSecurityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      http.authorizeRequests().anyRequest().authenticated();</span><br><span class="line">      http.formLogin();</span><br><span class="line">      http.httpBasic();</span><br><span class="line">      <span class="keyword">return</span> http.build();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-SecurityFilterAutoConfiguration"><a href="#8-SecurityFilterAutoConfiguration" class="headerlink" title="8.SecurityFilterAutoConfiguration"></a>8.SecurityFilterAutoConfiguration</h2><p><strong>是 Spring Boot 的自动配置类</strong>。用于注册过滤链集合到 servlet filter中。</p><p>实际上为我们装配了一个组件 <code>DelegatingFilterProxyRegistrationBean</code> 来用于注册过滤器。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(name = DEFAULT_FILTER_NAME)</span></span><br><span class="line"><span class="keyword">public</span> DelegatingFilterProxyRegistrationBean <span class="title function_">securityFilterChainRegistration</span><span class="params">(</span></span><br><span class="line"><span class="params">      SecurityProperties securityProperties)</span> &#123;</span><br><span class="line">   <span class="type">DelegatingFilterProxyRegistrationBean</span> <span class="variable">registration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegatingFilterProxyRegistrationBean</span>(</span><br><span class="line">         DEFAULT_FILTER_NAME);</span><br><span class="line">   registration.setOrder(securityProperties.getFilter().getOrder());</span><br><span class="line">   registration.setDispatcherTypes(getDispatcherTypes(securityProperties));</span><br><span class="line">   <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、无配置引入"><a href="#四、无配置引入" class="headerlink" title="四、无配置引入"></a>四、无配置引入</h1><h2 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h2><ol><li>引入依赖，版本由spring boot版本管理。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.引入后就可以立即启动。</p><p>此时默认所有路径都需要认证，都会经过<code>UsernamePasswordAuthenticationFilter</code>过滤器，默认有登录页面。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>以上效果是<strong>Spring Boot自动装配</strong>导致的，自动装配的配置类为<code>org.springframework.boot.autoconfigure.security.servlet.SpringBootWebSecurityConfiguration</code>。默认情况下它会创建一个<code>SecurityFilterChain</code>过滤链组件。组件<code>SecurityFilterChain</code>依赖于<code>HttpSecurity</code>组件。</p><p>源码分析如下：</p><p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20240223160414470.png" alt="image-20240223160414470"></p><p>代码 <code>http.authorizeRequests().anyRequest().authenticated();</code> 配置了<strong>所有请求都需要认证</strong>。</p><p>代码 <code>http.formLogin();</code> 配置了将FormLoginConfigurer加入HttpSecurity，请求经过 <code>UsernamePasswordAuthenticationFilter</code> 过滤器来进行认证，同时由于未配置登录页路径会**使用默认登录页”/login”**。</p><p>代码 <code>http.httpBasic();</code> 配置了将HttpBasicConfigurer加入HttpSecurity，请求经过 <code>BasicAuthenticationFilter</code> 过滤器来进行<strong>HTTP Basic认证</strong>。</p><p>代码 <code>http.build();</code> 根据以上代码来<strong>装配spring security的过滤链并返回SecurityFilterChain组件</strong>。</p><p>默认情况下，Spring Boot <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/servlet/UserDetailsServiceAutoConfiguration.java">UserDetailsServiceAutoConfiguration</a> 自动化配置类，会创建一个<strong>内存级别</strong>的 <a href="https://github.com/spring-projects/spring-security/blob/master/core/src/main/java/org/springframework/security/provisioning/InMemoryUserDetailsManager.java">InMemoryUserDetailsManager</a> Bean 对象，提供认证的用户信息。</p><blockquote><p> 以上我们分析了默认的SecurityFilterChain组件，这是Spring Boot默认为我们装配的。实际上我们需要自己配置一个SecurityFilterChain 组件或者 WebSecurityConfigurerAdapter 组件来覆盖此默认装配的组件。</p></blockquote><hr><h1 id="五、配置引入"><a href="#五、配置引入" class="headerlink" title="五、配置引入"></a>五、配置引入</h1><h2 id="代码实践-1"><a href="#代码实践-1" class="headerlink" title="代码实践"></a>代码实践</h2><ol><li>引入依赖，版本由spring boot版本管理。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.配置组件。</p><p><strong>配置Spring Security需要的组件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityComponentConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义的认证失败处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationEntryPoint <span class="title function_">authenticationEntryPoint</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AuthenticationEntryPointImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义的权限不够处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AccessDeniedHandler <span class="title function_">accessDeniedHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AccessDeniedHandlerImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义的认证过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TokenAuthenticationFilter <span class="title function_">tokenAuthenticationFilter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TokenAuthenticationFilter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在自定我们自己的Spring Security过滤器时，最好<strong>不要将过滤器注入IOC容器中</strong>，如果注入后spring boot会再次将此过滤器注册到servelet容器中，导致过滤器执行两次，如果我们一定要注入到IOC容器中我们可以控制spring boot不要注册此过滤器到servlet容器，代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> FilterRegistrationBean&lt;TenantFilter&gt; <span class="title function_">tenantFilterRegistration</span><span class="params">(TenantFilter filter)</span> &#123;</span><br><span class="line">    FilterRegistrationBean&lt;TenantFilter&gt; registration = <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>&lt;&gt;(filter);</span><br><span class="line">    <span class="comment">//不要注册此过滤器到servlet容器！！！</span></span><br><span class="line">    registration.setEnabled(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置Spring Security自身过滤器组件、添加过滤器组件、自身url的访问控制</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AccessDeniedHandler accessDeniedHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationEntryPoint authenticationEntryPoint;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TokenAuthenticationFilter tokenAuthenticationFilter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity httpSecurity)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.配置过滤器</span></span><br><span class="line">        httpSecurity</span><br><span class="line">                <span class="comment">// 开启跨域</span></span><br><span class="line">                .cors().and()</span><br><span class="line">                <span class="comment">// CSRF 禁用，因为不使用 Session</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">// 配置会话。基于 token 机制，所以不需要 Session，且一个用户只能有一个会话</span></span><br><span class="line">                .sessionManagement().maximumSessions(<span class="number">1</span>).expiredUrl(<span class="string">&quot;/auth/logion&quot;</span>).and()</span><br><span class="line">                                    .sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()</span><br><span class="line">                <span class="comment">// 配置响应头header。</span></span><br><span class="line">                .headers().frameOptions().disable().and()</span><br><span class="line">                <span class="comment">// 配置异常过滤器</span></span><br><span class="line">                .exceptionHandling().authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">                                    .accessDeniedHandler(accessDeniedHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.添加过滤器</span></span><br><span class="line">        httpSecurity.addFilterBefore(tokenAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得 @PermitAll 带来的 URL 列表，免登录</span></span><br><span class="line">        Multimap&lt;HttpMethod, String&gt; permitAllUrls = getPermitAllUrlsFromAnnotations();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.配置基于url的访问控制</span></span><br><span class="line">        httpSecurity</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 静态资源，可匿名访问</span></span><br><span class="line">                .antMatchers(HttpMethod.GET, <span class="string">&quot;/*.html&quot;</span>, <span class="string">&quot;/**/*.html&quot;</span>, <span class="string">&quot;/**/*.css&quot;</span>, <span class="string">&quot;/**/*.js&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">// 设置 @PermitAll 无需认证</span></span><br><span class="line">                .antMatchers(HttpMethod.GET, permitAllUrls.get(HttpMethod.GET).toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>])).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.POST, permitAllUrls.get(HttpMethod.POST).toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>])).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.PUT, permitAllUrls.get(HttpMethod.PUT).toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>])).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.DELETE, permitAllUrls.get(HttpMethod.DELETE).toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>])).permitAll()</span><br><span class="line">                <span class="comment">// 设置aj验证码的cotroller请求无需认证</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/captcha/get&quot;</span>, <span class="string">&quot;/captcha/check&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">// 兜底规则，必须认证</span></span><br><span class="line">                .and().authorizeRequests()</span><br><span class="line">                        .anyRequest().authenticated();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> httpSecurity.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过<span class="doctag">@PermitAlll</span>注解获取被注解的url集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Multimap&lt;HttpMethod, String&gt; <span class="title function_">getPermitAllUrlsFromAnnotations</span><span class="params">()</span> &#123;</span><br><span class="line">        Multimap&lt;HttpMethod, String&gt; result = HashMultimap.create();</span><br><span class="line">        <span class="comment">// 获得接口对应的 HandlerMethod 集合</span></span><br><span class="line">        <span class="type">RequestMappingHandlerMapping</span> <span class="variable">requestMappingHandlerMapping</span> <span class="operator">=</span> (RequestMappingHandlerMapping)</span><br><span class="line">                applicationContext.getBean(<span class="string">&quot;requestMappingHandlerMapping&quot;</span>);</span><br><span class="line">        Map&lt;RequestMappingInfo, HandlerMethod&gt; handlerMethodMap = requestMappingHandlerMapping.getHandlerMethods();</span><br><span class="line">        <span class="comment">// 获得有 @PermitAll 注解的接口</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;RequestMappingInfo, HandlerMethod&gt; entry : handlerMethodMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (!handlerMethod.hasMethodAnnotation(PermitAll.class)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (entry.getKey().getPatternsCondition() == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;String&gt; urls = entry.getKey().getPatternsCondition().getPatterns();</span><br><span class="line">            <span class="comment">// 特殊：使用 @RequestMapping 注解，并且未写 method 属性，此时认为都需要免登录</span></span><br><span class="line">            Set&lt;RequestMethod&gt; methods = entry.getKey().getMethodsCondition().getMethods();</span><br><span class="line">            <span class="keyword">if</span> (CollUtil.isEmpty(methods)) &#123;</span><br><span class="line">                result.putAll(HttpMethod.GET, urls);</span><br><span class="line">                result.putAll(HttpMethod.POST, urls);</span><br><span class="line">                result.putAll(HttpMethod.PUT, urls);</span><br><span class="line">                result.putAll(HttpMethod.DELETE, urls);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据请求方法，添加到 result 结果</span></span><br><span class="line">            entry.getKey().getMethodsCondition().getMethods().forEach(requestMethod -&gt; &#123;</span><br><span class="line">                <span class="keyword">switch</span> (requestMethod) &#123;</span><br><span class="line">                    <span class="keyword">case</span> GET:</span><br><span class="line">                        result.putAll(HttpMethod.GET, urls);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> POST:</span><br><span class="line">                        result.putAll(HttpMethod.POST, urls);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> PUT:</span><br><span class="line">                        result.putAll(HttpMethod.PUT, urls);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> DELETE:</span><br><span class="line">                        result.putAll(HttpMethod.DELETE, urls);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、还未完成，持续更新"><a href="#六、还未完成，持续更新" class="headerlink" title="六、还未完成，持续更新"></a>六、还未完成，持续更新</h1>]]></content>
      
      
      <categories>
          
          <category> Spring Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于部署上线那些事</title>
      <link href="/2024/02/14/%E5%85%B3%E4%BA%8E%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
      <url>/2024/02/14/%E5%85%B3%E4%BA%8E%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="1准备服务器"><a href="#1准备服务器" class="headerlink" title="1准备服务器"></a>1准备服务器</h3><p>购买服务器</p><p>为服务器初始化软件：宝塔面板（方便管理服务器）、Mysql、java环境、docker等。</p><h3 id="2前端"><a href="#2前端" class="headerlink" title="2前端"></a>2前端</h3><p><code>上线前准备</code>：前端上线对接后端地址。修改前端请求的后端地址。（编译阶段就区分好了环境）</p><p>&emsp;&emsp;开发环境：前端请求的是 localhost:XXXX 或者说是测试用的接口地址</p><p>&emsp;&emsp;上线环境：前端请求的是 xxxx.com/api 之类的正式地址</p><p><code>上线步骤</code>：</p><ol><li>本地打包构建。</li><li>给服务器安装Nginx。用Nginx等web服务器来提供访问前端服务能力</li><li>把dist网页目录放到<strong>服务器</strong>上。</li></ol><blockquote><p>纯css、js、html项目无需打包构建，使用了框架的项目需要打包构建为css、js、html项目。使用了框架建议参考官方文档部署项目。</p></blockquote><p><code>快速上线</code>：可以依赖宝塔面板快速部署上线</p><p>1.菜单栏添加站点（前提是安装了nginx才会有此页面）。</p><p><img src="/img/API%E6%8E%A5%E5%8F%A3%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0.assets/image-20240212142046166.png" alt="image-20240212142046166"></p><p>2.初始化站点信息。</p><p><img src="/img/API%E6%8E%A5%E5%8F%A3%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0.assets/image-20240212142315114.png" alt="image-20240212142315114"></p><p>3.将前端编译好的文件放到指定文件夹下。</p><p>4.默认该ip:80可以访问前端服务了。</p><h3 id="3后端"><a href="#3后端" class="headerlink" title="3后端"></a>3后端</h3><p><strong>关键：网络必须要连通</strong><br>如果自己学习用：单个服务器部署这三个项目就足够<br>如果你是搞大事，多个服务器建议在同一内网，内网交互会更快、且更安全</p><p><code>上线准备</code>：后端上线对接中间件、数据库地址（运行阶段区分环境）</p><p>&emsp;&emsp;开发环境：后端请求的数据库地址是 localhost:3306 ，请求的注册中心、redis等中间组件地址都是 localhost</p><p>&emsp;&emsp;上线环境：后端请求的地址是 xxxx.com:3306 之类的正式地址</p><p><code>上线步骤</code>：</p><ol><li>本地编译构建。</li><li>把jar包放到服务器上。</li><li>手动运行jar包。</li></ol><p><code>快速上线</code>：可以依赖宝塔面板快速部署上线</p><ol><li>上传java的jar包到服务器。</li><li>在网站菜单栏添加java项目。</li></ol><p><img src="/img/API%E6%8E%A5%E5%8F%A3%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0.assets/image-20240212145655615.png" alt="image-20240212145655615"></p><h3 id="4Docker部署"><a href="#4Docker部署" class="headerlink" title="4Docker部署"></a>4Docker部署</h3><p>Dockerfile用于指定构建 Docker 镜像的方法。</p><p>Docker构建优化：减少尺寸、减少构建时间（比如多阶段构建）</p><p><code>前端部署步骤</code>：</p><ol><li>本地打包dist包</li><li>本地编写Dockerfile文件（参考本项目）</li><li>将前端代码文件上传到云服务器。或者dist文件夹、docker文件夹、Dockerfile文件上传。</li><li>运行 docker build -t [标签名:标签版本]构建镜像</li></ol><p><code>后端部署步骤</code>：</p><ol><li>本地打包jar包</li><li>本地编写Dockerfile文件</li><li>将jar包和Dockerfile文件上传到云服务器</li><li>运行 docker build -t [标签名:标签版本]构建镜像</li></ol><blockquote><p><code>容器化后存在的问题</code>：各个容器的id地址不同且重启容器后ip会变化。<strong>代码中的localhost微服务之间的请求就失效了！！！</strong></p></blockquote><h3 id="5Docker平台部署"><a href="#5Docker平台部署" class="headerlink" title="5Docker平台部署"></a>5Docker平台部署</h3><ol><li>云服务商的容器平台（腾讯云、阿里云）</li><li>面向某个领域的容器平台（前端 webify、后端微信云托管）</li></ol><h3 id="6域名解析"><a href="#6域名解析" class="headerlink" title="6域名解析"></a>6域名解析</h3><ol><li>购买域名</li><li>解析域名</li><li>备案域名</li><li>配置nginx路由</li></ol><h3 id="7跨域问题解决"><a href="#7跨域问题解决" class="headerlink" title="7跨域问题解决"></a>7跨域问题解决</h3><p><strong>浏览器</strong>为了用户的安全，仅允许向<strong>同域名、同端口</strong>的服务器发送请求。</p><p>如何解决跨域：</p><ol><li>把前后端 域名、端口改成相同的</li><li>让服务器告诉浏览器允许跨域（返回cross-origin-allow响应头）</li><li>Nginx网关配置允许跨域。修改nginx.conf配置文件加响应头</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /api/ &#123;</span><br><span class="line">    proxy_pass http:<span class="comment">//127.0.0.1:8080/api/;</span></span><br><span class="line">    add_header <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> $http_origin;</span><br><span class="line">    add_header <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="string">&#x27;true&#x27;</span>;</span><br><span class="line">    add_header Access-Control-Allow-Methods <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">    add_header Access-Control-Allow-Headers <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> ($request_method = <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">        add_header <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="string">&#x27;true&#x27;</span>;</span><br><span class="line">        add_header <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> $http_origin;</span><br><span class="line">        add_header <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">        add_header <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#x27;</span>;</span><br><span class="line">        add_header <span class="string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="number">1728000</span>;</span><br><span class="line">        add_header <span class="string">&#x27;Content-Type&#x27;</span> <span class="string">&#x27;text/plain; charset=utf-8&#x27;</span>;</span><br><span class="line">        add_header <span class="string">&#x27;Content-Length&#x27;</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">204</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>修改后端服务允许跨域<ol><li>配置 @CrossOrigin 注解</li><li><strong>添加 web 请求拦截器</strong></li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局跨域配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wzy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 覆盖所有请求</span></span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                <span class="comment">// 允许发送 Cookie</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">                <span class="comment">// 放行哪些域名（必须用 patterns，否则 * 会和 allowCredentials 冲突）</span></span><br><span class="line">                .allowedOriginPatterns(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .exposedHeaders(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>定义新的 CrossFilter Bean，参考：<a href="https://www.jianshu.com/p/b02099a435bd">https://www.jianshu.com/p/b02099a435bd</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 上线 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 部署 </tag>
            
            <tag> 上线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常及其解决方案汇总（持续更新~）</title>
      <link href="/2024/02/14/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0~%EF%BC%89/"/>
      <url>/2024/02/14/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0~%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h1><h3 id="1-service层编写原则"><a href="#1-service层编写原则" class="headerlink" title="1.service层编写原则"></a>1.service层编写原则</h3><blockquote><p> 小心service组件循环依赖问题！！！</p></blockquote><ol><li><strong>Controller调用Service层是：一对一接口调用</strong>，且Controller层不做任何业务处理，目的是为了后续拓展直接替换Controller为RPC框架而准备</li><li><strong>同一模块下Service层避免互相调用</strong>：一般情况下事物配置在service层，为了避免事物嵌套或单个事物过大等问题的</li><li><strong>同一模块下service层调用dao层</strong>：除了尽量控制事物大小，即控制Service调用dao层的复杂度，将单个事物经量控制在100ms之内</li><li>对第二条进行补充，<strong>同一模块下避免互相调用service而选择调用dao</strong>，<strong>不同模块下尽量互相调用service</strong>。</li><li><strong>加锁范围一定要大于事务范围！！！</strong><a href="https://juejin.cn/post/7175530611807895611#heading-3">事务范围不能比加锁范围大</a>。</li><li><strong>调用其它模块的service时，尽量不要用到其它模块的模型对象</strong>。</li><li>同一个service的方法相互调用时，aop一般不会生效，我们需要<strong>手动获取其代理对象再进行同一个service的方法相互调用</strong>。</li><li><strong>解析前先判断，可以手动避免抛出异常</strong>。</li><li>优先使用 <strong>ThreadPoolTaskExecutor</strong> 而不是 ThreadPoolExecutor 。</li></ol><h3 id="2-Mysql使用原则"><a href="#2-Mysql使用原则" class="headerlink" title="2.Mysql使用原则"></a>2.Mysql使用原则</h3><ol><li><strong>尽量不要在mysql层面使用唯一校验</strong>。因为我们会有isDelete字段的存在，当isDelete为true时认为要忽略这条记录，保证未删除记录字段的唯一，即删除记录的字段是可以与未删除记录字段重复的，但mysql无法实现这个功能（或者说实现起来需要认为添加一个联合唯一索引，且必须在删除时更新维护一个多余的字段，比较麻烦）。而且数据库校验很不灵活，会增加数据库负担。</li><li><strong>尽量在后端service层实现唯一校验、存在校验、操作校验、子节点校验</strong>等等！实现方便且可以编写灵活复杂的校验逻辑，当然缺点就是与数据库的交互会急剧增加。</li></ol><h3 id="3-前端原则"><a href="#3-前端原则" class="headerlink" title="3.前端原则"></a>3.前端原则</h3><ol><li>前端代码比较“兼容”，一个json对象多了几个属性还是可以赋值给少了这些属性的变量，同理一个json对象少了几个属性还是可以赋值给多了这些属性的变量。<strong>即赋值没有严格的属性一致性</strong>。</li><li><strong>async异步函数内部一定要try-catch</strong>。以处理异常回调。</li></ol><hr><h1 id="springMVC"><a href="#springMVC" class="headerlink" title="springMVC"></a>springMVC</h1><h3 id="1-java-web项目-springmvc-xml-配置文件错误"><a href="#1-java-web项目-springmvc-xml-配置文件错误" class="headerlink" title="1.java web项目 springmvc.xml 配置文件错误"></a>1.java web项目 springmvc.xml 配置文件错误</h3><p>==问题提示：==java web项目 springmvc.xml 配置文件错误。抛出异常<code>Cannot resolve reference to bean ‘cacheManager‘ while setting bean property ‘cacheManager‘</code>。</p><p>==解决办法：==检查 springmvc.xml 配置文件的命名空间，将自动导入的cache改为mvc。</p><p><img src="/2024/02/14/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0~%EF%BC%89/image-20231007113928748.png" alt="image-20240214165413128"></p><h3 id="2-java-web项目配置-Tomcat-错误"><a href="#2-java-web项目配置-Tomcat-错误" class="headerlink" title="2.java web项目配置 Tomcat 错误"></a>2.java web项目配置 Tomcat 错误</h3><p>==问题提示：==请求一直404。其实是请求路径前缀问题。</p><p>==解决办法：==检查IDEA中的<strong>Tomcat如下 Application Context设置</strong>，会给url带指定的<strong>路径前缀</strong>，如果你的请求路径所带的前缀不一致就会一直404。</p><p><img src="/2024/02/14/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0~%EF%BC%89/image-20240313195603777.png" alt="image-20240313195603777"></p><p>另一个请求路径相关的设置，以下路径设置与项目无关。</p><p><img src="/2024/02/14/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0~%EF%BC%89/image-20240313200019345.png" alt="image-20240313200019345"></p><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h3 id="1-关于Spring-Cache的错误"><a href="#1-关于Spring-Cache的错误" class="headerlink" title="1.关于Spring Cache的错误"></a>1.关于Spring Cache的错误</h3><p>==问题提示：==EL1007E: Property or field ‘id’ cannot be found on null。id属性不能从null对象中找到。</p><p>==解决办法：==注意Spring Cache的使用，其注解的 <code>key</code> 属性不能指定为方法返回值的属性或相关内容，否则为null。所以报错空指针。</p><blockquote><p> @Transcational会生成代理对象，原理是AOP动态代理。</p></blockquote><hr><h1 id="Mybatis-plus"><a href="#Mybatis-plus" class="headerlink" title="Mybatis-plus"></a>Mybatis-plus</h1><h3 id="1-mybatis与mybatis-plus版本不兼容问题NoSuchMethodError"><a href="#1-mybatis与mybatis-plus版本不兼容问题NoSuchMethodError" class="headerlink" title="1.mybatis与mybatis-plus版本不兼容问题NoSuchMethodError"></a>1.mybatis与mybatis-plus版本不兼容问题NoSuchMethodError</h3><p>==问题提示：==java.lang.NoSuchMethodError: org.apache.ibatis.session.Configuration.setArgNameBasedConstructorAutoMapping(Z)V</p><p>==解决办法：==在mybatis-plus源码中找其依赖的mybatis版本！！！</p><h3 id="2-Mybatis-plus批量操作"><a href="#2-Mybatis-plus批量操作" class="headerlink" title="2.Mybatis-plus批量操作"></a>2.Mybatis-plus批量操作</h3><blockquote><p>不要使用Iservice提供的saveBatch，耗时最多循环插入都比它快。<a href="https://juejin.cn/post/7189163819825332284">各种批量插入方式效率分析</a></p></blockquote><p>默认BaseMapper没有insertBatch()方法，实现方式有：</p><ol><li>编写Mapper接口和Mapper.xml。自定义insertBatch()方法</li><li>使用mybatis-plus提供了<a href="https://gitee.com/baomidou/mybatis-plus-samples/tree/master/mybatis-plus-sample-sql-injector">InsertBatchSomeColumn</a>批量insert方法<ol><li>自定义sql注入类继承DefaultSqlInjector</li><li>mybatiplus配置类配置自定义sql注入新类的bean</li><li>创建MyBaseMapper接口继承BaseMapper接口，并添加抽象方法 <code>int insertBatchSomeColumn(List&lt;T&gt; entityList);</code></li><li>自定义的Mapper继承MyBaseMapper</li><li>service调用</li></ol></li><li>官网提供的<a href="https://baomidou.com/pages/33c2c2/">MybatisBatch</a>实现批量操作，支持insert、update、delete</li></ol><p>可以开启<strong>mysql的批处理</strong>支持<code>jdbc:mysql://localhost:3306/wzyapi?rewriteBatchedStatements=true</code>提高批处理速度。</p><p>还可以开启<strong>mybatis-plus的批处理模式</strong>。在application.yaml中配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">executor-type:</span> <span class="string">batch</span></span><br></pre></td></tr></table></figure><h3 id="3、mysql账号密码错误而导致的无法连接"><a href="#3、mysql账号密码错误而导致的无法连接" class="headerlink" title="3、mysql账号密码错误而导致的无法连接"></a>3、mysql账号密码错误而导致的无法连接</h3><p>==问题提示==：突然不能连接数据库了。</p><p>==解决办法==：查看账号修改密码。并设置root用户 <code>&#39;root&#39;@&#39;%&#39;</code> 任意ip可访问。小心不是‘root‘@’0.0.0.0’！！！这样不生效！！！</p><h3 id="4、mybtais-plus是如何通过lambda方法引用获取字段名的"><a href="#4、mybtais-plus是如何通过lambda方法引用获取字段名的" class="headerlink" title="4、mybtais-plus是如何通过lambda方法引用获取字段名的"></a>4、mybtais-plus是如何通过lambda方法引用获取字段名的</h3><p>参考博客：<a href="https://blog.csdn.net/justry_deng/article/details/124059375">https://blog.csdn.net/justry_deng/article/details/124059375</a></p><p>原理：<strong>方法引用的序列化机制</strong>，读取其方法名再解析出属性名就是字段名</p><p>源码：</p><p><strong>Person::getName方法引用会被动态生成下述类</strong>：其中重要的是 <code>writeReplace()</code> 方法，这是<strong>序列化的lambda表达式信息</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JVM自动生成的类，运行时直接dump class出来后反编译出来</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MainTests$$Lambda$1</span> <span class="keyword">implements</span> <span class="title class_">SFunction</span> &#123;</span><br><span class="line">   <span class="meta">@Hidden</span></span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">apply</span><span class="params">(Object var1)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ((Person)var1).getName();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Object <span class="title function_">writeReplace</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SerializedLambda</span>(</span><br><span class="line">      MainTests.class, </span><br><span class="line">      <span class="string">&quot;com/example/lambda/demo/SFunction&quot;</span>, </span><br><span class="line">      <span class="string">&quot;apply&quot;</span>, </span><br><span class="line">      <span class="string">&quot;(Ljava/lang/Object;)Ljava/lang/Object;&quot;</span>, </span><br><span class="line">      <span class="number">5</span>, </span><br><span class="line">      <span class="string">&quot;com/example/lambda/test/Person&quot;</span>, </span><br><span class="line">      <span class="string">&quot;getName&quot;</span>, </span><br><span class="line">      <span class="string">&quot;()Ljava/lang/String;&quot;</span>, </span><br><span class="line">      <span class="string">&quot;(Lcom/example/lambda/test/Person;)Ljava/lang/Object;&quot;</span>, </span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]</span><br><span class="line">      );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AbstractLambdaWrapper</code> 类中的 getColumnCache 方法会调用 <code>LambdaUtils.extract(column);</code>。通过反射调用 column 的 writeReplace 方法获取 SerializedLambda 对象，并将其包装为 ReflectLambdaMeta ，最终还是<strong>从 SerializedLambda 获取 ImplMethodName</strong>。</p><ol><li>LambdaUtils.extract(column) 根据lambda表达<strong>反射调用 writeReplace 方法获取 SerializedLambda  对象</strong>。</li><li>将 SerializedLambda <strong>包装为 ReflectLambdaMeta 返回</strong>。</li><li>通过 ReflectLambdaMeta <strong>获取  SerializedLambda 的 implMethodName 属性</strong>，<strong>就是lambda方法引用的方法名称</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractLambdaWrapper.java</span></span><br><span class="line"><span class="keyword">protected</span> ColumnCache <span class="title function_">getColumnCache</span><span class="params">(SFunction&lt;T, ?&gt; column)</span> &#123;</span><br><span class="line"><span class="comment">//1.通过反射获取</span></span><br><span class="line">    <span class="type">LambdaMeta</span> <span class="variable">meta</span> <span class="operator">=</span> LambdaUtils.extract(column);</span><br><span class="line">    <span class="comment">//3.获取字段名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fieldName</span> <span class="operator">=</span> PropertyNamer.methodToProperty(meta.getImplMethodName());</span><br><span class="line">    Class&lt;?&gt; instantiatedClass = meta.getInstantiatedClass();</span><br><span class="line">    tryInitCache(instantiatedClass);</span><br><span class="line">    <span class="keyword">return</span> getColumnCache(fieldName, instantiatedClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LambdaUtils.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; LambdaMeta <span class="title function_">extract</span><span class="params">(SFunction&lt;T, ?&gt; func)</span> &#123;</span><br><span class="line">    。。。</span><br><span class="line">    <span class="comment">// 2. 反射读取</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//2.1反射调用 lambda生成的类的 writeReplace 方法获取到 SerializedLambda 对象（见生成类的源码）</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> func.getClass().getDeclaredMethod(<span class="string">&quot;writeReplace&quot;</span>);</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//2.2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReflectLambdaMeta</span>((SerializedLambda) method.invoke(func), func.getClass().getClassLoader());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">       。。。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-自定义TypeHandler类型解析器"><a href="#5-自定义TypeHandler类型解析器" class="headerlink" title="5.自定义TypeHandler类型解析器"></a>5.自定义TypeHandler类型解析器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(autoResultMap = true)</span><span class="comment">//一定要开启映射注解，否则不会生效</span></span><br><span class="line"><span class="meta">@TableName(value =&quot;tenant_package&quot;,autoResultMap = true)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TenantPackage</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TableField(value = &quot;menuIds&quot;,typeHandler = LongSetTypeHandler.class)</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Long&gt; menuIds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>**@TableName(autoResultMap = true)**注解的autoResultMap 属性一定要置为true</li><li><strong>@TableField</strong>(value = “menuIds”,typeHandler = LongSetTypeHandler.class)entity对象属性上一定要指定typeHandler</li><li><strong>Mapper.xml</strong>中如果写了ResultMap一定要标明字段的typeHandler</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;menuIds&quot;</span> <span class="attr">column</span>=<span class="string">&quot;menuIds&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">typeHandler</span>=<span class="string">&quot;com.wzy.project.framework.mybatis.type.LongSetTypeHandler&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-自定义批量插入要判断集合是否为空，否则sql出错"><a href="#6-自定义批量插入要判断集合是否为空，否则sql出错" class="headerlink" title="6.自定义批量插入要判断集合是否为空，否则sql出错"></a>6.自定义批量插入要判断集合是否为空，否则sql出错</h3><p>多租户情况下，新租户最易出现这种情况。</p><hr><h1 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h1><h3 id="1-关于OpenFeign的controller层参数校验"><a href="#1-关于OpenFeign的controller层参数校验" class="headerlink" title="1.关于OpenFeign的controller层参数校验"></a>1.关于OpenFeign的controller层参数校验</h3><p>==问题提示==：A method overriding another method must not redefine the parameter constraint configuration。</p><p>==解决办法==：继承模式下，参数校验写在接口文件中，controller层实现只留实现，<strong>在controller层写@Vlidated注解在类上就行，其它校验注解不要写否则会报错</strong>。</p><h3 id="2-OpenFeign调用的服务配置了server-servlet-context-path时，调用出现404"><a href="#2-OpenFeign调用的服务配置了server-servlet-context-path时，调用出现404" class="headerlink" title="2.OpenFeign调用的服务配置了server.servlet.context-path时，调用出现404"></a>2.OpenFeign调用的服务配置了server.servlet.context-path时，调用出现404</h3><p>==问题提示==：feign.FeignException$NotFound: [404] during [GET] to [XXXXXXX]</p><p>==解决办法==：这是由于 server.servlet.context-path 配置会自动为controller层的路径再次添加前缀导致的，<strong>无论我们interface文件的方法上注解的请求路径怎么写都无济于事</strong>，实现方微服务都会在前面添加前缀，所以我们需要在 <code>@FeignClient(name = &quot;XXX&quot;,path = &quot;/api&quot;)</code> 添加Feign远程调用请求的前缀，即客户端远程调用请求前缀由<code>@FeignClient</code>指定，服务端远程调用请求前缀由<code>server.servlet.context-path</code>配置指定，这两者必须相同，否则404。</p><p>3.</p><hr><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><blockquote><p>前端打印对象 JSON.stringfy(obj)</p></blockquote><blockquote><p>if (actionRef.current) {<br>actionRef.current.reload()<br>}</p><p>与</p><p>actionRef.current?.reload()</p><p>是等价的</p></blockquote><h3 id="1-npm认证过期，证书过期"><a href="#1-npm认证过期，证书过期" class="headerlink" title="1.npm认证过期，证书过期"></a>1.npm认证过期，证书过期</h3><p>==问题提示：==npm ERR! code CERT_HAS_EXPIRED 。npm认证过期，证书过期问题。</p><p>==解决办法：==CERT_HAS_EXPIRED是一个由<a href="https://so.csdn.net/so/search?q=Node.js&spm=1001.2101.3001.7020">Node.js</a>和npm抛出的错误，表示你正在尝试访问的服务器的SSL证书已经过期。</p><ol><li><p>清除npm缓存：<code>npm cache clean --force</code></p></li><li><p>取消ssl验证：<code>npm config set strict-ssl false</code></p></li><li><p>之后再<code>npm install</code> 你想安装的东西</p></li></ol><h3 id="2-echarts-for-react做图时，图数据不实时变化"><a href="#2-echarts-for-react做图时，图数据不实时变化" class="headerlink" title="2.echarts-for-react做图时，图数据不实时变化"></a>2.echarts-for-react做图时，图数据不实时变化</h3><blockquote><p>困扰1小时！！！</p></blockquote><p>==问题提示：==定义了一个<code>const option</code>变量传递给图，其中<code>option.tilte.text</code>是一个字面量。因为定义的为常量，所以后续js中改变option.title.text就会失效。</p><p>==解决办法：==定义<code>const option</code>变量时将<code>option.tilte.text</code>也定义为变量。通过setTiltle实时变化数据！！！</p><h3 id="3-HttpMessageNotReadableException"><a href="#3-HttpMessageNotReadableException" class="headerlink" title="3.HttpMessageNotReadableException"></a>3.HttpMessageNotReadableException</h3><p>==问题提示：==HttpMessageNotReadableException: JSON parse error: Cannot deserialize value of type <code>java.lang.String</code> from Object value (token <code>JsonToken.START_OBJECT</code>)</p><p>前端json对象（HttpMessage）无法反序列化为后端String对象。因为这样的话需要先反序列化，再序列化，但是默认HTTP请求处理只会反序列化。</p><p>==解决办法：==前端数据输入修改正常。</p><h3 id="4-Ant-Design图标"><a href="#4-Ant-Design图标" class="headerlink" title="4.Ant Design图标"></a>4.Ant Design图标</h3><p>参考文章：<a href="https://github.com/ant-design/ant-design/issues/20668">https://github.com/ant-design/ant-design/issues/20668</a></p><p>三种表示图标的方法：</p><ol><li><p><code>&lt;MessageOutlined /&gt;</code></p></li><li><p><code>icon=&#123;MessageOutlined&#125;</code></p></li><li><p><code>icon=&quot;message&quot;</code></p></li></ol><img src="image-20240301164748532.png" alt="image-20240301164748532" style="zoom:50%;" /><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取全局属性。用户信息</span></span><br><span class="line"><span class="keyword">const</span> &#123; initialState &#125; = <span class="title function_">useModel</span>(<span class="string">&#x27;@@initialState&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; loginUser &#125; = initialState || &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-ant-design-pro修改前端项目的路径后，运行后报错"><a href="#5-ant-design-pro修改前端项目的路径后，运行后报错" class="headerlink" title="5.ant-design-pro修改前端项目的路径后，运行后报错"></a>5.ant-design-pro修改前端项目的路径后，运行后报错</h3><p>==问题提示：== Can not resolve dependence ‘ant-design-pro/node_modules/@umijs/renderer-react’, please install it.</p><p>==解决办法：==删除新路径中的 如：<code>E:\dev\new-ant-design-pro\node_modules\</code> 的文件夹 <code>.cache</code>。 再重新运行项目</p><h3 id="6-前端在打包构建时报错冲突"><a href="#6-前端在打包构建时报错冲突" class="headerlink" title="6.前端在打包构建时报错冲突"></a>6.前端在打包构建时报错冲突</h3><p>==解决办法：==删除原来dist文件</p><h3 id="7-Ant-Design-Pro前端上线后出现404页面请求"><a href="#7-Ant-Design-Pro前端上线后出现404页面请求" class="headerlink" title="7.Ant Design Pro前端上线后出现404页面请求"></a>7.Ant Design Pro前端上线后出现404页面请求</h3><p>==解决办法：==将umi路由方式从默认的browser改为<a href="https://pro.ant.design/zh-CN/docs/deploy#%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E7%BB%93%E5%90%88">hash路由</a>。</p><h3 id="8-浏览器前端请求本质"><a href="#8-浏览器前端请求本质" class="headerlink" title="8.浏览器前端请求本质"></a>8.浏览器前端请求本质</h3><p>将nginx中的前端代码获取到浏览器中渲染。</p><p>umi框架在使用build时自动传入了NODE_ENV == prod</p><h3 id="9-React的setState是异步执行的"><a href="#9-React的setState是异步执行的" class="headerlink" title="9.React的setState是异步执行的"></a>9.React的setState是异步执行的</h3><h3 id="10-前端向后端传递日期问题"><a href="#10-前端向后端传递日期问题" class="headerlink" title="10.前端向后端传递日期问题"></a>10.前端向后端传递日期问题</h3><p>==问题提示：== springboot中报错<code>Invalid character found in the request</code>。浏览器option请求直接400。浏览器响应信息提示String无法转LocalDateTime。问题一：Tomcat不接受<code>[]</code>字符的url。问题二：日期字符串在mvc不能自动转换为LocalDateTime。</p><p>==解决办法：==针对问题一：配置文件配置Tomcat，让Tomcat允许[]字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  tomcat:</span><br><span class="line">    relaxed-query-chars:</span><br><span class="line">      - &quot;[&quot;</span><br><span class="line">      - &quot;]&quot;</span><br></pre></td></tr></table></figure><p>针对问题二：VO层的实体类上在日期字段上添加注解<code>@DateTimeFormat(pattern = DATETIME_FORMAT)</code>，<strong>告诉后端你要如何解析日期字符串</strong>。</p><h3 id="11-Ant-Desgin-Pro使用时更新对话框没有携带id字段"><a href="#11-Ant-Desgin-Pro使用时更新对话框没有携带id字段" class="headerlink" title="11.Ant Desgin Pro使用时更新对话框没有携带id字段"></a>11.Ant Desgin Pro使用时更新对话框没有携带id字段</h3><p>==问题提示：==没有更新时后端报错没有id，即前端没有传递 id字段。究其原因是对话框没有设置id字段。</p><p>==解决办法：==在前端执行API更新请求时，指定id字段。</p><h3 id="12-Ant-Desgin-Pro中的Form-Item问题"><a href="#12-Ant-Desgin-Pro中的Form-Item问题" class="headerlink" title="12.Ant Desgin Pro中的Form.Item问题"></a>12.Ant Desgin Pro中的Form.Item问题</h3><p>参考文章：<a href="https://blog.csdn.net/qq_43720551/article/details/131502261">https://blog.csdn.net/qq_43720551/article/details/131502261</a></p><p>==问题提示：==input框里面的数值消失。前端提交不到表单。</p><p>==解决办法：==原因是Form.Item在设置name属性后，input框的value属性值会被覆盖，即 Form.Item 来管理输入框中的内容，这时我们去Form.Item中设置初始值属性就好了。</p><h3 id="13-后端接收不到前端的数据"><a href="#13-后端接收不到前端的数据" class="headerlink" title="13.后端接收不到前端的数据"></a>13.后端接收不到前端的数据</h3><p>==问题提示：==数据正常发送，格式也没有问题。最后问题是出在后端注解，没有使用 @RequestBody 注解来处理前端传来的参数。导致校验Bean Vlidation报错。</p><p>==解决办法：==后端检查注解，确保正确被处理。</p><h3 id="14-日期字符串在前端页面格式化"><a href="#14-日期字符串在前端页面格式化" class="headerlink" title="14.日期字符串在前端页面格式化"></a>14.日期字符串在前端页面格式化</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 日期字符串格式化</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> <span class="variable">val</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> <span class="variable">params</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">formatDate</span> = (<span class="params">val:<span class="built_in">string</span>|<span class="literal">undefined</span>,params=<span class="string">&#x27;YYYY年MM月DD日 HH:mm:ss&#x27;</span></span>) =&gt; &#123;</span><br><span class="line">       <span class="keyword">if</span> (!val) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="title function_">moment</span>(val).<span class="title function_">format</span>(params);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="15-页面组件的子组件加载问题【useEffect-方法】"><a href="#15-页面组件的子组件加载问题【useEffect-方法】" class="headerlink" title="15.页面组件的子组件加载问题【useEffect(,[])方法】"></a>15.页面组件的子组件加载问题【useEffect(,[])方法】</h3><p>==注意：==页面组件在第一次加载时会调用useEffect(,[])方法，也同时会所有调用子组件的useEffect(,[])方法。而且<strong>子组件在显示时不会再次调用useEffect()方法</strong>！！！</p><p>==注意：==但是我们**稍微改变一下将其变为useEffect(,[监听对象])**，一旦对象变化就会监听到并执行useEffect(,[监听对象])。这样就可以多次调用了。</p><p>总结：useEffect()函数是一个非常好用的函数！！！</p><p>列表的 <code>initialValue</code> 就是初始值，会被动态的覆盖，或者说一直就是这个值不会改变。<strong>我们要使用 useEffect()函数函数来动态的改变对话框里面的input标签的值</strong>。</p><h3 id="16-文件上传问题"><a href="#16-文件上传问题" class="headerlink" title="16.文件上传问题"></a>16.文件上传问题</h3><p>参考博客：<a href="https://blog.csdn.net/java0506/article/details/108078867">https://blog.csdn.net/java0506/article/details/108078867</a></p><p>==问题提示：==Resolved [org.springframework.web.multipart.support.<strong>MissingServletRequestPartException: Required request part ‘multipartFile’ is not present</strong>]</p><p>情况描述：ant desgin文件上传时，直接使用表格封装的value对象来取 file 会取不到真正的file文件对象。</p><p>==解决办法：==1.首先上传标签的 <code>beforeUpload</code> 属性设置返回false阻止文件自动上传。2.其次使用表单的表单项标签 <code>getValueFromEvent</code>  属性获取真正的文件对象<code>&#123;file: ,fileList: &#125;</code>，并创建 <code>FormData</code> 对象（这是<strong>最终请求体里面的对象非常重要</strong>）将file保证到里面。3.发送请求时请求体携带 formdata 对象即可。</p><p>注意：ant desgin pro会根据你构造的请求对象，自动填充请求头的Content-Type值。</p><p>==问题提示：==Springboot报错Required request part ‘file‘ is not present</p><p>==解决办法：==这是由于设置到 <code>FormData</code> 对象的文件对象不正确导致的，即设置的不是真正的文件对象。需要将file对象设置进去。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于获取文件对象，并保存到 formData 中</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">normFile</span> = (<span class="params">e: <span class="built_in">any</span></span>) =&gt; &#123;</span><br><span class="line">    formData.<span class="title function_">append</span>(<span class="string">&#x27;multipartFile&#x27;</span>, e.<span class="property">file</span>) &lt;------*</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(e)) &#123;</span><br><span class="line">        <span class="keyword">return</span> e</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e &amp;&amp; e.<span class="property">fileList</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-Form-Item里面checkBox赋值后不生效问题"><a href="#17-Form-Item里面checkBox赋值后不生效问题" class="headerlink" title="17.Form.Item里面checkBox赋值后不生效问题"></a>17.Form.Item里面checkBox赋值后不生效问题</h3><p>==问题提示：==checkBox选中后，并没有传到Form.Item被其管理，表单结果没有选中的值。</p><p>==解决办法：==语法问题。如下表单项就无法管理到 checkBox 的值。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Form</span>.<span class="property">Item</span> name=&#123;<span class="string">&quot;updateSupport&quot;</span>&#125; valuePropName=&#123;<span class="string">&#x27;checked&#x27;</span>&#125; initialValue=&#123;<span class="literal">false</span>&#125;&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Checkbox</span>&gt;</span>是否更新已经存在的用户数据<span class="tag">&lt;/<span class="name">Checkbox</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>仅允许导入xls、xlsx格式文件。<span class="tag">&lt;<span class="name">a</span>&gt;</span>下载模板<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Form</span>.<span class="property">Item</span>&gt;</span><br></pre></td></tr></table></figure><p>必须改为</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Form</span>.<span class="property">Item</span> name=&#123;<span class="string">&quot;updateSupport&quot;</span>&#125; valuePropName=&#123;<span class="string">&#x27;checked&#x27;</span>&#125; initialValue=&#123;<span class="literal">false</span>&#125;&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Checkbox</span>&gt;</span>是否更新已经存在的用户数据<span class="tag">&lt;/<span class="name">Checkbox</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Form</span>.<span class="property">Item</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>仅允许导入xls、xlsx格式文件。<span class="tag">&lt;<span class="name">a</span>&gt;</span>下载模板<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="18-对话框结束后Dragger标签清空问题"><a href="#18-对话框结束后Dragger标签清空问题" class="headerlink" title="18.对话框结束后Dragger标签清空问题"></a>18.对话框结束后Dragger标签清空问题</h3><p>无法双向绑定清空Dragger标签数据？？？</p><h3 id="19-TreeSelect标签初始时传入了初始值但checkBox没有显示选中"><a href="#19-TreeSelect标签初始时传入了初始值但checkBox没有显示选中" class="headerlink" title="19.TreeSelect标签初始时传入了初始值但checkBox没有显示选中"></a>19.TreeSelect标签初始时传入了初始值但checkBox没有显示选中</h3><p>==问题提示：==TreeSelect标签初始时传入了初始值但checkBox没有显示选中</p><p>==解决办法：==数据类型不匹配问题，options传入的类型为{<strong>value:string</strong>,title:string}，但是传入的初始值数据是number[]类型就会导致checkBox没有显示选中。解决方案一：将options传入的类型改为{<strong>value:number</strong>,title:string}，解决方案一：将初始值改为string[]</p><h3 id="20-使用antd的openapi报错"><a href="#20-使用antd的openapi报错" class="headerlink" title="20.使用antd的openapi报错"></a>20.使用antd的openapi报错</h3><p>==问题提示：==TypeError: Cannot read properties of undefined (reading ‘version’)</p><p>==解决办法：==这种情况一般是前端无法访问后端此url路径：/v3/api-docs导致的。</p><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h3 id="1-json字符串转具体泛型对象，例如BaseResopnse-lt-String-gt"><a href="#1-json字符串转具体泛型对象，例如BaseResopnse-lt-String-gt" class="headerlink" title="1.json字符串转具体泛型对象，例如BaseResopnse&lt;String&gt;"></a>1.json字符串转具体泛型对象，例如<code>BaseResopnse&lt;String&gt;</code></h3><blockquote><p>困扰1小时！！！</p></blockquote><p>==问题提示：==1.使用原始泛型类型为变量类型报警。2.<code>BaseResopnse</code>类型值不能赋值到<code>BaseResopnse&lt;String&gt;</code>变量上。</p><p><img src="/2024/02/14/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0~%EF%BC%89/image-20240206203540636.png" alt="image-20240206203540636"></p><p><img src="/2024/02/14/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0~%EF%BC%89/image-20240206203756240.png" alt="image-20240206203756240"></p><p>==解决办法：==使用方法<code>JSONUtil.toBean(result, new TypeReference&lt;BaseResponse&lt;String&gt;&gt;() &#123;&#125;,false)</code>。即可返回泛型类型的对象值。</p><h3 id="2-java-lang-LinkageError【devtools导致】"><a href="#2-java-lang-LinkageError【devtools导致】" class="headerlink" title="2.java.lang.LinkageError【devtools导致】"></a>2.java.lang.LinkageError【devtools导致】</h3><blockquote><p>困扰1小时！！！</p></blockquote><p>==问题提示：==两个类加载器<code>RestartClassLoader</code>和<code>Launcher$AppClassLoader</code>加载同一个方法签名冲突。devtools两个类加载器加载同一个类导致的LinkageError。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.LinkageError: loader constraint violation: </span><br><span class="line">when resolving method <span class="string">&quot;com.wzy.wzyapiclientsdk.client.WzyApiClient.getUserNameByPost(Lcom/wzy/wzyapiclientsdk/model/User;)Lcom/wzy/wzyapicommon/common/BaseResponse;&quot;</span> </span><br><span class="line">the class loader (instance of org/springframework/boot/devtools/restart/classloader/RestartClassLoader) of the current class, com/wzy/project/controller/InterfaceInfoController, </span><br><span class="line">and the class loader (instance of sun/misc/Launcher<span class="variable">$AppClassLoader</span>) <span class="keyword">for</span> the method<span class="string">&#x27;s defining class, com/wzy/wzyapiclientsdk/client/WzyApiClient, </span></span><br><span class="line"><span class="string">have different Class objects for the type com/wzy/wzyapicommon/common/BaseResponse used in the signature</span></span><br></pre></td></tr></table></figure><p>LinkageError: loader constraint violation: when resolving method the class loader of the current class,and the class loader for the method have different Class objects for the type used in the signature</p><p>==解决办法：==LinkageError出现的情况复杂，一般发生在被多个类加载器加载的类发生交互时出现。这里是由于springboot装配devtools后，类被加载两次导致。</p><p>devtools加载了两次后，导致有两个类型的BaseResponse，最终导致调用方法getUserNameByPost时类型转换异常。解决办法就是去掉devtools依赖。<a href="https://blog.csdn.net/tongyimplin/article/details/80983272">https://blog.csdn.net/tongyimplin/article/details/80983272</a></p><h3 id="3-java-反射调用函数问题（实际是HttpUtil客户端使用错误抛出的异常）"><a href="#3-java-反射调用函数问题（实际是HttpUtil客户端使用错误抛出的异常）" class="headerlink" title="3.java 反射调用函数问题（实际是HttpUtil客户端使用错误抛出的异常）"></a>3.java 反射调用函数问题（实际是HttpUtil客户端使用错误抛出的异常）</h3><p>==问题提示：==java.lang.reflect.InvocationTargetException调用失败</p><p>==解决办法：==此异常是被调用函数抛出的异常。需要检查被调用函数逻辑。注意使用Hutool发送请求时，不要设置<code>int[]</code>类型的参数，不要使用原始类似数组，否则会报异常，如果传入了原始类型数组，转换一下为包装类似数组。Hutool源码如下:</p><p><img src="/2024/02/14/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0~%EF%BC%89/image-20240209183009094.png" alt="image-20240209183009094"></p><blockquote><p> List.toArray(需要输入数组对象)。否则创建的是 Object[] 对象</p></blockquote><p>==JSONArray里面只包括JSONObject、JSONArray和原始数据类型！！！==JSON对象很方便转换解析为为Bean对象，而JSON数组不方便转换为Bean对象。</p><h3 id="4-云服务器上的mysql不允许连接"><a href="#4-云服务器上的mysql不允许连接" class="headerlink" title="4.云服务器上的mysql不允许连接"></a>4.云服务器上的mysql不允许连接</h3><p>==问题提示：==mysql不允许链接</p><p>==解决办法：==</p><ol><li>云服务器防火墙开通3306</li><li>mysql的root用户权限默认本地登录访问。改为远程登录访问。</li><li>mysql配置的bind-address改为 0.0.0.0</li></ol><h3 id="5-云服务器上Nacos后端无法连接"><a href="#5-云服务器上Nacos后端无法连接" class="headerlink" title="5.云服务器上Nacos后端无法连接"></a>5.云服务器上Nacos后端无法连接</h3><p>==问题提示：==NacosException: Client not connected, current status:STARTING</p><p>==解决办法：==nacos需要开放三个端口8848、9848、9849。</p><h3 id="6-IDEA中java代码打包问题"><a href="#6-IDEA中java代码打包问题" class="headerlink" title="6.IDEA中java代码打包问题"></a>6.IDEA中java代码打包问题</h3><p>==问题提示：==java打包后只有.jar文件。没有.jar.original文件。且打包后的文件内容格式混乱，打开后不是org/META_INF/BOOT_INF三个文件夹。</p><p>==解决办法：==</p><p>修改pom.xml文件将spring-boot-maven-plugin插件配置好。配置主类加executions标签、去掉skip标签。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--     war包打包插件       --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--jar包打包插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.wzy.wzyapiinterface.WzyapiInterfaceApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="7-上线错误缺失类com-google-protobuf-Message"><a href="#7-上线错误缺失类com-google-protobuf-Message" class="headerlink" title="7.上线错误缺失类com.google.protobuf.Message"></a>7.上线错误缺失类com.google.protobuf.Message</h3><p>==问题提示==：缺失类com.google.protobuf.Message（缺失protobuf-java的依赖）</p><p>==解决办法：==安装依赖包protobuf-java，重新打包。</p><h3 id="8、上线报错ConnectTimeoutException"><a href="#8、上线报错ConnectTimeoutException" class="headerlink" title="8、上线报错ConnectTimeoutException"></a>8、上线报错ConnectTimeoutException</h3><p>==问题提示==：网关报错io.netty.channel.ConnectTimeoutException: connection timed out: /111.231.72.191:8123</p><p>==解决办法==：网关请求不到此端口。云服务器防火墙开放端口8123</p><h3 id="9、SpringBoot读取依赖模块中application-yml配置失效问题"><a href="#9、SpringBoot读取依赖模块中application-yml配置失效问题" class="headerlink" title="9、SpringBoot读取依赖模块中application.yml配置失效问题"></a>9、SpringBoot读取依赖模块中application.yml配置失效问题</h3><p>==问题提示==：A项目依赖B.jar包，其中B.jar包装包含配置文件application.yaml，同时A项目中也包含配置文件application.yaml。运行A项目报错 <code>IllegalArgumentException: Could not resolve placeholder</code> 配置的属性。<a href="https://blog.lonelyman.site/archives/36">https://blog.lonelyman.site/archives/36</a></p><p>==解决办法==：springboot 如果自身有<code>application.yml</code>，就会覆盖依赖模块的同名配置文件。由于在<code>client-service</code>模块创建了<code>application.yml</code>，导致<code>common</code>模块的<code>application.yml</code>被覆盖。所以将配置转移到依赖模块中或者重命名配置文件名。</p><h3 id="10-多租户下，租户切换用户权限校验问题"><a href="#10-多租户下，租户切换用户权限校验问题" class="headerlink" title="10.多租户下，租户切换用户权限校验问题"></a>10.多租户下，租户切换用户权限校验问题</h3><p>如果<strong>切换租户时，进行了手动权限校验，就会导致报错</strong>。这是因为<strong>需要校验的是原租户的用户权限</strong>，而不是切换后租户用户的权限。</p><h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h3 id="1-IDEA-NoSuchMethodError-DefaultModelValidator-method-＜init＞-V-not-found"><a href="#1-IDEA-NoSuchMethodError-DefaultModelValidator-method-＜init＞-V-not-found" class="headerlink" title="1.IDEA_NoSuchMethodError: DefaultModelValidator: method ＜init＞()V not found"></a>1.IDEA_NoSuchMethodError: DefaultModelValidator: method ＜init＞()V not found</h3><p>==问题提示==：NoSuchMethodError: DefaultModelValidator: method <init>()V not found   at CustomModelValidator</p><p>==解决办法==：是由于Maven版本过高，IDEA不兼容导致的。</p><p>注意：针对一些老项目 还是尽量采用 3.6.3版本，针对idea各个版本的兼容性就很兼容<br>0.IDEA 2022 兼容<a href="https://so.csdn.net/so/search?q=maven&spm=1001.2101.3001.7020">maven</a> 3.8.1及之前的所用版本<br>1.IDEA 2021 兼容maven 3.8.1及之前的所用版本<br>2.IDEA 2020 兼容Maven 3.6.3及之前所有版本<br>3.IDEA 2018 兼容Maven3.6.1及之前所有版本</p><hr><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h3 id="1、配置RabbitMQ导致循环依赖问题"><a href="#1、配置RabbitMQ导致循环依赖问题" class="headerlink" title="1、配置RabbitMQ导致循环依赖问题"></a>1、配置RabbitMQ导致循环依赖问题</h3><p>==问题提示==：RabbitmqConfig-&gt;依赖-&gt;RabbitTemplate-&gt;依赖-&gt;RabbitTemplateConfigurer-&gt;依赖-&gt;MessageConverter。而自定义的MessageConverter组件放在了RabbitmqConfig就会导致循环依赖！！！</p><p>==解决办法==：将MessageConverter抽取出来新建一个配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageConverterConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息转换器。默认消息只能传输字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、云服务器部署连接不上"><a href="#2、云服务器部署连接不上" class="headerlink" title="2、云服务器部署连接不上"></a>2、云服务器部署连接不上</h3><p>==问题提示==：springboot连接rabbitmq报错：Failed to check/redeclare auto-delete queue(s)</p><p>==解决办法==：这是因为spring boot程序无法连接到rabbitmq，如果端口开放了，用户密码正确了，就使用面板localhost:15672<strong>检查用户权限</strong>开启用户的权限。</p><hr><h1 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h1><h3 id="1-一个项目启动多个实例"><a href="#1-一个项目启动多个实例" class="headerlink" title="1.一个项目启动多个实例"></a>1.一个项目启动多个实例</h3><p>==问题提示：==允许多个实例运行后，直接修改原配置文件。导致原java进程也改变了服务端口，原java进程是基于target文件夹未压缩的class文件运行的。</p><p>==解决办法：==</p><ol><li>设置允许多实例运行。</li></ol><p><img src="/2024/02/14/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0~%EF%BC%89/image-20240204233858018.png" alt="image-20240204233858018"></p><ol start="2"><li>在service窗口复制配置。</li></ol><p><img src="/2024/02/14/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0~%EF%BC%89/image-20240204233957103.png" alt="image-20240204233957103"></p><ol start="3"><li>在环境变量修改服务端口号和其它使用到的端口号。</li></ol><p><img src="/2024/02/14/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0~%EF%BC%89/image-20240204234148489.png" alt="image-20240204234148489"></p><ol start="4"><li>运行该配置。</li></ol><h3 id="2-xml文件未引入spring-boot项目"><a href="#2-xml文件未引入spring-boot项目" class="headerlink" title="2.xml文件未引入spring boot项目"></a>2.xml文件未引入spring boot项目</h3><p>==问题提示：==spring boot项目下编写xml文件到resources目录提示Application context not configured for this file</p><p><img src="/2024/02/14/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0~%EF%BC%89/image-20240205091824617.png" alt="image-20240205091824617"></p><p>==解决办法：==原因是idea识别到xml文件未引入项目。需要在spring boot启动类上加注解<code>@ImportResource(&#123;&quot;classpath:dubbo-consumer.xml&quot;&#125;)</code>用于引入在.xml文件中定义的beans。</p><h1 id="跨域配置方案"><a href="#跨域配置方案" class="headerlink" title="跨域配置方案"></a>跨域配置方案</h1><h2 id="1-微服务跨域配置"><a href="#1-微服务跨域配置" class="headerlink" title="1.微服务跨域配置"></a>1.微服务跨域配置</h2><p>参考博客：<a href="https://blog.csdn.net/leijie0322/article/details/127415396">https://blog.csdn.net/leijie0322/article/details/127415396</a></p><p><a href="https://www.cnblogs.com/cndarren/p/17265441.html">https://www.cnblogs.com/cndarren/p/17265441.html</a></p><p><strong>方案一</strong>：使用 Spring MVC 提供的 WebMvcConfigurer 提供的跨域解决方案。这时会在DispatcherServlet的拦截器CorsInterceptor中校验请求并设置响应的响应头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 覆盖所有请求</span></span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                <span class="comment">// 允许发送 Cookie</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">                <span class="comment">// 放行哪些域名（必须用 patterns，否则 * 会和 allowCredentials 冲突）</span></span><br><span class="line">                .allowedOriginPatterns(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .exposedHeaders(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方案二</strong>：使用 Servlet Filter 支持的Spring 提供的CorsFilter跨域解决方案。这时在过滤器层面就解决了跨域设置了响应头。(<strong>推荐</strong>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCorsFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cors跨域处理过滤器</span></span><br><span class="line"><span class="comment">     * 优先级最高</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean&lt;CorsFilter&gt; <span class="title function_">corsFilter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">corsConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line">        corsConfiguration.addAllowedOriginPattern(CorsConfiguration.ALL);</span><br><span class="line">        corsConfiguration.addAllowedMethod(CorsConfiguration.ALL);</span><br><span class="line">        corsConfiguration.addAllowedHeader(CorsConfiguration.ALL);</span><br><span class="line">        corsConfiguration.addExposedHeader(CorsConfiguration.ALL);</span><br><span class="line"></span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>,corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> createFilterRegistrationBean(<span class="keyword">new</span> <span class="title class_">CorsFilter</span>(source),CORS_FILTER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  &lt;T <span class="keyword">extends</span> <span class="title class_">Filter</span>&gt; FilterRegistrationBean&lt;T&gt; <span class="title function_">createFilterRegistrationBean</span><span class="params">(T filter, <span class="type">int</span> order)</span> &#123;</span><br><span class="line">        FilterRegistrationBean&lt;T&gt; registrationBean = <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>&lt;&gt;(filter);</span><br><span class="line">        registrationBean.setOrder(order);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-gateway网关跨域配置"><a href="#2-gateway网关跨域配置" class="headerlink" title="2.gateway网关跨域配置"></a>2.gateway网关跨域配置</h2><p>注意：网关要使用 <strong>lb://微服务名</strong> 一定要添加loadbalance依赖。</p><p><strong>方案一</strong>：直接通过application.yaml文件进行配置（<strong>推荐</strong>）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="comment"># 解决双重跨域</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">DedupeResponseHeader=Vary</span> <span class="string">Access-Control-Allow-Origin</span> <span class="string">Access-Control-Allow-Headers</span> <span class="string">Access-Control-Allow-Credentials,RETAIN_UNIQUE</span></span><br><span class="line">      <span class="attr">globalcors:</span></span><br><span class="line">        <span class="comment"># 解决options请求被拦截问题</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 全局的跨域配置</span></span><br><span class="line">        <span class="attr">cors-configurations:</span></span><br><span class="line">          <span class="comment"># 拦截的请求</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOriginPatterns:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">            <span class="comment"># 允许请求中携带的头信息</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">            <span class="comment"># 运行跨域的请求方式</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">            <span class="comment"># 是否允许携带cookie</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span></span><br><span class="line">            <span class="comment"># 跨域检测的有效期,单位s</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">36000</span></span><br></pre></td></tr></table></figure><p>如果**在 Spring Cloud 网关处配置跨域处理，则需要注入 <code>CorsWebFilter</code>**，这是因为 Spring Cloud Gateway 是 WebFlux 的，并不采用 Servlet 体系。</p><p><strong>方案二</strong>：使用 Spring 提供的 <code>CorsWebFilter</code> 实现gateway跨域问题解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCorsConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsWebFilter <span class="title function_">corsWebFilter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.配置跨域</span></span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">corsConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        <span class="comment">// 1.1这里仅为了说明问题，配置为放行所有域名，生产环境请对此进行修改</span></span><br><span class="line">        corsConfiguration.addAllowedOriginPattern(CorsConfiguration.ALL);<span class="comment">//坑</span></span><br><span class="line">        <span class="comment">// 1.2放行的请求头</span></span><br><span class="line">        corsConfiguration.addAllowedHeader(CorsConfiguration.ALL);</span><br><span class="line">        <span class="comment">// 暴露头部信息</span></span><br><span class="line">        corsConfiguration.addExposedHeader(CorsConfiguration.ALL);</span><br><span class="line">        <span class="comment">// 1.3放行的请求方式，主要有：GET, POST, PUT, DELETE, OPTIONS</span></span><br><span class="line">        corsConfiguration.addAllowedMethod(CorsConfiguration.ALL);</span><br><span class="line">        <span class="comment">// 1.4是否发送cookie</span></span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>,corsConfiguration);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsWebFilter</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>最近遇到的数据库被勒索😈😈😈</p><p><img src="/2024/02/14/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0~%EF%BC%89/image-20240214110013598.png" alt="image-20240214110013598"></p><p>笑嘻嘻，建议大家数据库密码还是要设置复制一些</p><p>永久修改CMD窗口编码：<a href="https://learnku.com/articles/55553">https://learnku.com/articles/55553</a></p><p><img src="/2024/02/14/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0~%EF%BC%89/image-20240401151813867.png" alt="image-20240401151813867"></p><p><a href="https://blog.csdn.net/ccboy2009/article/details/127142652">https://blog.csdn.net/ccboy2009/article/details/127142652</a></p>]]></content>
      
      
      <categories>
          
          <category> 汇总 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇总 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux虚拟机的创建（基于VirtualBox）</title>
      <link href="/2023/01/06/Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%88%E5%9F%BA%E4%BA%8EVirtualBox%EF%BC%89/"/>
      <url>/2023/01/06/Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%88%E5%9F%BA%E4%BA%8EVirtualBox%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、安装VirtualBox"><a href="#一、安装VirtualBox" class="headerlink" title="一、安装VirtualBox"></a>一、安装VirtualBox</h2><p>1.下载VirtualBox</p><p>下载地址：<a href="https://download.virtualbox.org/virtualbox/6.0.10/VirtualBox-6.0.10-132072-Win.exe">https://download.virtualbox.org/virtualbox/6.0.10/VirtualBox-6.0.10-132072-Win.exe</a></p><p>2.开始安装</p><img src="\img\3\image-20230106175835756.png" alt="image-20230106175835756" style="zoom:50%;" /><p>3.更改安装路径，下一步。后续默认选项进行安装。</p><img src="\img\3\image-20230106180015348.png" alt="image-20230106180015348" style="zoom:50%;" /><img src="\img\3\image-20230106180112522.png" alt="image-20230106180112522" style="zoom:50%;" /><h2 id="二、利用Vagrant安装Centos的镜像快速创建虚拟机"><a href="#二、利用Vagrant安装Centos的镜像快速创建虚拟机" class="headerlink" title="二、利用Vagrant安装Centos的镜像快速创建虚拟机"></a>二、利用Vagrant安装Centos的镜像快速创建虚拟机</h2><p>1.安装Vagrant</p><p>安装包下载地址：<a href="https://releases.hashicorp.com/vagrant/2.2.5/vagrant_2.2.5_x86_64.msi">https://releases.hashicorp.com/vagrant/2.2.5/vagrant_2.2.5_x86_64.msi</a></p><p>按默认步骤安装即可，安装后需要重启电脑。</p><p>2.安装虚拟机镜像</p><p>打开CMD命令行，输入下方命令，即在当前目录创建了Vagrantfile文件。执行vagrant up后就完成了虚拟机的基本创建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vagrant init centos #初始化</span><br><span class="line"></span><br><span class="line">vagrant up #联网安装虚拟机镜像</span><br><span class="line"></span><br><span class="line">vagrant ssh #连接虚拟机</span><br></pre></td></tr></table></figure><img src="\img\3\image-20230106185103294.png" alt="image-20230106185103294" style="zoom:100%;" /><img src="\img\3\image-20230106185853296.png" alt="image-20230106185853296" style="zoom:60%;" /><h2 id="三、配置网络IP"><a href="#三、配置网络IP" class="headerlink" title="三、配置网络IP"></a>三、配置网络IP</h2><p>默认虚拟机的ip地址不是固定ip，开发不方便。</p><p>1.使用ipconfig查看virtualbox的网卡地址，我们设置的地址需要与此地址保证同一网段，如图应设为192.168.56.*。</p><img src="\img\3\image-20230106191841746.png" alt="image-20230106191841746" style="zoom:60%;" /><p>2.修改Vagrantfile文件配置ip地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.network &quot;private_network&quot;, ip: &quot;192.168.56.10&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux虚拟机的创建（基于VMware）</title>
      <link href="/2023/01/06/Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%88%E5%9F%BA%E4%BA%8EVMware%EF%BC%89/"/>
      <url>/2023/01/06/Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%88%E5%9F%BA%E4%BA%8EVMware%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、配置硬件"><a href="#一、配置硬件" class="headerlink" title="一、配置硬件"></a>一、配置硬件</h2><p>1.点击“创建新的虚拟机”，打开向导，点击自定义。</p><img src="\img\2\image-20230105232534485.png" alt="image-20230105232534485" style="zoom: 33%;" /><img src="\img\2\image-20230105232648819.png" alt="image-20230105232648819" style="zoom:50%;" /><img src="\img\2\image-20230105232852309.png" alt="image-20230105232852309" style="zoom:50%;" /><p>2.点击“稍后安装操作系统”，先配置硬件，再安装操作系统软件，点击下一步。选择预安装操作系统和对应的版本，点击下一步。</p><img src="\img\2\image-20230105233000827.png" alt="image-20230105233000827" style="zoom:50%;" /><img src="\img\2\image-20230105233138197.png" alt="image-20230105233138197" style="zoom:50%;" /><p>3.修改你的虚拟机名字，和虚拟机文件保存位置，点击下一步。</p><img src="\img\2\image-20230105233358467.png" alt="image-20230105233358467" style="zoom:50%;" /><p>4.设置CPU核数、内存、网络连接、硬盘、设置磁盘地址（最好与虚拟机文件地址一致），最后点击完成。</p><img src="\img\2\image-20230105233841558.png" alt="image-20230105233841558" style="zoom:50%;" /><img src="\img\2\image-20230105234003887.png" alt="image-20230105234003887" style="zoom:50%;" /><img src="\img\2\image-20230105234206932.png" alt="image-20230105234206932" style="zoom:50%;" /><img src="\img\2\image-20230105234308080.png" alt="image-20230105234308080" style="zoom:50%;" /><img src="\img\2\image-20230105234531880.png" alt="image-20230105234531880" style="zoom:50%;" /><img src="\img\2\image-20230105234651303.png" alt="image-20230105234651303" style="zoom:50%;" /><img src="\img\2\image-20230105234753243.png" alt="image-20230105234753243" style="zoom:50%;" /><h2 id="二、安装系统软件"><a href="#二、安装系统软件" class="headerlink" title="二、安装系统软件"></a>二、安装系统软件</h2><p>1.导入Linux的镜像ISO文件。</p><img src="\img\2\image-20230105235222902.png" alt="image-20230105235222902" style="zoom: 33%;" /><img src="\img\2\image-20230105235337839.png" alt="image-20230105235337839" style="zoom:50%;" /><p>2.点击开启虚拟机，开始系统的安装过程，这部分简单跳过，只展示出一些重点步骤的建议选项。</p><img src="\img\2\image-20230105235435033.png" alt="image-20230105235435033" style="zoom: 33%;" /><img src="\img\2\image-20230106000421051.png" alt="image-20230106000421051" style="zoom:50%;" /><p>3.配置分区，1g的/boot文件系统改为标准分区ext4,4g的/swap文件系统为swap，55g的/文件系统为标准分区ext4。</p><img src="\img\2\image-20230106000721768.png" alt="image-20230106000721768" style="zoom:50%;" /><img src="\img\2\image-20230106000815789.png" alt="image-20230106000815789" style="zoom:50%;" /><img src="\img\2\image-20230106001003169.png" alt="image-20230106001003169" style="zoom:50%;" /><img src="\img\2\image-20230106001541753.png" alt="image-20230106001541753" style="zoom:50%;" /><img src="\img\2\image-20230106001848334.png" alt="image-20230106001848334" style="zoom:50%;" /><h2 id="三、配置网络IP和主机名称和主机名称映射"><a href="#三、配置网络IP和主机名称和主机名称映射" class="headerlink" title="三、配置网络IP和主机名称和主机名称映射"></a>三、配置网络IP和主机名称和主机名称映射</h2><p>1.配置静态的IP地址和主机名称。注意IP地址需要配置VMware和windows的和linux的，参考<a href="https://www.bilibili.com/video/BV1Qp4y1n7EN/?p=20&amp;vd_source=b17973d85879e1da10ae411ab7cb16ee%E3%80%82">https://www.bilibili.com/video/BV1Qp4y1n7EN/?p=20&amp;vd_source=b17973d85879e1da10ae411ab7cb16ee。</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-ens33 #修改linux的静态ip配置 </span><br><span class="line"></span><br><span class="line">vim /etc/hostname #修改主机名称</span><br><span class="line"></span><br><span class="line">vim /etc/hosts #配置主机名称映射</span><br><span class="line"></span><br><span class="line">reboot #最后要重启生效</span><br></pre></td></tr></table></figure><p>/etc/sysconfig/network-scripts/ifcfg-ens33配置如下</p><img src="\img\2\image-20230106011126473.png" alt="image-20230106001848334" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《新业务政策和标准》12月</title>
      <link href="/2023/01/05/%E6%96%B0%E4%B8%9A%E5%8A%A1%E6%94%BF%E7%AD%96%E5%92%8C%E6%A0%87%E5%87%8612%E6%9C%88/"/>
      <url>/2023/01/05/%E6%96%B0%E4%B8%9A%E5%8A%A1%E6%94%BF%E7%AD%96%E5%92%8C%E6%A0%87%E5%87%8612%E6%9C%88/</url>
      
        <content type="html"><![CDATA[<h2 id="第一部分-国家法律法规"><a href="#第一部分-国家法律法规" class="headerlink" title="第一部分 国家法律法规"></a>第一部分 国家法律法规</h2><h3 id="中共中央、国务院印发《扩大内需战略规划纲要（2022－2035年）》（12月14日）"><a href="#中共中央、国务院印发《扩大内需战略规划纲要（2022－2035年）》（12月14日）" class="headerlink" title="中共中央、国务院印发《扩大内需战略规划纲要（2022－2035年）》（12月14日）"></a>中共中央、国务院印发《扩大内需战略规划纲要（2022－2035年）》（12月14日）</h3><p>  《纲要》提出，加大生态环保设施建设力度。全面提升生态环境基础设施水平，构建集污水、垃圾、固废、危废、医废处理处置设施和监测监管能力于一体的环境基础设施体系，形成由城市向建制镇和乡村延伸覆盖的环境基础设施网络。实施重要生态系统保护和修复重大工程。推动建立生态保护补偿制度。全面推进资源高效利用，建设促进提高清洁能源利用水平、降低二氧化碳排放的生态环保设施。</p><h3 id="生态环境部印发《企业温室气体排放核算与报告指南-发电设施》和《企业温室气体排放核查技术指南-发电设施》（12月21日）"><a href="#生态环境部印发《企业温室气体排放核算与报告指南-发电设施》和《企业温室气体排放核查技术指南-发电设施》（12月21日）" class="headerlink" title="生态环境部印发《企业温室气体排放核算与报告指南 发电设施》和《企业温室气体排放核查技术指南 发电设施》（12月21日）"></a>生态环境部印发《企业温室气体排放核算与报告指南 发电设施》和《企业温室气体排放核查技术指南 发电设施》（12月21日）</h3><p>  为进一步提升碳排放数据质量，完善全国碳排放权交易市场制度机制，增强技术规范的科学性、合理性和可操作性，12月21日，生态环境部印发《企业温室气体排放核算与报告指南 发电设施》《企业温室气体排放核查技术指南 发电设施》的通知。</p><h2 id="第二部分-地方法律法规"><a href="#第二部分-地方法律法规" class="headerlink" title="第二部分 地方法律法规"></a>第二部分 地方法律法规</h2><h3 id="贵州省人民政府印发《关于加快建立健全绿色低碳循环发展经济体系的实施意见》（11月30日）"><a href="#贵州省人民政府印发《关于加快建立健全绿色低碳循环发展经济体系的实施意见》（11月30日）" class="headerlink" title="贵州省人民政府印发《关于加快建立健全绿色低碳循环发展经济体系的实施意见》（11月30日）"></a>贵州省人民政府印发《关于加快建立健全绿色低碳循环发展经济体系的实施意见》（11月30日）</h3><p>  《意见》提出，推进医疗废物信息化管理，实现一级以上医疗机构医疗废物可追溯，并逐步向乡镇卫生院、社区卫生服务中心延伸。推进设市城市实现餐厨垃圾处理能力全覆盖。加快县域生活垃圾焚烧处理全覆盖，配套建设焚烧飞灰处理设施，全省基本实现原生生活垃圾“零填埋”。</p><h3 id="北京市城管委员会印发《北京市”十四五”时期环境卫生事业发展规划》（12月21日）"><a href="#北京市城管委员会印发《北京市”十四五”时期环境卫生事业发展规划》（12月21日）" class="headerlink" title="北京市城管委员会印发《北京市”十四五”时期环境卫生事业发展规划》（12月21日）"></a>北京市城管委员会印发《北京市”十四五”时期环境卫生事业发展规划》（12月21日）</h3><p>  《规划》提出，强化科技赋能。开展恶臭污染物治理、渗滤液及浓缩液处理、厨余垃圾就地处理、小型化垃圾焚烧处理和焚烧炉渣资源化利用等技术研发与集成应用。</p><p>  有序推进厨余垃圾处理设施建设。2025年底前建成顺义、平谷、密云等区厨余垃圾处理技改、应急、新（扩）建项目，力争全市处理能力达到9000吨/日以上，补齐处理能力短板。推动农村地区厨余垃圾与农林有机废弃物协同处理，减少垃圾出村。加强废弃油脂回收、处置规范化管理体系建设。</p><h3 id="北京市发展改革委发布《关于征集基础设施REITs试点储备项目有关工作的通知》（12月19日）"><a href="#北京市发展改革委发布《关于征集基础设施REITs试点储备项目有关工作的通知》（12月19日）" class="headerlink" title="北京市发展改革委发布《关于征集基础设施REITs试点储备项目有关工作的通知》（12月19日）"></a>北京市发展改革委发布《关于征集基础设施REITs试点储备项目有关工作的通知》（12月19日）</h3><p>  《通知》指出，试点行业范围包括能源基础设施。包括风电、光伏发电、水力发电、天然气发电、生物质发电、核电等清洁能源项目，特高压输电项目，增量配电网、微电网、充电基础设施项目，分布式冷热电项目。</p><p>  还包括生态环保基础设施。包括城镇污水垃圾处理及资源化利用环境基础设施、固废危废医废处理环境基础设施、大宗固体废弃物综合利用基础设施项目。</p><h3 id="上海市经济信息化委等四部门联合印发《上海市工业领域碳达峰实施方案》（12月9日）"><a href="#上海市经济信息化委等四部门联合印发《上海市工业领域碳达峰实施方案》（12月9日）" class="headerlink" title="上海市经济信息化委等四部门联合印发《上海市工业领域碳达峰实施方案》（12月9日）"></a>上海市经济信息化委等四部门联合印发《上海市工业领域碳达峰实施方案》（12月9日）</h3><p>  《方案》提出，推动碳捕集利用与封存(CCUS)应用场景向化工、钢铁等其他行业拓展，加快与储能、氢能等技术的集成发展。大力推进氢能应用研究，研发清洁、高效、经济的工业副产氢提纯制氢技术，突破高能效氢燃料电池系统、长寿命电堆、质子交换膜等关键技术。推动高压供氢加氢设备、70兆帕储氢瓶等多重储运技术的应用。开展兆瓦级风力、光伏等新能源电解水制氢集成及应用示范。</p><p>  强化行业和区域协同处置能力。推进工业窑炉、工业企业间点对点协同处置固废，开展燃煤电厂、生活垃圾焚烧设施对市政污泥、工业固废、建筑垃圾等的协同处置，试点示范有机污泥、餐厨垃圾等在生物质能上的应用。</p><h3 id="上海市生态环境局印发《上海市“无废城市”建设工作方案（征求意见稿）》（11月29日）"><a href="#上海市生态环境局印发《上海市“无废城市”建设工作方案（征求意见稿）》（11月29日）" class="headerlink" title="上海市生态环境局印发《上海市“无废城市”建设工作方案（征求意见稿）》（11月29日）"></a>上海市生态环境局印发《上海市“无废城市”建设工作方案（征求意见稿）》（11月29日）</h3><p>  《方案》提出，全面实现原生生活垃圾零填埋。按照资源化利用和无害化处置并举的原则，继续推进宝山、浦东海滨等生活垃圾焚烧项目和老港二期、宝山湿垃圾项目建设，在老港、闵行、嘉定、松江、青浦、奉贤、崇明等区域再新建一批湿垃圾集中处理设施。</p><p>  建立平战结合的医疗废物收运处置体系。完善医疗废物应急收运处置体系，将生活垃圾焚烧设施纳入本市医疗废物应急处置设施清单。</p><p>  落实燃煤电厂、生活垃圾焚烧设施协同处置市政污泥、工业固废、建筑垃圾残渣等。妥善处理处置污泥。结合污水厂新建、扩建工程，完成浦东、嘉定、青浦等区污泥干化焚烧设施建设，推进燃煤电厂和垃圾焚烧厂污泥掺烧，到2025年实现全市污水厂污泥零填埋。新建一批通沟污泥处理设施，新增处理能力共计约10.5万吨/年。</p><h3 id="西藏自治区人民政府办公厅印发《西藏自治区“十四五”时期“无废城市”建设工作方案》（12月2日）"><a href="#西藏自治区人民政府办公厅印发《西藏自治区“十四五”时期“无废城市”建设工作方案》（12月2日）" class="headerlink" title="西藏自治区人民政府办公厅印发《西藏自治区“十四五”时期“无废城市”建设工作方案》（12月2日）"></a>西藏自治区人民政府办公厅印发《西藏自治区“十四五”时期“无废城市”建设工作方案》（12月2日）</h3><p>  《方案》要求，各市要因地制宜推进简便易行的垃圾分类和资源化利用方法，加强易腐烂垃圾就地处理和资源化利用。探索开展农村生活垃圾分类和资源化利用示范县创建工作。探索建设小型化、分散化、无害化处理设施，推进农牧区生活垃圾就地就近处理。各相关市95%的行政村实现农村生活垃圾收运处置体系全覆盖。</p><p>  实施好自治区危险废物处置中心二期项目和地(市)级医疗废物处置中心提标改造项目建设,有效提升危险废物(医疗废物)处置能力。加快推动日喀则市、山南市所辖偏远县小型医疗废物处置设施建设,解决医疗废物运距远、处置不及时的问题。</p><h3 id="宁夏回族自治区第十二届人民代表大会常务委员会通过《宁夏回族自治区固体废物污染环境防治条例》（11月30日）"><a href="#宁夏回族自治区第十二届人民代表大会常务委员会通过《宁夏回族自治区固体废物污染环境防治条例》（11月30日）" class="headerlink" title="宁夏回族自治区第十二届人民代表大会常务委员会通过《宁夏回族自治区固体废物污染环境防治条例》（11月30日）"></a>宁夏回族自治区第十二届人民代表大会常务委员会通过《宁夏回族自治区固体废物污染环境防治条例》（11月30日）</h3><p>  《条例》指出，产生、收集厨余垃圾的单位和其他生产经营者应当将厨余垃圾交由具备相应资质条件的单位进行无害化处理。禁止将厨余垃圾资源化产品作为食品销售或者用于食品生产。</p><p>  县级以上人民政府应当建立重大传染病疫情医疗废物应急处置保障体系，将危险废物焚烧设施、生活垃圾焚烧设施等纳入应急处置保障体系，明确集中隔离场所、封闭管理区域涉疫情医疗废物和生活垃圾的收集、贮存、运输要求，保障重大传染病疫情医疗废物处置安全。</p><p>  县级以上人民政府应当制定工业固体废物污染环境防治工作规划，组织建设工业固体废物集中处置等设施，支持推广减少工业固体废物产生量和降低工业固体废物危害性的生产工艺和设备，推动工业固体废物污染环境防治工作。</p><p>  城镇污水处理设施维护运营单位或者污泥处理处置单位应当安全处理处置污泥，保证处理处置后的污泥符合国家标准，建立污泥管理台账，对产生的污泥以及处理处置后的污泥去向、用途、用量等进行跟踪、记录，并向城镇排水、生态环境主管部门报告。</p><h3 id="河南省生态环境厅发布《河南省固体废物污染环境防治条例（征求意见稿）》（12月1日）"><a href="#河南省生态环境厅发布《河南省固体废物污染环境防治条例（征求意见稿）》（12月1日）" class="headerlink" title="河南省生态环境厅发布《河南省固体废物污染环境防治条例（征求意见稿）》（12月1日）"></a>河南省生态环境厅发布《河南省固体废物污染环境防治条例（征求意见稿）》（12月1日）</h3><p>  《条例》指出，县级以上人民政府统筹负责本行政区域内医疗废物收集、贮存、运输、处置体系的建设工作，实现县级以上医疗废物全收集、全处理，并逐步延伸到村镇地区。人口密集的县（市）可建设县级医疗废物处置设施。鼓励边远地区医疗机构配置移动式或小型处理设备实现就地消毒处理。</p><p>  新建、改建和扩建城镇污水处理厂，应当规划、建设污泥处理处置设施，保证污水处理厂产生的污泥无害化处置。</p><h3 id="宁夏回族自治区生态环境厅发布《宁夏回族自治区可再生能源发展“十四五”规划》（12月5日）"><a href="#宁夏回族自治区生态环境厅发布《宁夏回族自治区可再生能源发展“十四五”规划》（12月5日）" class="headerlink" title="宁夏回族自治区生态环境厅发布《宁夏回族自治区可再生能源发展“十四五”规划》（12月5日）"></a>宁夏回族自治区生态环境厅发布《宁夏回族自治区可再生能源发展“十四五”规划》（12月5日）</h3><p>  《规划》提出，宁夏自治区将加快推进垃圾发电在地级市全覆盖。加快建设固原、石嘴山等生活垃圾焚烧发电项目，实现地级市全覆盖目标。结合社会人口经济发展和城镇化建设进程，适时启动银川扩建、同心等生活垃圾焚烧发电项目。到2025年，垃圾焚烧发电处理能力超过5000吨/天，装机规模达到10万千瓦。</p><p>  大力发展离网型新能源电解水制氢，打造宁东光伏产业园绿氢规模化生产基地。培育风光+氢储能一体化应用模式，积极创建宁东可再生能源制氢耦合煤化工产业示范区，通过绿氢耦合煤制油、煤制烯烃、煤制乙二醇、煤基多联产等项目，推动灰氢转绿、以氢换煤、绿氢消碳。到2025年，力争绿氢生产规模达到8万吨/年。</p><p>  推广生物质成型燃料供热应用。结合清洁取暖、农村散煤治理和燃煤锅炉拆除等工作，加快生物质成型燃料在工业供热和民用采暖等领域推广应用。</p><h3 id="江西省住房和城乡建设厅等六部门联合印发《关于进一步加强农村生活垃圾收运处置体系建设管理的实施意见》（11月28日）"><a href="#江西省住房和城乡建设厅等六部门联合印发《关于进一步加强农村生活垃圾收运处置体系建设管理的实施意见》（11月28日）" class="headerlink" title="江西省住房和城乡建设厅等六部门联合印发《关于进一步加强农村生活垃圾收运处置体系建设管理的实施意见》（11月28日）"></a>江西省住房和城乡建设厅等六部门联合印发《关于进一步加强农村生活垃圾收运处置体系建设管理的实施意见》（11月28日）</h3><p>  《意见》指出，各地要按照生活垃圾收运处置体系自然村(村民小组)全覆盖的要求，合理配置收运处置设施设备，实现自然村有收集点(站)、乡镇有转运能力、县城有无害化处理能力。逐步取缔露天收集池，更新老旧破损垃圾收集容器，推动处理设施设备升级换代，建设一批小型化、分散化、无害化的生活垃圾处理设施。</p><h3 id="云南省第十三届人民代表大会常务委员会通过《云南省固体废物污染环境防治条例》（11月30日）"><a href="#云南省第十三届人民代表大会常务委员会通过《云南省固体废物污染环境防治条例》（11月30日）" class="headerlink" title="云南省第十三届人民代表大会常务委员会通过《云南省固体废物污染环境防治条例》（11月30日）"></a>云南省第十三届人民代表大会常务委员会通过《云南省固体废物污染环境防治条例》（11月30日）</h3><p>  《条例》提出，医疗卫生机构应当依法分类收集本单位产生的医疗废物，交由医疗废物集中处置单位处置。医疗废物集中处置单位应当及时收集、运输和处置医疗废物。鼓励发展移动式医疗废物处置设施，为偏远地区提供处置服务。</p><p>  县级以上人民政府城镇排水主管部门应当将污泥处理设施纳入城镇排水与污水处理规划，推动同步建设污泥处理设施与污水处理设施，鼓励协同处理，不断提高污泥综合利用和无害化处理水平。</p><h3 id="湖南省工业和信息化厅印发《湖南省工业领域碳达峰实施方案》（12月21日）"><a href="#湖南省工业和信息化厅印发《湖南省工业领域碳达峰实施方案》（12月21日）" class="headerlink" title="湖南省工业和信息化厅印发《湖南省工业领域碳达峰实施方案》（12月21日）"></a>湖南省工业和信息化厅印发《湖南省工业领域碳达峰实施方案》（12月21日）</h3><p>  《方案》提出，建立数字化碳管理体系。加强信息技术在能源消费与碳排放等领域的开发应用，鼓励企业基于能源管控系统建立数字化碳管理平台，协同推进用能数据与碳排放数据的收集、分析和管理。探索建设碳达峰碳中和综合服务平台，建立产品全生命周期碳排放基础数据库，深化重点行业碳排放实时监测。</p><p>  有序推进重点行业企业碳排放报告与核查机制，引导重点企业对标建立碳排放报告和信息披露制度。积极开展重点行业建设项目碳排放环境影响评价。引导企业积极参与绿电交易，做好绿电交易与绿证交易、碳排放权交易的衔接。</p><h3 id="吉林省人民政府办公厅印发《关于进一步加强生活垃圾处理工作的指导意见》（12月30日）"><a href="#吉林省人民政府办公厅印发《关于进一步加强生活垃圾处理工作的指导意见》（12月30日）" class="headerlink" title="吉林省人民政府办公厅印发《关于进一步加强生活垃圾处理工作的指导意见》（12月30日）"></a>吉林省人民政府办公厅印发《关于进一步加强生活垃圾处理工作的指导意见》（12月30日）</h3><p>  《意见》提出，推进生活垃圾焚烧处理设施建设，到2023年底，基本实现原生生活垃圾“零填埋”。到2025年底，生活垃圾焚烧处理能力进一步提升，地级及以上城市基本具备厨余垃圾集中处理能力。</p><p>  推进厨余垃圾处理。实施生活垃圾分类试点的城市要加快出台相关法规制度，明确厨余垃圾处理要求，以集中处理为主，分散处理为辅，有序推进厨余垃圾处理设施建设。鼓励厨余垃圾处理设施与生活垃圾焚烧处理设施同步、就近建设。</p>]]></content>
      
      
      <categories>
          
          <category> 政策 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 政策 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客搭建（基于HEXO）</title>
      <link href="/2023/01/04/%E5%BF%AB%E9%80%9F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%88%E5%9F%BA%E4%BA%8EHEXO%EF%BC%89/"/>
      <url>/2023/01/04/%E5%BF%AB%E9%80%9F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%88%E5%9F%BA%E4%BA%8EHEXO%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="个人博客搭建（基于HEXO）"><a href="#个人博客搭建（基于HEXO）" class="headerlink" title="个人博客搭建（基于HEXO）"></a>个人博客搭建（基于HEXO）</h1><h2 id="一、安装环境"><a href="#一、安装环境" class="headerlink" title="一、安装环境"></a>一、安装环境</h2><h3 id="1-安装node-js"><a href="#1-安装node-js" class="headerlink" title="1.安装node.js"></a>1.安装node.js</h3><ul><li>下载node.js二进制安装包，这一步需要注意node.js与centos版本的匹配与兼容。</li></ul><img src="/img/1/image-20230104121014067.png" alt="image-20230104121014067" style="zoom:50%;" /><ul><li><p>下载后根据<a href="https://github.com/nodejs/help/wiki/Installation%E6%95%99%E7%A8%8B%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85%E3%80%82">https://github.com/nodejs/help/wiki/Installation教程进行安装。</a></p><ol><li>Unzip the binary archive to any directory you wanna install Node, I use <code>/usr/local/lib/nodejs</code></li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VERSION=v10.15.0</span><br><span class="line">DISTRO=linux-x64</span><br><span class="line">sudo mkdir -p /usr/local/lib/nodejs</span><br><span class="line">sudo tar -xJvf node-$VERSION-$DISTRO.tar.xz -C /usr/local/lib/nodejs </span><br></pre></td></tr></table></figure><ol start="2"><li>Set the environment variable <code>~/.profile</code>, add below to the end</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Nodejs</span><br><span class="line">VERSION=v10.15.0</span><br><span class="line">DISTRO=linux-x64</span><br><span class="line">export PATH=/usr/local/lib/nodejs/node-$VERSION-$DISTRO/bin:$PATH</span><br></pre></td></tr></table></figure><ol start="3"><li>Refresh profile</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. ~/.profile</span><br></pre></td></tr></table></figure><ol start="4"><li>Test installation using</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">$ npm version</span><br><span class="line">$ npx -v</span><br></pre></td></tr></table></figure><ul><li>安装cnpm</li></ul><p>由于npm很慢，我们安装cnpm并配置淘宝镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><ul><li>成功案例：博主使用centos7.5，node.js v16.9.0</li></ul><img src="/img/1/image-20230104121257507.png" alt="image-20230104121257507" style="zoom:50%;" /><ul><li>注意node.js版本限制，最好安装12.13.0以上的版本。</li></ul><img src="/img/1/image-20230104121449564.png" alt="image-20230104121449564" style="zoom:50%;" /><h3 id="2-安装HEXO"><a href="#2-安装HEXO" class="headerlink" title="2.安装HEXO"></a>2.安装HEXO</h3><ul><li>用cnpm包管理工具安装hexo</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><ul><li>验证安装完成hexo -v</li></ul><img src="/img/1/image-20230104123816448.png" alt="image-20230104123816448" style="zoom:50%;" /><h2 id="3-创建blog工程文件夹"><a href="#3-创建blog工程文件夹" class="headerlink" title="3.创建blog工程文件夹"></a>3.创建blog工程文件夹</h2>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
