<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring-Security源码解析与实战（持续更新）</title>
      <link href="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
      <url>/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Spring Security是一个提供了<strong>认证、授权、常见攻击保护</strong>的框架。适用于非响应式、响应式编程的项目。是基于 <strong>Spring AOP</strong> 和 <strong>Servlet 过滤器</strong>的安全框架，提供全面的安全性解决方案。</p><p>Spring Security 中<a href="https://www.javaboy.org/2020/0617/authorize-springsecurity.html">四种常见的权限控制方式</a>。</p><ul><li>表达式控制 URL 路径权限</li><li>表达式控制方法权限</li><li>使用过滤注解</li><li>动态权限</li></ul><h1 id="一、过滤器解析"><a href="#一、过滤器解析" class="headerlink" title="一、过滤器解析"></a>一、过滤器解析</h1><p>过滤器链<strong>采用的是责任链的设计模式</strong>，它有一条很长的过滤器链。</p><h2 id="1-ChannelProcessingFilter"><a href="#1-ChannelProcessingFilter" class="headerlink" title="1.ChannelProcessingFilter"></a>1.ChannelProcessingFilter</h2><p>通常是用来过滤哪些请求必须用 https 协议， 哪些请求必须用 http协议， 哪些请求随便用哪个协议都行。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) req;</span><br><span class="line">   <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) res;</span><br><span class="line">   <span class="type">FilterInvocation</span> <span class="variable">filterInvocation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterInvocation</span>(request, response, chain);</span><br><span class="line">   Collection&lt;ConfigAttribute&gt; attributes = <span class="built_in">this</span>.securityMetadataSource.getAttributes(filterInvocation);</span><br><span class="line">   <span class="keyword">if</span> (attributes != <span class="literal">null</span>) &#123;</span><br><span class="line">      。。。日志</span><br><span class="line">      <span class="built_in">this</span>.channelDecisionManager.decide(filterInvocation, attributes);</span><br><span class="line">      <span class="keyword">if</span> (filterInvocation.getResponse().isCommitted()) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-WebAsyncManagerIntegrationFilter"><a href="#2-WebAsyncManagerIntegrationFilter" class="headerlink" title="2.WebAsyncManagerIntegrationFilter"></a>2.WebAsyncManagerIntegrationFilter</h2><p>用于<strong>集成 SecurityContext 到Spring异步执行机制中</strong>。通过 SecurityContextCallableProcessingInterceptor.beforeConcurrentHandling()就可以将 SecurityContext 传递给异步线程。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><br><span class="line">      <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">   <span class="comment">//1.获取 WebAsyncManager异步管理器</span></span><br><span class="line">   <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">   <span class="comment">//2.从异步管理器获取过滤器对应的SecurityContextCallableProcessingInterceptor</span></span><br><span class="line">   <span class="comment">// 检查异步管理器是否设置了此过滤器对应的SecurityContextCallableProcessingInterceptor，如果没有设置则会进行设置</span></span><br><span class="line">   <span class="type">SecurityContextCallableProcessingInterceptor</span> <span class="variable">securityProcessingInterceptor</span> <span class="operator">=</span> (SecurityContextCallableProcessingInterceptor) asyncManager</span><br><span class="line">         .getCallableInterceptor(CALLABLE_INTERCEPTOR_KEY);</span><br><span class="line">   <span class="comment">//3.如果为空，将新的 SecurityContextCallableProcessingInterceptor注册进去</span></span><br><span class="line">   <span class="keyword">if</span> (securityProcessingInterceptor == <span class="literal">null</span>) &#123;</span><br><span class="line">      asyncManager.registerCallableInterceptor(CALLABLE_INTERCEPTOR_KEY,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SecurityContextCallableProcessingInterceptor</span>());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//4.执行下一个过滤器 </span></span><br><span class="line">   filterChain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-SecurityContextPersistenceFilter"><a href="#3-SecurityContextPersistenceFilter" class="headerlink" title="3.SecurityContextPersistenceFilter"></a>3.SecurityContextPersistenceFilter</h2><p>主要<strong>控制 SecurityContext 的在一次请求中的生命周期</strong> 。请求来临时，创建SecurityContext 安全上下文信息，请求结束时清空 SecurityContextHolder 。</p><blockquote><p>请求 / 线程 &lt; 会话 &lt; 应用</p></blockquote><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="comment">//1.如果过滤器执行过一次则跳过此过滤器</span></span><br><span class="line">   <span class="keyword">if</span> (request.getAttribute(FILTER_APPLIED) != <span class="literal">null</span>) &#123;</span><br><span class="line">      chain.doFilter(request, response);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.设置请求属性 &quot;__spring_security_scpf_applied&quot; 为 true </span></span><br><span class="line">   request.setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">   。。。创建session</span><br><span class="line">   <span class="type">HttpRequestResponseHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpRequestResponseHolder</span>(request, response);</span><br><span class="line">   <span class="comment">//3.从 SecurityContextRepository 加载 SecurityContext，默认为HttpSessionSecurityContextRepository</span></span><br><span class="line">   <span class="comment">//如果SecurityContextRepository没有则创建一个新的。（从会话中获取SecurityContext供当前线程使用）</span></span><br><span class="line">   <span class="type">SecurityContext</span> <span class="variable">contextBeforeChainExecution</span> <span class="operator">=</span> <span class="built_in">this</span>.repo.loadContext(holder);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//4.设置 SecurityContext 到 SecurityContextHolder（设置ThreadLocal）</span></span><br><span class="line">      SecurityContextHolder.setContext(contextBeforeChainExecution);</span><br><span class="line">      。。。日志</span><br><span class="line">      <span class="comment">//5.继续执行下一个过滤器</span></span><br><span class="line">      chain.doFilter(holder.getRequest(), holder.getResponse());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//6.将SecurityContext保存到repo，并清空当前SecurityContextHolder（清理ThreadLocal）</span></span><br><span class="line">      <span class="type">SecurityContext</span> <span class="variable">contextAfterChainExecution</span> <span class="operator">=</span> SecurityContextHolder.getContext();</span><br><span class="line">      SecurityContextHolder.clearContext();</span><br><span class="line">      <span class="built_in">this</span>.repo.saveContext(contextAfterChainExecution, holder.getRequest(), holder.getResponse());</span><br><span class="line">      <span class="comment">//7.移除请求属性</span></span><br><span class="line">      request.removeAttribute(FILTER_APPLIED);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结以上出现的部件概念，如下：</p><ul><li><strong>SecurityContextRepository</strong>：负责<strong>保证在一个用户级会话的过程中，维护住相关的安全上下文信息</strong>。这个问题主要发生在web应用中，由于http的无状态性，所以每次request都需要重复加载安全上下文信息。默认情况下，将基于HTTP Session来完成这方面的工作。</li><li><strong>SecurityContext</strong>：安全上下文信息。</li><li><strong>SecurityContextHolder</strong>：<strong>维护一个线程的SecurityContext</strong>，用户请求处理过程中的各种程序调用能够使用到SecurityContext。默认使用线程变量机制，对于Web应用比较合适。如果是swing程序等，可以换用文件机制。</li></ul><blockquote><p>实现每次请求/每个线程设置 SecurityContextHolder 的 SecurityContext，并在结束后清理SecurityContextHolder 。</p></blockquote><h2 id="4-HeaderWriterFilter"><a href="#4-HeaderWriterFilter" class="headerlink" title="4.HeaderWriterFilter"></a>4.HeaderWriterFilter</h2><p>用于添加响应头，比如 X-Frame-Options（防止点击劫持） , X-XSSProtection（防止xss注入脚本攻击）， X-Content-Type-Options（防止基于 MIME 类型混淆的攻击）。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><br><span class="line">      <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">   <span class="comment">//1.查看过滤器属性为true(默认为false)，则在之前添加响应头 </span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.shouldWriteHeadersEagerly) &#123;</span><br><span class="line">      doHeadersBefore(request, response, filterChain);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//2.过滤器属性为false，则在之后添加响应头（这里使用了装饰者模式增强功能）</span></span><br><span class="line">      doHeadersAfter(request, response, filterChain);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doHeadersAfter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">//1.装饰 Response、Request</span></span><br><span class="line">    <span class="type">HeaderWriterResponse</span> <span class="variable">headerWriterResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeaderWriterResponse</span>(request, response);</span><br><span class="line">    <span class="type">HeaderWriterRequest</span> <span class="variable">headerWriterRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeaderWriterRequest</span>(request, headerWriterResponse);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//2.执行下一个过滤器</span></span><br><span class="line">        filterChain.doFilter(headerWriterRequest, headerWriterResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3.调用装饰后的响应对象方法写响应头</span></span><br><span class="line">        headerWriterResponse.writeHeaders();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真正的写响应头方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">writeHeaders</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">//调用过滤器属性 headerWriters来写响应头（过滤器属性在HeadersConfigurer中注入）</span></span><br><span class="line">    <span class="keyword">for</span> (HeaderWriter writer : <span class="built_in">this</span>.headerWriters) &#123;</span><br><span class="line">        writer.writeHeaders(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有如下 headerWriters 对象</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HeaderWriter&gt; <span class="title function_">getHeaderWriters</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;HeaderWriter&gt; writers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.contentTypeOptions.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.xssProtection.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.cacheControl.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.hsts.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.frameOptions.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.hpkp.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.contentSecurityPolicy.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.referrerPolicy.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.featurePolicy.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.permissionsPolicy.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.crossOriginOpenerPolicy.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.crossOriginEmbedderPolicy.writer);</span><br><span class="line">    addIfNotNull(writers, <span class="built_in">this</span>.crossOriginResourcePolicy.writer);</span><br><span class="line">    writers.addAll(<span class="built_in">this</span>.headerWriters);</span><br><span class="line">    <span class="keyword">return</span> writers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-CorsFilter"><a href="#5-CorsFilter" class="headerlink" title="5.CorsFilter"></a>5.CorsFilter</h2><p>跨域相关的过滤器。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">      FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">   <span class="comment">//1.从configSource属性获取 CorsConfiguration对象 </span></span><br><span class="line">   <span class="type">CorsConfiguration</span> <span class="variable">corsConfiguration</span> <span class="operator">=</span> <span class="built_in">this</span>.configSource.getCorsConfiguration(request);</span><br><span class="line">   <span class="comment">//2.使用 processor属性处理跨域</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">isValid</span> <span class="operator">=</span> <span class="built_in">this</span>.processor.processRequest(corsConfiguration, request, response);</span><br><span class="line">   <span class="comment">//3.一些跨域请求如option请求处理直接返回</span></span><br><span class="line">   <span class="keyword">if</span> (!isValid || CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//4.继续下一个过滤器 </span></span><br><span class="line">   filterChain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-LogoutFilter"><a href="#6-LogoutFilter" class="headerlink" title="6.LogoutFilter"></a>6.LogoutFilter</h2><p>注销过滤器，<strong>专门用于处理注销请求</strong>，默认处理的请求路径为/logout，否则则跳过此过滤器。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="comment">//1.根据请求和过滤器属性来决定是否进行注销过滤，如果是则执行过滤 </span></span><br><span class="line">   <span class="keyword">if</span> (requiresLogout(request, response)) &#123;</span><br><span class="line">      <span class="comment">//2.获取认证对象 </span></span><br><span class="line">      <span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">      <span class="comment">//3.处理注销 </span></span><br><span class="line">      <span class="built_in">this</span>.handler.logout(request, response, auth);</span><br><span class="line">      <span class="comment">//4.注销成功后处理 </span></span><br><span class="line">      <span class="built_in">this</span>.logoutSuccessHandler.onLogoutSuccess(request, response, auth);</span><br><span class="line">      <span class="comment">//5.返回 </span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.无需过滤的请求，执行下一个过滤器</span></span><br><span class="line">   chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">requiresLogout</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">//根据请求路径来匹配，若匹配则返回true</span></span><br><span class="line">    <span class="comment">// 先委托给AntPathRequestMatcher.matches(request)(处理类型匹配)，再委托给 SpringAntMatcher.matches(url)， //最后委托给AntPathMatcher.match(String pattern, String path)（处理路径匹配）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.logoutRequestMatcher.matches(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    。。。日志</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-ConcurrentSessionFilter"><a href="#7-ConcurrentSessionFilter" class="headerlink" title="7.ConcurrentSessionFilter"></a>7.ConcurrentSessionFilter</h2><p>用于同步SessionRegistry中注册的SessionInformation状态。1.从SessionRegistry获取 SessionInformation并检查是否过期2.每次请求就更新sessioninformation的时间。SessionRegistry默认使用内存对象 <code>SessionRegistryImpl</code> ，它是一个监听器监听session相关的事件然后注册到其内部。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="comment">//1.获取session对象</span></span><br><span class="line">   <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(<span class="literal">false</span>);</span><br><span class="line">   <span class="comment">//2.如果没有session就跳过此过滤器 （如禁用了session）</span></span><br><span class="line">   <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//3.从内存sessionRegistry中获取 SessionInformation</span></span><br><span class="line">      <span class="type">SessionInformation</span> <span class="variable">info</span> <span class="operator">=</span> <span class="built_in">this</span>.sessionRegistry.getSessionInformation(session.getId());</span><br><span class="line">      <span class="comment">//4.如果非空进行更新 </span></span><br><span class="line">      <span class="keyword">if</span> (info != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">//5.如果过期，执行登出</span></span><br><span class="line">         <span class="keyword">if</span> (info.isExpired()) &#123;</span><br><span class="line">            。。。日志</span><br><span class="line">            doLogout(request, response);</span><br><span class="line">            。。。发布登出事件</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//6.更新 SessionInformation时间</span></span><br><span class="line">         <span class="built_in">this</span>.sessionRegistry.refreshLastRequest(info.getSessionId());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//7.执行下一个过滤器</span></span><br><span class="line">   chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-UsernamePasswordAuthenticationFilter"><a href="#8-UsernamePasswordAuthenticationFilter" class="headerlink" title="8.UsernamePasswordAuthenticationFilter"></a>8.UsernamePasswordAuthenticationFilter</h2><p>处理<strong>用户以及密码认证</strong>的核心过滤器。认证请求提交的username 和 password 被封装成 <code>UsernamePasswordAuthenticationToken</code> 进行一系列的认证。 <code>UsernamePasswordAuthenticationToken</code> 实际上就是 <code>Authentication</code> 类型。</p><p>过滤器<strong>默认只会处理 <code>/login POST</code> 请求</strong>，可以配置请求路径。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   doFilter((HttpServletRequest) request, (HttpServletResponse) response, chain);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"><span class="comment">//1.不需要认证直接跳过过滤器（按请求路径和类型匹配）</span></span><br><span class="line">    <span class="keyword">if</span> (!requiresAuthentication(request, response)) &#123;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//2.进行认证</span></span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authenticationResult</span> <span class="operator">=</span> attemptAuthentication(request, response);</span><br><span class="line">        <span class="keyword">if</span> (authenticationResult == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        。。。</span><br><span class="line">        <span class="comment">//3.是否支持成功后继续执行过滤链，如果支持认证成功，继续下一个过滤</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.continueChainBeforeSuccessfulAuthentication) &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.认证成功后处理</span></span><br><span class="line">        successfulAuthentication(request, response, chain, authenticationResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;</span><br><span class="line">        <span class="comment">//5.异常后处理</span></span><br><span class="line">        unsuccessfulAuthentication(request, response, failed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AuthenticationException ex) &#123;</span><br><span class="line">        <span class="comment">//5.认证失败后处理</span></span><br><span class="line">        unsuccessfulAuthentication(request, response, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-doFilter方法"><a href="#4-1-doFilter方法" class="headerlink" title="4.1.doFilter方法"></a>4.1.doFilter方法</h3><p>AbstractAuthenticationProcessingFilter类有过滤器方法doFilter来过滤处理post方式的/login请求。</p><p>方法来源：由UsernamePasswordAuthenticationFilter组件直接调用，但本类没有此方法，调用继承的父类AbstractAuthenticationProcessingFilter方法。</p><p>方法逻辑：判断是否需要过滤、尝试认证、设置会话、认证成功处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractAuthenticationProcessingFilter类doFilter方法源码解析</span></span><br><span class="line"><span class="comment">//外部过滤器调用的方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">doFilter((HttpServletRequest) request, (HttpServletResponse) response, chain);<span class="comment">//方法重载调用私有doFilter方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内部真正调用重载方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">//1.判断是否需要过滤器处理，不需要跳过此过滤器。判断依据封装在requiresAuthentication，依据方法路径和类型判断。</span></span><br><span class="line">    <span class="keyword">if</span> (!requiresAuthentication(request, response)) &#123;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.尝试认证</span></span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">authenticationResult</span> <span class="operator">=</span> attemptAuthentication(request, response);</span><br><span class="line">    <span class="keyword">if</span> (authenticationResult == <span class="literal">null</span>) &#123;<span class="comment">//认证返回为null中止过滤链返回</span></span><br><span class="line">        <span class="comment">// return immediately as subclass has indicated that it hasn&#x27;t completed</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.认证成功后依据会话策略设置会话。在CompositeSessionAuthenticationStrategy中处理会话</span></span><br><span class="line">    <span class="built_in">this</span>.sessionStrategy.onAuthentication(authenticationResult, request, response);</span><br><span class="line">    <span class="comment">// Authentication success</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.continueChainBeforeSuccessfulAuthentication) &#123;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.认证成功处理</span></span><br><span class="line">    successfulAuthentication(request, response, chain, authenticationResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的比较重要的方法：</p><ul><li>attemptAuthentication</li><li>successfulAuthentication</li></ul><h3 id="4-2-attemptAuthentication方法"><a href="#4-2-attemptAuthentication方法" class="headerlink" title="4.2.attemptAuthentication方法"></a>4.2.attemptAuthentication方法</h3><p>UsernamePasswordAuthenticationFilter类通过attemptAuthentication方法来尝试认证，本质是认证前的一些处理并委托给authenticationManager进行认证。</p><p>方法来源：UsernamePasswordAuthenticationFilter类的doFilter调用。</p><p>方法逻辑：只处理post的认证请求，从请求中解析出用户名和密码，并使用UsernamePasswordAuthenticationToken类封装作为认证令牌，传入认证令牌并委托<strong>authenticationManager</strong>的authenticate方法进行认证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UsernamePasswordAuthenticationFilter类attemptAuthentication方法源码解析</span></span><br><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span><span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    <span class="comment">//1.只处理post请求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.postOnly &amp;&amp; !request.getMethod().equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationServiceException</span>(<span class="string">&quot;Authentication method not supported: &quot;</span> + request.getMethod());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.解析用户名和密码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> obtainUsername(request);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> obtainPassword(request);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//3.把用户名密码封装成UsernamePasswordAuthenticationToken认证令牌</span></span><br><span class="line">    <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(username, password);</span><br><span class="line">    <span class="comment">//4.为令牌设置Details</span></span><br><span class="line">    setDetails(request, authRequest);</span><br><span class="line">    <span class="comment">//5.委托给AuthenticationManager认证处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-ProviderManager类authenticate方法"><a href="#4-3-ProviderManager类authenticate方法" class="headerlink" title="4.3.ProviderManager类authenticate方法"></a>4.3.ProviderManager类authenticate方法</h3><p>ProviderManager类是==AuthenticationManager接口==的默认实现类，通过authenticate方法来实现多种认证方式尝试认证。</p><p>方法来源：来源于ProviderManager类，但UsernamePasswordAuthenticationFilter类attemptAuthentication方法是通过AuthenticationManager接口调用authenticate方法，故是通过<strong>多态</strong>实现了源于ProviderManager类的authenticate方法的调用。</p><p>方法逻辑：遍历所有的AuthenticationProvider进行认证provider.authenticate(authentication)。其中默认包含DaoAuthhenticationProvider组件。ProviderManager中管理了诸多用于认证的AuthenticationProvider组件。<strong>依据认证令牌的类型来使用不同的AuthenticationProvider（认证登录真正的逻辑）</strong>。这样spring security就通过ProviderManager扩展了登录认证的方式，具有良好的扩展性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ProviderManager类的authenticate方法</span></span><br><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    <span class="comment">//1.记录authentication认证令牌类的类型</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Authentication</span>&gt; toTest = authentication.getClass();</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">parentResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//2.依据令牌类型，遍历AuthenticationProvider来进行认证处理</span></span><br><span class="line">    <span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line">        <span class="comment">//3.判断是否能处理该类型令牌</span></span><br><span class="line">        <span class="keyword">if</span> (!provider.supports(toTest)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.委托DaoAuthenticationProvider来处理认证</span></span><br><span class="line">        result = provider.authenticate(authentication);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;<span class="comment">//认证成功复制details给result，并退出遍历循环</span></span><br><span class="line">            copyDetails(authentication, result);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父AuthenticationManager尝试机制</span></span><br><span class="line">     <span class="keyword">if</span> (result == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">         parentResult = <span class="built_in">this</span>.parent.authenticate(authentication);</span><br><span class="line">         result = parentResult;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//5.返回认证主体。去除密码信息</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.eraseCredentialsAfterAuthentication &amp;&amp; (result <span class="keyword">instanceof</span> CredentialsContainer)) &#123;</span><br><span class="line">            ((CredentialsContainer) result).eraseCredentials();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.没有获得认证后的主体，抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> lastException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-AbstractUserDetailsAuthenticationProvider类authenticate方法"><a href="#4-4-AbstractUserDetailsAuthenticationProvider类authenticate方法" class="headerlink" title="4.4.AbstractUserDetailsAuthenticationProvider类authenticate方法"></a>4.4.AbstractUserDetailsAuthenticationProvider类authenticate方法</h3><p>AbstractUserDetailsAuthenticationProvider类authenticate方法功能是登录认证使用数据库来认证用户名和密码。</p><p>方法来源：直接调用者是DaoAuthhenticationProvider组件。其继承了AbstractUserDetailsAuthenticationProvider，由于没有authenticate方法在本类中所以使用继承的父类authenticate方法。</p><p>方法逻辑：先从令牌中提取username，然后提供了用户信息本地缓存机制，然后查询数据库，然后检查查询到的结果（检查用户状态、检查密码、检查密码状态），然后添加缓存，然后按需求返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractUserDetailsAuthenticationProvider类authenticate方法源码解析</span></span><br><span class="line"><span class="comment">//其本质上充当/login的service层，实现了查询数据库用户信息、校验密码、返回</span></span><br><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> determineUsername(authentication);<span class="comment">//1.提取username</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">cacheWasUsed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> <span class="built_in">this</span>.userCache.getUserFromCache(username);<span class="comment">//2.查缓存</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheWasUsed = <span class="literal">false</span>;</span><br><span class="line">        user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);<span class="comment">//3.查数据库</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.preAuthenticationChecks.check(user);<span class="comment">//4.前置认证检查，检查用户状态信息（包括锁定状态、可用状态、过期状态），检查失败会递归调用retrieveUser然后再前置检查。</span></span><br><span class="line">    additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);<span class="comment">//4.密码检查</span></span><br><span class="line">    <span class="built_in">this</span>.postAuthenticationChecks.check(user);<span class="comment">//4.后置认证检查，检查密码过期状态。</span></span><br><span class="line">    <span class="keyword">if</span> (!cacheWasUsed) &#123;</span><br><span class="line"><span class="built_in">this</span>.userCache.putUserInCache(user);<span class="comment">//5.添加缓存用户信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">principalToReturn</span> <span class="operator">=</span> user;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.forcePrincipalAsString) &#123;</span><br><span class="line">        principalToReturn = user.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);<span class="comment">//6.依据用户信息等封装合法的主体信息结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的重要方法：</p><ul><li>retrieveUser</li><li>preAuthenticationChecks.check</li><li>additionalAuthenticationChecks</li><li>postAuthenticationChecks.check</li><li>createSuccessAuthentication</li></ul><h3 id="4-5-retrieveUser方法"><a href="#4-5-retrieveUser方法" class="headerlink" title="4.5.retrieveUser方法"></a>4.5.retrieveUser方法</h3><p>DaoAuthhenticationProvider中提供了查询数据库的方法retrieveUser。</p><p>方法来源：DaoAuthhenticationProvider组件。由AbstractUserDetailsAuthenticationProvider类authenticate方法调用。</p><p>方法逻辑：定时攻击保护、委托给<strong>UserDetailsService组件进行数据库查询</strong>包括用户信息和用户权限、用户名是否存在检查。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DaoAuthhenticationProvider类retrieveUser方法源码解析</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> UserDetails <span class="title function_">retrieveUser</span><span class="params">(String username, UsernamePasswordAuthenticationToken authentication)</span></span><br><span class="line"><span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    prepareTimingAttackProtection();<span class="comment">//1.定时攻击保护</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="type">UserDetails</span> <span class="variable">loadedUser</span> <span class="operator">=</span> <span class="built_in">this</span>.getUserDetailsService().loadUserByUsername(username);<span class="comment">//2.委托给UserDetailsService组件进行数据库查询用户信息，包括用户信息和用户权限</span></span><br><span class="line"><span class="keyword">if</span> (loadedUser == <span class="literal">null</span>) &#123;<span class="comment">//3.用户名是否存在检查</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalAuthenticationServiceException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> loadedUser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-createSuccessAuthentication方法"><a href="#4-6-createSuccessAuthentication方法" class="headerlink" title="4.6.createSuccessAuthentication方法"></a>4.6.createSuccessAuthentication方法</h3><p>DaoAuthhenticationProvider中提供了依据查询结果封装为Authentication认证后主体的方法createSuccessAuthentication。</p><p>方法来源：直接来源DaoAuthhenticationProvider，但同时方法本身调用了父类AbstractUserDetailsAuthenticationProvider的createSuccessAuthentication来最终生成Authentication。由（被）AbstractUserDetailsAuthenticationProvider类authenticate方法调用。</p><p>方法逻辑：1.依据查询到的userDetail创建认证后主体。2.设置认证后主体details。3.返回认证后主体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DaoAuthhenticationProvider类createSuccessAuthentication方法源码解析</span></span><br><span class="line"><span class="keyword">protected</span> Authentication <span class="title function_">createSuccessAuthentication</span><span class="params">(Object principal, Authentication authentication,UserDetails user)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.createSuccessAuthentication(principal, authentication, user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AbstractUserDetailsAuthenticationProvider类createSuccessAuthentication方法源码解析</span></span><br><span class="line"><span class="keyword">protected</span> Authentication <span class="title function_">createSuccessAuthentication</span><span class="params">(Object principal, Authentication authentication,UserDetails user)</span> &#123;</span><br><span class="line"><span class="comment">// Ensure we return the original credentials the user supplied,</span></span><br><span class="line"><span class="comment">// so subsequent attempts are successful even with encoded passwords.</span></span><br><span class="line"><span class="comment">// Also ensure we return the original getDetails(), so that future</span></span><br><span class="line"><span class="comment">// authentication events after cache expiry contain the details</span></span><br><span class="line">    <span class="comment">//1.依据查询到的userDetail创建认证后主体。</span></span><br><span class="line">    <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(principal,</span><br><span class="line">            authentication.getCredentials(), <span class="built_in">this</span>.authoritiesMapper.mapAuthorities(user.getAuthorities()));</span><br><span class="line">    <span class="comment">//2.设置认证后主体details</span></span><br><span class="line">    result.setDetails(authentication.getDetails());</span><br><span class="line">    <span class="built_in">this</span>.logger.debug(<span class="string">&quot;Authenticated user&quot;</span>);</span><br><span class="line">    <span class="comment">//3.返回</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-successfulAuthentication方法"><a href="#4-7-successfulAuthentication方法" class="headerlink" title="4.7.successfulAuthentication方法"></a>4.7.successfulAuthentication方法</h3><p>AbstractAuthenticationProcessingFilter类有方法successfulAuthentication来处理认证成功。</p><p>方法来源：AbstractAuthenticationProcessingFilter类。由AbstractAuthenticationProcessingFilter类的doFilter方法调用。</p><p>方法逻辑：1.初始化设置SecurityContextHolder和SecurityContext。2.通知rememberMeServices服务认证成功。3.发布认证成功消息。4.委托给AuthenticationSuccessHandler来处理认证成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractAuthenticationProcessingFilter类successfulAuthentication方法源码分析。</span></span><br><span class="line"><span class="comment">//默认初始化的认证成功处理器为SavedRequestAwareAuthenticationSuccessHandler</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">AuthenticationSuccessHandler</span> <span class="variable">successHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SavedRequestAwareAuthenticationSuccessHandler</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">successfulAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain,Authentication authResult)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">//1.初始化设置SecurityContextHolder和SecurityContext，将认证后主体保存到SecurityContextHolder中的SecurityContext中。</span></span><br><span class="line"><span class="type">SecurityContext</span> <span class="variable">context</span> <span class="operator">=</span> SecurityContextHolder.createEmptyContext();</span><br><span class="line">    context.setAuthentication(authResult);</span><br><span class="line">    SecurityContextHolder.setContext(context);</span><br><span class="line">   <span class="comment">//。。。</span></span><br><span class="line">    <span class="comment">//2.通知rememberMeServices服务认证成功</span></span><br><span class="line">    <span class="built_in">this</span>.rememberMeServices.loginSuccess(request, response, authResult);</span><br><span class="line">    <span class="comment">//3.发布认证成功消息</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.eventPublisher != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">InteractiveAuthenticationSuccessEvent</span>(authResult, <span class="built_in">this</span>.getClass()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.委托给AuthenticationSuccessHandler来处理认证成功。</span></span><br><span class="line">    <span class="built_in">this</span>.successHandler.onAuthenticationSuccess(request, response, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-8-子类onAuthenticationSuccess方法"><a href="#4-8-子类onAuthenticationSuccess方法" class="headerlink" title="4.8.子类onAuthenticationSuccess方法"></a>4.8.子类onAuthenticationSuccess方法</h3><p>SavedRequestAwareAuthenticationSuccessHandler类有方法onAuthenticationSuccess来处理认证成功。具体处理的是解析<strong>重定向到哪个url</strong>。即：认证后重定向到认证前url问题。</p><p>方法来源：SavedRequestAwareAuthenticationSuccessHandler类。由AbstractAuthenticationProcessingFilter类successfulAuthentication方法调用。</p><p>方法逻辑：1.获取对应认证请求缓存的认证前请求（即要访问的未认证请求）。2.没有缓存，调用父类方法返回配置的重定向url。3.是否配置重定向url在请求参数中或配置使用默认重定向url。调用父类方法返回配置的重定向url。4.获取缓存的重定向地址。5.重定向。总结：若从认证页面进行认证，则直接依据配置的默认重定向地址进行重定向；从未认证页面进行认证，则会重定向到未认证页面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SavedRequestAwareAuthenticationSuccessHandler类onAuthenticationSuccess方法源码解析</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response,Authentication authentication)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//1.获取对应认证请求缓存的认证前请求（即要访问的未认证请求）。</span></span><br><span class="line">    <span class="type">SavedRequest</span> <span class="variable">savedRequest</span> <span class="operator">=</span> <span class="built_in">this</span>.requestCache.getRequest(request, response);</span><br><span class="line">    <span class="comment">//2.没有缓存，调用父类方法返回配置的重定向url。</span></span><br><span class="line">    <span class="keyword">if</span> (savedRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">super</span>.onAuthenticationSuccess(request, response, authentication);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.是否配置重定向url在请求参数中或配置使用默认重定向url。调用父类方法返回配置的重定向url。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">targetUrlParameter</span> <span class="operator">=</span> getTargetUrlParameter();</span><br><span class="line">    <span class="keyword">if</span> (isAlwaysUseDefaultTargetUrl()</span><br><span class="line">            || (targetUrlParameter != <span class="literal">null</span> &amp;&amp; StringUtils.hasText(request.getParameter(targetUrlParameter)))) &#123;</span><br><span class="line">        <span class="built_in">this</span>.requestCache.removeRequest(request, response);</span><br><span class="line">        <span class="built_in">super</span>.onAuthenticationSuccess(request, response, authentication);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    clearAuthenticationAttributes(request);</span><br><span class="line">    <span class="comment">// Use the DefaultSavedRequest URL</span></span><br><span class="line">    <span class="comment">//4.获取缓存的重定向地址。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">targetUrl</span> <span class="operator">=</span> savedRequest.getRedirectUrl();</span><br><span class="line">    <span class="comment">//5.重定向。</span></span><br><span class="line">    getRedirectStrategy().sendRedirect(request, response, targetUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-9-父类onAuthenticationSuccess方法"><a href="#4-9-父类onAuthenticationSuccess方法" class="headerlink" title="4.9.父类onAuthenticationSuccess方法"></a>4.9.父类onAuthenticationSuccess方法</h3><p>父类onAuthenticationSuccess方法源码解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleUrlAuthenticationSuccessHandler类onAuthenticationSuccess方法源码解析</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleUrlAuthenticationSuccessHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstractAuthenticationTargetUrlRequestHandler</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationSuccessHandler</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response,Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//处理认证成功</span></span><br><span class="line">handle(request, response, authentication);</span><br><span class="line">clearAuthenticationAttributes(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractAuthenticationTargetUrlRequestHandler类haanle方法源码解析</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">//1.确定重新url</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">targetUrl</span> <span class="operator">=</span> determineTargetUrl(request, response, authentication);</span><br><span class="line">   <span class="comment">//。。。</span></span><br><span class="line">    <span class="comment">//2.重定向到目标url</span></span><br><span class="line">    <span class="built_in">this</span>.redirectStrategy.sendRedirect(request, response, targetUrl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AbstractAuthenticationTargetUrlRequestHandler类determineTargetUrl方法源码解析</span></span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">determineTargetUrl</span><span class="params">(HttpServletRequest request, HttpServletResponse response,Authentication authentication)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> determineTargetUrl(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">determineTargetUrl</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">//1.检查配置一直使用默认重定向地址，直接返回默认重定向地址</span></span><br><span class="line">    <span class="keyword">if</span> (isAlwaysUseDefaultTargetUrl()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.defaultTargetUrl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check for the parameter and use that if available</span></span><br><span class="line">    <span class="comment">//2.检查配置请求参数中获取重定向地址，则返回请求参数中的重定向地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">targetUrl</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.targetUrlParameter != <span class="literal">null</span>) &#123;</span><br><span class="line">        targetUrl = request.getParameter(<span class="built_in">this</span>.targetUrlParameter);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(targetUrl)) &#123;</span><br><span class="line">            <span class="keyword">return</span> targetUrl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.检查配置请求头Referer获取重定向地址</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.useReferer &amp;&amp; !StringUtils.hasLength(targetUrl)) &#123;</span><br><span class="line">        targetUrl = request.getHeader(<span class="string">&quot;Referer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.没有获取到重定向地址，直接复制默认重定向地址</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(targetUrl)) &#123;</span><br><span class="line">        targetUrl = <span class="built_in">this</span>.defaultTargetUrl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.返回</span></span><br><span class="line">    <span class="keyword">return</span> targetUrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-10-详细的认证流程时序图"><a href="#4-10-详细的认证流程时序图" class="headerlink" title="4.10.详细的认证流程时序图"></a>4.10.详细的认证流程时序图</h3><p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/springsecurity%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90.png" alt="springsecurity认证过程分析"></p><blockquote><p>HttpSecurity.formLogin()注入过滤器，实现了指定路径认证过滤其它路径跳过此过滤器。</p></blockquote><h2 id="9-RequestCacheAwareFilter"><a href="#9-RequestCacheAwareFilter" class="headerlink" title="9.RequestCacheAwareFilter"></a>9.RequestCacheAwareFilter</h2><p>用于<strong>缓存未认证成功的请求</strong>。且<a href="https://juejin.cn/post/7273758446113128502#heading-1">默认只能缓存 GET 类型请求</a>，在异常处理过滤器中执行缓存，在账号密码登录过滤器认证成功时使用缓存重定向到缓存的请求。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="comment">//1.从缓存中获取 与当前请求匹配的保存的 wrappedSavedRequest</span></span><br><span class="line">   <span class="type">HttpServletRequest</span> <span class="variable">wrappedSavedRequest</span> <span class="operator">=</span> <span class="built_in">this</span>.requestCache.getMatchingRequest((HttpServletRequest) request, (HttpServletResponse) response);</span><br><span class="line">   <span class="comment">//2.如果获取不到，则该过滤器无效；如果获取到了则执行缓存的请求 </span></span><br><span class="line">   chain.doFilter((wrappedSavedRequest != <span class="literal">null</span>) ? wrappedSavedRequest : request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-SecurityContextHolderAwareRequestFilter"><a href="#10-SecurityContextHolderAwareRequestFilter" class="headerlink" title="10.SecurityContextHolderAwareRequestFilter"></a>10.SecurityContextHolderAwareRequestFilter</h2><p>包装原始请求和响应对象生成一个新的请求对象。<strong>增强了请求对象的能力</strong>、增加了功能。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="comment">//调用 HttpServlet3RequestFactory对象 包装请求和响应为 Servlet3SecurityContextHolderAwareRequestWrapper</span></span><br><span class="line">   chain.doFilter(<span class="built_in">this</span>.requestFactory.create((HttpServletRequest) req, (HttpServletResponse) res), res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//过滤器属性初始化完成后自动执行的方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="built_in">super</span>.afterPropertiesSet();</span><br><span class="line">    updateFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置过滤器的 requestFactory对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">rolePrefix</span> <span class="operator">=</span> <span class="built_in">this</span>.rolePrefix;</span><br><span class="line">    <span class="built_in">this</span>.requestFactory = createServlet3Factory(rolePrefix);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//底层创建的 HttpServlet3RequestFactory对象</span></span><br><span class="line"><span class="keyword">private</span> HttpServletRequestFactory <span class="title function_">createServlet3Factory</span><span class="params">(String rolePrefix)</span> &#123;</span><br><span class="line">    <span class="type">HttpServlet3RequestFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpServlet3RequestFactory</span>(rolePrefix);</span><br><span class="line">    factory.setTrustResolver(<span class="built_in">this</span>.trustResolver);</span><br><span class="line">    factory.setAuthenticationEntryPoint(<span class="built_in">this</span>.authenticationEntryPoint);</span><br><span class="line">    factory.setAuthenticationManager(<span class="built_in">this</span>.authenticationManager);</span><br><span class="line">    factory.setLogoutHandlers(<span class="built_in">this</span>.logoutHandlers);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-RememberMeAuthenticationFilter"><a href="#11-RememberMeAuthenticationFilter" class="headerlink" title="11.RememberMeAuthenticationFilter"></a>11.RememberMeAuthenticationFilter</h2><p>记住我认证过滤器。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="comment">//1.如果已经认证成功，则跳过此过滤器 </span></span><br><span class="line">   <span class="keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() != <span class="literal">null</span>) &#123;</span><br><span class="line">      。。。日志</span><br><span class="line">      chain.doFilter(request, response);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.调用 rememberMeServices获取 Authentication待认证&quot;token&quot;对象</span></span><br><span class="line">   <span class="type">Authentication</span> <span class="variable">rememberMeAuth</span> <span class="operator">=</span> <span class="built_in">this</span>.rememberMeServices.autoLogin(request, response);</span><br><span class="line">   <span class="comment">//3.非空执行rememberMe认证</span></span><br><span class="line">   <span class="keyword">if</span> (rememberMeAuth != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//认证 </span></span><br><span class="line">         rememberMeAuth = <span class="built_in">this</span>.authenticationManager.authenticate(rememberMeAuth);</span><br><span class="line">         <span class="type">SecurityContext</span> <span class="variable">context</span> <span class="operator">=</span> SecurityContextHolder.createEmptyContext();</span><br><span class="line">         context.setAuthentication(rememberMeAuth);</span><br><span class="line">         SecurityContextHolder.setContext(context);</span><br><span class="line">         <span class="comment">//认证成功处理</span></span><br><span class="line">         onSuccessfulAuthentication(request, response, rememberMeAuth);</span><br><span class="line">         。。。日志</span><br><span class="line">         <span class="built_in">this</span>.securityContextRepository.saveContext(context, request, response);</span><br><span class="line">         。。。发布事件</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">this</span>.successHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//认证成功处理 </span></span><br><span class="line">            <span class="built_in">this</span>.successHandler.onAuthenticationSuccess(request, response, rememberMeAuth);</span><br><span class="line">            <span class="comment">//4.返回 </span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (AuthenticationException ex) &#123;</span><br><span class="line">         。。。日志</span><br><span class="line">         <span class="comment">//认证失败处理    </span></span><br><span class="line">         <span class="built_in">this</span>.rememberMeServices.loginFail(request, response);</span><br><span class="line">         onUnsuccessfulAuthentication(request, response, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//4.执行下一个过滤器 </span></span><br><span class="line">   chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>已认证跳过，rememberMeServices.autoLogin(request, response)返回空跳过，否组执行rememberMe认证。</p></blockquote><h2 id="12-AnonymousAuthenticationFilter"><a href="#12-AnonymousAuthenticationFilter" class="headerlink" title="12.AnonymousAuthenticationFilter"></a>12.AnonymousAuthenticationFilter</h2><p>匿名登录认证过滤器，未认证设置一个匿名认证对象到SecurityContextHolder。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="comment">//1.如果没有经过认证，创建一个匿名的Authentication认证对象设置到SecurityContextHolder。</span></span><br><span class="line">   <span class="keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> createAuthentication((HttpServletRequest) req);</span><br><span class="line">      <span class="type">SecurityContext</span> <span class="variable">context</span> <span class="operator">=</span> SecurityContextHolder.createEmptyContext();</span><br><span class="line">      context.setAuthentication(authentication);</span><br><span class="line">      SecurityContextHolder.setContext(context);</span><br><span class="line">      。。。日志</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      。。。日志</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.继续下一个过滤器</span></span><br><span class="line">   chain.doFilter(req, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-SessionManagementFilter"><a href="#13-SessionManagementFilter" class="headerlink" title="13.SessionManagementFilter"></a>13.SessionManagementFilter</h2><p>Session 管理器过滤器，内部维护了一个SessionAuthenticationStrategy 用于管理 Session。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="comment">//1.如果已被调用过跳过过滤器 </span></span><br><span class="line">   <span class="keyword">if</span> (request.getAttribute(FILTER_APPLIED) != <span class="literal">null</span>) &#123;</span><br><span class="line">      chain.doFilter(request, response);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.设置请求属性已调用 </span></span><br><span class="line">   request.setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">   <span class="comment">//3.如果 securityContextRepository 没有该请求对应的 securityContext，就需要进行处理</span></span><br><span class="line">   <span class="keyword">if</span> (!<span class="built_in">this</span>.securityContextRepository.containsContext(request)) &#123;</span><br><span class="line">      <span class="comment">//4.获取已认证的Authentication对象 </span></span><br><span class="line">      <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">      <span class="comment">//5.如果已认证，会话认证策略对象 进行相关处理（比如同一用户并发的会话/同时登录会话处理、比如会话对象是否存在、比如更  //  改会话sessionid）</span></span><br><span class="line">       <span class="keyword">if</span> (authentication != <span class="literal">null</span> &amp;&amp; !<span class="built_in">this</span>.trustResolver.isAnonymous(authentication)) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//会话处理 </span></span><br><span class="line">            <span class="built_in">this</span>.sessionAuthenticationStrategy.onAuthentication(authentication, request, response);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (SessionAuthenticationException ex) &#123;</span><br><span class="line">            <span class="comment">//会话拒绝了认证对象，处理认证失败</span></span><br><span class="line">            SecurityContextHolder.clearContext();</span><br><span class="line">            <span class="built_in">this</span>.failureHandler.onAuthenticationFailure(request, response, ex);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//存储 SecurityContext 到securityContextRepository</span></span><br><span class="line">         <span class="built_in">this</span>.securityContextRepository.saveContext(SecurityContextHolder.getContext(), request, response);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//5.如果会话失效，则 会话失效策略对象 执行失效逻辑</span></span><br><span class="line">         <span class="keyword">if</span> (request.getRequestedSessionId() != <span class="literal">null</span> &amp;&amp; !request.isRequestedSessionIdValid()) &#123;</span><br><span class="line">            。。。日志</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.invalidSessionStrategy != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="built_in">this</span>.invalidSessionStrategy.onInvalidSessionDetected(request, response);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//4.执行下一个过滤器 </span></span><br><span class="line">   chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对会话相关进行处理。只有当前请求没有存储 securityContext 时才会进行会话处理。<strong>即是否存储好 securityContext 到会话级别标志着会话是否进行了处理</strong>。</p><p>认证会话处理可以包括许多内容：如更改会话id防止攻击、检查会话对象是否存在、同一用户多个会话处理等等。</p></blockquote><h2 id="14-ExceptionTranslationFilter"><a href="#14-ExceptionTranslationFilter" class="headerlink" title="14.ExceptionTranslationFilter"></a>14.ExceptionTranslationFilter</h2><p>主要来<strong>捕获异常进行合理的处理</strong>，传输异常事件。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//1.继续执行下一个过滤器</span></span><br><span class="line">      chain.doFilter(request, response);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">     。。。</span><br><span class="line">      <span class="comment">//2.处理异常</span></span><br><span class="line">     handleSpringSecurityException(request, response, chain, securityException);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleSpringSecurityException</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">        FilterChain chain, RuntimeException exception)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">//1.如果是未认证异常，委托给handleAuthenticationException</span></span><br><span class="line">    <span class="comment">// AuthenticationEntryPoint组件处理</span></span><br><span class="line">    <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> AuthenticationException) &#123;</span><br><span class="line">        handleAuthenticationException(request, response, chain, (AuthenticationException) exception);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.如果是权限异常，委托给handleAccessDeniedException</span></span><br><span class="line">    <span class="comment">// AccessDeniedHandler组件处理</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> AccessDeniedException) &#123;</span><br><span class="line">        handleAccessDeniedException(request, response, chain, (AccessDeniedException) exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>合理的异常响应返回需要我们配置AuthenticationEntryPoint、AccessDeniedHandler组件。</p></blockquote><h2 id="15-FilterSecurityInterceptor（重点）"><a href="#15-FilterSecurityInterceptor（重点）" class="headerlink" title="15.FilterSecurityInterceptor（重点）"></a>15.FilterSecurityInterceptor（重点）</h2><p><strong>过滤web请求并在拒绝请求时抛出异常</strong>。这个<strong>过滤器</strong>决定了访问特定<strong>路径</strong>应该具备的权限，如果要实现动态权限控制就必须研究该类 。<strong>只处理过滤器层面的权限控制，并不处理注解AOP层面的权限控制</strong>。</p><p>其主要过程为：拦截<code>Authentication</code>对”secured object”的访问，依据“<strong>安全元信息属性</strong>”列表来决定<code>Authentication</code>对象是否可以访问”secured object”。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">   invoke(<span class="keyword">new</span> <span class="title class_">FilterInvocation</span>(request, response, chain));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(FilterInvocation filterInvocation)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">//1.不是第一次执行，跳过此过滤器</span></span><br><span class="line">    <span class="keyword">if</span> (isApplied(filterInvocation) &amp;&amp; <span class="built_in">this</span>.observeOncePerRequest) &#123;</span><br><span class="line">        filterInvocation.getChain().doFilter(filterInvocation.getRequest(), filterInvocation.getResponse());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.第一次执行，设置请求属性 __spring_security_filterSecurityInterceptor_filterApplied 为true</span></span><br><span class="line">    <span class="keyword">if</span> (filterInvocation.getRequest() != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.observeOncePerRequest) &#123;</span><br><span class="line">        filterInvocation.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.委托 beforeInvocation 执行“鉴权”过滤逻辑</span></span><br><span class="line">    <span class="type">InterceptorStatusToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="built_in">super</span>.beforeInvocation(filterInvocation);</span><br><span class="line">    <span class="comment">//4.过滤结束，执行下一个过滤器</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        filterInvocation.getChain().doFilter(filterInvocation.getRequest(), filterInvocation.getResponse());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//5.请求调用结束后执行</span></span><br><span class="line">        <span class="built_in">super</span>.finallyInvocation(token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.请求调用完成后执行</span></span><br><span class="line">    <span class="built_in">super</span>.afterInvocation(token, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>AbstractSecurityInterceptor</code>中已经规划了安全控制过程的抽象</strong>，<code>FilterSecurityInterceptor</code>是针对<strong>web request</strong>的基于filter技术实现，<code>MethodSecurityInterceptor</code>和<code>AspectJMethodSecurityInterceptor</code>是针对<strong>method invocation</strong>的基于两种java aop技术实现。</p><p>组件关系类图如下：</p><p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20240224223030340.png" alt="image-20240224223030340"></p><p><strong><code>AbstractSecurityInterceptor</code>中的抽象过程基本如下</strong>：</p><ol><li>寻找关联当前“secure object”的配置属性（“configuration attributes”）</li><li><strong>把<code>authentication</code>\secure object\configuration attributes提交给<code>AccessDecisionManager</code>.decide()</strong></li><li>可以在此机会对Authentication对象进行变更</li><li>如果授权成功，则允许请求\调用继续往下进行</li><li>如果配置了<code>AfterInvocaitonManager</code>，那么就调用该管理器的相关操作</li></ol><p><strong>而 AccessDecisionManager.decide()又委托给多个Voter去vote()，然后AccessDecisionManager综合意见返回。</strong></p><p>AccessDecisionManager有一个抽象实现类AbstractAccessDecisionManager，这个抽象实现面向了一种vote机制，其中维护了一个vote器列表。</p><p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20240224225955647.png" alt="image-20240224225955647"></p><p><code>AbstractAccessDecisionManager</code>的子类专注于一件事情：从它的vote器们的vote结果中决定，是否最终给予授权。不同的子类实现了不同的决策策略：</p><ol><li><code>AffirmativeBased</code>：任何一个vote器给予ACCESS_GRANTED，那么最终结果就给予授权；否则不授权；</li><li><code>ConsensusBased</code>：按少数服从多数策略，给予授权决定；</li><li><code>UnanimousBased</code>：一Piao否决制。</li><li>注意全部弃权票委托给抽象类方法checkAllowIfAllAbstainDecisions()来处理。</li></ol><h3 id="10-1-doFilter方法"><a href="#10-1-doFilter方法" class="headerlink" title="10.1.doFilter方法"></a>10.1.doFilter方法</h3><p>FilterSecurityInterceptor类方法doFilter来实现过滤处理。</p><p>方法来源：FilterSecurityInterceptor类</p><p>方法逻辑：封装一下方法参数为FilterInvocation转发给本类invoke方法处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FilterSecurityInterceptor类doFilter方法源码分析</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">invoke(<span class="keyword">new</span> <span class="title class_">FilterInvocation</span>(request, response, chain));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-2-invoke方法"><a href="#10-2-invoke方法" class="headerlink" title="10.2.invoke方法"></a>10.2.invoke方法</h3><p>FilterSecurityInterceptor类方法invoke来实现过滤处理。</p><p>方法来源：FilterSecurityInterceptor类</p><p>方法逻辑：1.检查是否已经经过安全校验（对于该用户的该请求）2.设置请求属性已安全校验3.过滤器访问控制前处理（即处理其它后续过滤器前<strong>该过滤器的前处理</strong>）4.放行给下一个过滤器处理5.请求调用后处理6.过滤器后处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FilterSecurityInterceptor类invoke方法源码分析</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(FilterInvocation filterInvocation)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"><span class="comment">//1.检查是否已经经过安全校验（对于该用户的该请求）</span></span><br><span class="line">    <span class="keyword">if</span> (isApplied(filterInvocation) &amp;&amp; <span class="built_in">this</span>.observeOncePerRequest) &#123;</span><br><span class="line">        filterInvocation.getChain().doFilter(filterInvocation.getRequest(), filterInvocation.getResponse());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.设置请求属性已安全校验</span></span><br><span class="line">    <span class="keyword">if</span> (filterInvocation.getRequest() != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.observeOncePerRequest) &#123;</span><br><span class="line">        filterInvocation.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.过滤器访问控制前处理</span></span><br><span class="line">    <span class="type">InterceptorStatusToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="built_in">super</span>.beforeInvocation(filterInvocation);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//4.放行给下一个过滤器处理</span></span><br><span class="line">        filterInvocation.getChain().doFilter(filterInvocation.getRequest(), filterInvocation.getResponse());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//5.请求调用后处理，由于位于finally代码块，即使请求调用异常该方法仍然执行。</span></span><br><span class="line">        <span class="built_in">super</span>.finallyInvocation(token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.过滤器后处理</span></span><br><span class="line">    <span class="built_in">super</span>.afterInvocation(token, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的重要方法：</p><ul><li>beforeInvocation</li><li>finallyInvocation</li><li>afterInvocation</li></ul><h3 id="10-3-beforeInvocation方法-鉴权核心"><a href="#10-3-beforeInvocation方法-鉴权核心" class="headerlink" title="10.3.beforeInvocation方法(鉴权核心)"></a>10.3.beforeInvocation方法(鉴权核心)</h3><p>AbstractSecurityInterceptor类beforeInvocation方法来进行安全检查校验权限。</p><p>方法来源：FilterSecurityInterceptor类的父类AbstractSecurityInterceptor。直接由FilterSecurityInterceptor调用super.beforeInvocation来调用父类的方法。</p><p>方法逻辑：1.查询获取配置的匹配该请求的权限规则2.无权限规则，则返回null3.校验是否已经认证，未认证抛出异常4.从SecurityContextHolder获取认证主体5.尝试授权6.返回一个封装SecurityContext、请求的安全规则、请求的InterceptorStatusToken</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractSecurityInterceptor类beforeInvocation方法源码分析</span></span><br><span class="line"><span class="keyword">protected</span> InterceptorStatusToken <span class="title function_">beforeInvocation</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="comment">//1.从DefaultFilterInvocationSecurityMetadataSource中查询获取配置的匹配该请求的权限规则</span></span><br><span class="line">Collection&lt;ConfigAttribute&gt; attributes = <span class="built_in">this</span>.obtainSecurityMetadataSource().getAttributes(object);</span><br><span class="line">    <span class="comment">//2.无权限规则，则返回null</span></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(attributes)) &#123;</span><br><span class="line">        publishEvent(<span class="keyword">new</span> <span class="title class_">PublicInvocationEvent</span>(object));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// no further work post-invocation</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.校验是否已经认证，未认证抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() == <span class="literal">null</span>) &#123;</span><br><span class="line">credentialsNotFound(<span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;AbstractSecurityInterceptor.authenticationNotFound&quot;</span>,<span class="string">&quot;An Authentication object was not found in the SecurityContext&quot;</span>), object, attributes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.从SecurityContextHolder获取认证主体</span></span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">authenticated</span> <span class="operator">=</span> authenticateIfRequired();</span><br><span class="line">    <span class="comment">//5.尝试授权</span></span><br><span class="line">    attemptAuthorization(object, attributes, authenticated);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.publishAuthorizationSuccess) &#123;<span class="comment">//发布授权成功</span></span><br><span class="line">        publishEvent(<span class="keyword">new</span> <span class="title class_">AuthorizedEvent</span>(object, attributes, authenticated));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//默认runAsManager什么都不做返回null,可以自定义runAsManager</span></span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">runAs</span> <span class="operator">=</span> <span class="built_in">this</span>.runAsManager.buildRunAs(authenticated, object, attributes);</span><br><span class="line">    <span class="keyword">if</span> (runAs != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">SecurityContext</span> <span class="variable">origCtx</span> <span class="operator">=</span> SecurityContextHolder.getContext();</span><br><span class="line">        <span class="type">SecurityContext</span> <span class="variable">newCtx</span> <span class="operator">=</span> SecurityContextHolder.createEmptyContext();</span><br><span class="line">        newCtx.setAuthentication(runAs);</span><br><span class="line">        SecurityContextHolder.setContext(newCtx);</span><br><span class="line">        <span class="comment">// need to revert to token.Authenticated post-invocation</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InterceptorStatusToken</span>(origCtx, <span class="literal">true</span>, attributes, object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.返回一个封装SecurityContext、请求的安全规则、请求的InterceptorStatusToken</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InterceptorStatusToken</span>(SecurityContextHolder.getContext(), <span class="literal">false</span>, attributes, object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的重要方法：</p><ul><li>getAttributes</li><li>attemptAuthorization</li></ul><h3 id="10-4-getAttributes方法"><a href="#10-4-getAttributes方法" class="headerlink" title="10.4.getAttributes方法"></a>10.4.getAttributes方法</h3><p>DefaultFilterInvocationSecurityMetadataSource类方法getAttributes来获取配置的该请求映射的安全规则集合。</p><p>方法来源：直接来源于DefaultFilterInvocationSecurityMetadataSource类。但由AbstractSecurityInterceptor类beforeInvocation方法调用，且调用时是基于<strong>SecurityMetadataSource接口</strong>调用具有<strong>多态</strong>的特性。默认使用该DefaultFilterInvocationSecurityMetadataSource类。</p><p>方法逻辑：1.获取请求2.遍历requestMap（代码生成）获取匹配该请求的权限规则3.没有相关权限规则返回null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultFilterInvocationSecurityMetadataSource类getAttributes方法源码解析</span></span><br><span class="line"><span class="keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="title function_">getAttributes</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="comment">//1.获取请求</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ((FilterInvocation) object).getRequest();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//2.遍历requestMap（代码生成）获取匹配该请求的安全规则</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;RequestMatcher, Collection&lt;ConfigAttribute&gt;&gt; entry : <span class="built_in">this</span>.requestMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getKey().matches(request)) &#123;</span><br><span class="line">            <span class="keyword">return</span> entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) &#123;<span class="comment">//日志打印不匹配的信息</span></span><br><span class="line">                <span class="built_in">this</span>.logger.trace(LogMessage.format(<span class="string">&quot;Did not match request to %s - %s (%d/%d)&quot;</span>, entry.getKey(),</span><br><span class="line">                        entry.getValue(), ++count, <span class="built_in">this</span>.requestMap.size()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.没有相关安全规则返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-5attemptAuthorization方法"><a href="#10-5attemptAuthorization方法" class="headerlink" title="10.5attemptAuthorization方法"></a>10.5attemptAuthorization方法</h3><p>AbstractSecurityInterceptor类方法attemptAuthorization来委托accessDecisionManager进行<strong>权限检查</strong>，即比对用户拥有的权限和访问该方法需要符合的安全规则。<strong>无权限就抛异常结束过滤器的处理</strong>。</p><p>方法来源：AbstractSecurityInterceptor类，由AbstractSecurityInterceptor类beforeInvocation方法调用。</p><p>方法逻辑：1.委托accessDecisionManager进行授权决策，无法授权就抛出异常2.异常时打印日志3.异常时发布授权失败消息4.再次抛出原异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractSecurityInterceptor类attemptAuthorization方法源码解析</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">attemptAuthorization</span><span class="params">(Object object, Collection&lt;ConfigAttribute&gt; attributes,</span></span><br><span class="line"><span class="params">        Authentication authenticated)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.委托accessDecisionManager进行授权决策，无法授权就抛出异常</span></span><br><span class="line">        <span class="built_in">this</span>.accessDecisionManager.decide(authenticated, object, attributes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AccessDeniedException ex) &#123;</span><br><span class="line">        <span class="comment">//2.打印Trace日志</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.trace(LogMessage.format(<span class="string">&quot;Failed to authorize %s with attributes %s using %s&quot;</span>, object,</span><br><span class="line">                    attributes, <span class="built_in">this</span>.accessDecisionManager));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.打印Debug日志</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.debug(LogMessage.format(<span class="string">&quot;Failed to authorize %s with attributes %s&quot;</span>, object, attributes));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.发布授权失败消息</span></span><br><span class="line">        publishEvent(<span class="keyword">new</span> <span class="title class_">AuthorizationFailureEvent</span>(object, attributes, authenticated, ex));</span><br><span class="line">        <span class="comment">//4.再次抛出原异常</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-6-decide方法"><a href="#10-6-decide方法" class="headerlink" title="10.6.decide方法"></a>10.6.decide方法</h3><p>AffirmativeBased类方法decide来进行授权决策（几个投票者如何投票代表成功授权），即解析该主体对该请求的访问权限。而AffirmativeBased是一种解析策略。</p><p>方法来源：默认调用AffirmativeBased类的decide。但此方法是源于AbstractSecurityInterceptor的attemptAuthorization方法调用，调用也是基于<strong>AccessDecisionManager接口</strong>调用，即this.accessDecisionManager.decide。</p><p>方法逻辑：1.遍历所有DecisionVoters来让它们投票，一旦有人投赞成票则授权成功（即有一种类型的配置权限合法）2.没有赞成票时，否定票&gt;0，授权失败抛出异常3.所有人弃权，依据配置AllowIfAllAbstainDecisions来决定是否授权成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decide</span><span class="params">(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes)</span><span class="keyword">throws</span> AccessDeniedException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">deny</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1.遍历所有DecisionVoters来让它们投票，一旦有人投赞成票则授权成功</span></span><br><span class="line">    <span class="keyword">for</span> (AccessDecisionVoter voter : getDecisionVoters()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> voter.vote(authentication, object, configAttributes);<span class="comment">//重要调用方法</span></span><br><span class="line">        <span class="keyword">switch</span> (result) &#123;</span><br><span class="line">        <span class="keyword">case</span> AccessDecisionVoter.ACCESS_GRANTED:</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//授权成功</span></span><br><span class="line">        <span class="keyword">case</span> AccessDecisionVoter.ACCESS_DENIED:</span><br><span class="line">            deny++;<span class="comment">//计数否定票</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.没有赞成票时，否定票&gt;0，授权失败抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (deny &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccessDeniedException</span>(</span><br><span class="line">                <span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;AbstractAccessDecisionManager.accessDenied&quot;</span>, <span class="string">&quot;Access is denied&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//3.所有人弃权，依据配置AllowIfAllAbstainDecisions来决定是否授权成功</span></span><br><span class="line">    checkAllowIfAllAbstainDecisions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AffirmativeBased默认包括的所有voters</strong>:</p><ul><li>PreInvocationAuthorizationAdviceVoter</li><li>RoleVoter</li><li>AuthenticatedVoter</li></ul><p>重要调用方法：voter.vote</p><h3 id="10-7-vote方法"><a href="#10-7-vote方法" class="headerlink" title="10.7.vote方法"></a>10.7.vote方法</h3><p>WebExpressionVoter类方法vote会执行真正的权限投票（权限对比检查）。</p><p>注意：在<strong>WebSecurityConfigurerAdapter子类配置的权限规则</strong>会被封装为WebExpressionConfigAttribute由<strong>WebExpressionVoter</strong>来进行处理；<strong>注解配置的权限规则</strong>会被封装成PreInvocationAttribute由<strong>PreInvocationAuthorizationAdviceVoter</strong>来进行处理；带“ROLE_”前缀的会被<strong>RoleVoter</strong>进行处理。</p><p>方法来源：WebExpressionVoter类。由AffirmativeBased类的decide方法调用。基于接口AccessDecisionVoter调用。</p><p>方法逻辑：1.从权限规则集合中提取该投票者能处理的权限规则2.没找到符合的返回弃权（没有使用该方法配置权限）3.构造EL表达式上下文4.使用ExpressionUtils工具类来判断EL表达式的值5.EL表达式为true返回授权成功6.否则返回授权失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WebExpressionVoter类vote方法源代码分析</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">vote</span><span class="params">(Authentication authentication, FilterInvocation filterInvocation,</span></span><br><span class="line"><span class="params">Collection&lt;ConfigAttribute&gt; attributes)</span> &#123;</span><br><span class="line">    <span class="comment">//1.从权限规则集合中提取该投票者能处理的权限规则，即获取http配置项</span></span><br><span class="line">    <span class="type">WebExpressionConfigAttribute</span> <span class="variable">webExpressionConfigAttribute</span> <span class="operator">=</span> findConfigAttribute(attributes);</span><br><span class="line">    <span class="comment">//2.没找到符合的返回弃权</span></span><br><span class="line">    <span class="keyword">if</span> (webExpressionConfigAttribute == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ACCESS_ABSTAIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.构造EL表达式上下文</span></span><br><span class="line">    <span class="type">EvaluationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> webExpressionConfigAttribute.postProcess(</span><br><span class="line">            <span class="built_in">this</span>.expressionHandler.createEvaluationContext(authentication, filterInvocation), filterInvocation);</span><br><span class="line">    <span class="comment">//4.使用ExpressionUtils工具类来判断EL表达式的值（这里是EL表达式的难点）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">granted</span> <span class="operator">=</span> ExpressionUtils.evaluateAsBoolean(webExpressionConfigAttribute.getAuthorizeExpression(), ctx);</span><br><span class="line">    <span class="comment">//5.EL表达式为true返回授权成功</span></span><br><span class="line">    <span class="keyword">if</span> (granted) &#123;</span><br><span class="line">        <span class="keyword">return</span> ACCESS_GRANTED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.否则返回授权失败</span></span><br><span class="line">    <span class="built_in">this</span>.logger.trace(<span class="string">&quot;Voted to deny authorization&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ACCESS_DENIED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> WebExpressionConfigAttribute <span class="title function_">findConfigAttribute</span><span class="params">(Collection&lt;ConfigAttribute&gt; attributes)</span> &#123;</span><br><span class="line">    <span class="comment">//遍历所有权限规则找第一个符合要求的，在一个地方重复配置会被第一个权限规则覆盖</span></span><br><span class="line">    <span class="keyword">for</span> (ConfigAttribute attribute : attributes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (attribute <span class="keyword">instanceof</span> WebExpressionConfigAttribute) &#123;</span><br><span class="line">            <span class="keyword">return</span> (WebExpressionConfigAttribute) attribute;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-8-finallyInvocation方法"><a href="#10-8-finallyInvocation方法" class="headerlink" title="10.8.finallyInvocation方法"></a>10.8.finallyInvocation方法</h3><p>AbstractSecurityInterceptor类方法finallyInvocation来处理是否更新SecurityContext。该方法只要通过了授权就会被调用，即使请求调用抛出了异常。</p><p>方法来源：AbstractSecurityInterceptor类，由FilterSecurityInterceptor调用super.beforeInvocation来调用父类的方法。</p><p>方法逻辑：授权后令牌不为null且isContextHolderRefreshRequired设置为true时更新ecurityContext</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractSecurityInterceptor类finallyInvocation方法源码解析</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finallyInvocation</span><span class="params">(InterceptorStatusToken token)</span> &#123;</span><br><span class="line">    <span class="comment">//授权后令牌不为null且isContextHolderRefreshRequired设置为true时更新ecurityContext</span></span><br><span class="line">    <span class="keyword">if</span> (token != <span class="literal">null</span> &amp;&amp; token.isContextHolderRefreshRequired()) &#123;</span><br><span class="line">        SecurityContextHolder.setContext(token.getSecurityContext());</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.debug(LogMessage.of(</span><br><span class="line">                    () -&gt; <span class="string">&quot;Reverted to original authentication &quot;</span> + token.getSecurityContext().getAuthentication()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-9-afterInvocation方法"><a href="#10-9-afterInvocation方法" class="headerlink" title="10.9.afterInvocation方法"></a>10.9.afterInvocation方法</h3><p>AbstractSecurityInterceptor类方法afterInvocation来进行过滤器后处理。</p><p>方法来源：AbstractSecurityInterceptor类，由FilterSecurityInterceptor调用super.afterInvocation来调用父类的方法。</p><p>方法逻辑：1.若无需权限就直接返回null无处理2.清理SecurityContext3.若afterInvocationManager存在，委托afterInvocationManager进行过滤器后处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractSecurityInterceptor类afterInvocation方法源码解析</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">afterInvocation</span><span class="params">(InterceptorStatusToken token, Object returnedObject)</span> &#123;</span><br><span class="line">    <span class="comment">//1.若无需权限就直接返回null无处理</span></span><br><span class="line">    <span class="keyword">if</span> (token == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// public object</span></span><br><span class="line">        <span class="keyword">return</span> returnedObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.清理SecurityContext</span></span><br><span class="line">    finallyInvocation(token); <span class="comment">// continue to clean in this method for passivity</span></span><br><span class="line">    <span class="comment">//3.若afterInvocationManager存在，委托afterInvocationManager进行过滤器后处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.afterInvocationManager != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Attempt after invocation handling</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            returnedObject = <span class="built_in">this</span>.afterInvocationManager.decide(token.getSecurityContext().getAuthentication(),</span><br><span class="line">                    token.getSecureObject(), token.getAttributes(), returnedObject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AccessDeniedException ex) &#123;</span><br><span class="line">            publishEvent(<span class="keyword">new</span> <span class="title class_">AuthorizationFailureEvent</span>(token.getSecureObject(), token.getAttributes(),</span><br><span class="line">                    token.getSecurityContext().getAuthentication(), ex));</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回null或后处理结果</span></span><br><span class="line">    <span class="keyword">return</span> returnedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-10-详细的授权流程时序图"><a href="#10-10-详细的授权流程时序图" class="headerlink" title="10.10.详细的授权流程时序图"></a>10.10.详细的授权流程时序图</h3><p>![spring security授权过程分析](spring security授权过程分析.png)</p><blockquote><p>FilterSecurityInterceptor过滤器原理为servlet过滤器，实现了请求路径过滤器层面的权限控制，请求路径权限配置来源于Spring Security的配置类。</p></blockquote><h2 id="16-MethodSecurityInterceptor（重点）"><a href="#16-MethodSecurityInterceptor（重点）" class="headerlink" title="16.MethodSecurityInterceptor（重点）"></a>16.MethodSecurityInterceptor（重点）</h2><p><strong>拦截方法调用并在拒绝请求时抛出异常</strong>。这个<strong>拦截器</strong>决定了访问特定<strong>方法</strong>应具备的权限，如果要实现动态权限控制就必须研究该类。</p><p><strong>只处理注解AOP层面的权限控制，不处理过滤器层面的权限控制</strong>。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">   <span class="comment">//1.委托 beforeInvocation 执行“鉴权”过滤逻辑</span></span><br><span class="line">   <span class="type">InterceptorStatusToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="built_in">super</span>.beforeInvocation(mi);</span><br><span class="line">   Object result;</span><br><span class="line">   <span class="comment">//2.执行方法调用</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      result = mi.proceed();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//3.方法调用结束后执行</span></span><br><span class="line">      <span class="built_in">super</span>.finallyInvocation(token);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//4.方法调用完成后执行 </span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">super</span>.afterInvocation(token, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 FilterSecurityInterceptor 继承的同一个父类 <code>AbstractSecurityInterceptor</code> 。其逻辑源码与 FilterSecurityInterceptor 几乎一样，但是其 <code>SecurityMetadataSource</code> 的真实类型与之不同，是 <code>MethodSecurityMetadataSource</code> 类型。类图如下：</p><p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20240224175844626.png" alt="image-20240224175844626"></p><p>即<strong>拦截器的权限数据源</strong>与FilterSecurityInterceptor 过滤器的数据源不同，<strong>拦截器的权限数据源来源于方法上的注解</strong>。总结拦截器数据源有如下<strong>四种</strong>：</p><p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20240224181132139.png" alt="image-20240224181132139"></p><p>而<strong>过滤器数据源</strong>只有<strong>一种</strong>：ExpressionBasedFilterInvocationSecurityMetadataSource</p><p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20240224181443840.png" alt="image-20240224181443840"></p><p>以上拦截器 <code>MethodSecurityInterceptor</code> 与 <code>MethodSecurityMetadataSource</code> 都是由 <code>GlobalMethodSecurityConfiguration</code> 配置类装配到IOC容器的。源码比较多，这里就不分析了还是比较简单。</p><blockquote><p>MethodSecurityInterceptor拦截器原理为AOP，实现了方法层面的权限控制，方法权限配置来源于注解和xml配置文件。</p></blockquote><h1 id="二、注解解析"><a href="#二、注解解析" class="headerlink" title="二、注解解析"></a>二、注解解析</h1><h2 id="1-EnableWebSecurity"><a href="#1-EnableWebSecurity" class="headerlink" title="1.EnableWebSecurity"></a>1.EnableWebSecurity</h2><p>在非<code>Springboot</code>的应用中，该注解<code>@EnableWebSecurity</code>需要开发人员自己引入以启用<code>Web</code>安全。</p><p><strong>在<code>Springboot</code>的应用中,开发人员没有必要再次引用该注解</strong>，<code>Springboot</code>的自动配置机制<code>WebSecurityEnablerConfiguration</code>已经引入了该注解。</p><p><code>@EnableWebSecurity</code>引入了WebSecurityConfiguration、<code>HttpSecurityConfiguration</code>、AuthenticationConfiguration的bean对象和SpringWebMvcImportSelector、OAuth2ImportSelector选择引入的bean对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Import(&#123; WebSecurityConfiguration.class, SpringWebMvcImportSelector.class, OAuth2ImportSelector.class,</span><br><span class="line">      HttpSecurityConfiguration.class &#125;)</span><br><span class="line">@EnableGlobalAuthentication</span><br></pre></td></tr></table></figure><p>其中 <code>HttpSecurityConfiguration</code> 的装配最重要，它帮我们装配了一个默认的 <code>HttpSecurity</code> 组件，这是配置Spring Security的关键组件。其中对 HttpSecurity 组件进行了默认的配置，<strong>配置开启了许多的过滤器组件</strong>，这些<strong>过滤器在 HttpSecurity .build() 时创建</strong>。</p><blockquote><p>springboot应用无需使用这个注解。它帮我们准备好了许多默认的过滤器组件，我们只需要httpSecurity.build()就可以使<strong>Http安全相关过滤器</strong>注入生效。它还帮我们调用了webSecurity.build()装配好了<strong>web安全相关的过滤器</strong>。</p><p>注意：<strong>先执行httpSecurity.build()再执行webSecurity.build()。webSecurity层次更高。</strong></p></blockquote><h1 id="三、组件解析"><a href="#三、组件解析" class="headerlink" title="三、组件解析"></a>三、组件解析</h1><h2 id="1-DelegatingFilterProxy"><a href="#1-DelegatingFilterProxy" class="headerlink" title="1.DelegatingFilterProxy"></a>1.DelegatingFilterProxy</h2><p><strong>用于给Servlet Filter做代理</strong>(代理方)，代理到 spring bean（被代理方），这样可以将spring bean中的过滤器通过 <code>DelegatingFilterProxy</code> 来注册到servlet容器的过滤器中。</p><p><code>DelegatingFilterProxy</code> 是由 <code>DelegatingFilterProxyRegistrationBean</code> 来创建的，并将其注册到 Servlet 容器中。而这个注册bean是由 <code>SecurityFilterAutoConfiguration</code> 自动配置类装配的。</p><p>所以依赖关系如下：<code>DelegatingFilterProxy</code>  –&gt;  <code>DelegatingFilterProxyRegistrationBean</code> –&gt;  <code>SecurityFilterAutoConfiguration</code></p><p><strong>DelegatingFilterProxy</strong>：用于给Servlet Filter做代理。代理的 targetBeanName 名字为 “springSecurityFilterChain”。</p><p><strong>DelegatingFilterProxyRegistrationBean</strong>：用于注册 Servlet filter。</p><p><strong>SecurityFilterAutoConfiguration</strong>：用于装配 DelegatingFilterProxyRegistrationBean 到 IOC容器。</p><h2 id="2-FilterChainProxy"><a href="#2-FilterChainProxy" class="headerlink" title="2. FilterChainProxy"></a>2. FilterChainProxy</h2><p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20240225140054659.png" alt="image-20240225140054659"></p><p>是一个代理类，代理了 <code>List&lt;SecurityFilterChain&gt; filterChains</code> 多个 <code>SecurityFilterChain</code> 。同时这个对象被注入到DelegatingFilterProxy对象。</p><p><strong>FilterChainProxy由 WebSecurity.buid() 创建出来</strong>。并<strong>由 <code>WebSecurityConfiguration</code> 配置类来控制这个构建过程</strong>。这个组件会将程序中所有由 httpSecurity.build() 构建的 SecurityFilterChain 全部重新整合构建为 <code>FilterChainProxy</code>。</p><blockquote><p><strong>The WebSecurity is created by WebSecurityConfiguration to create the FilterChainProxy</strong> known as the Spring Security Filter Chain (<strong>springSecurityFilterChain</strong>). The springSecurityFilterChain is the Filter that the DelegatingFilterProxy delegates to.</p><p>所以 <strong>WebSecurityConfiguration 组件控制了 FilterChainProxy 的创建过程！</strong></p></blockquote><h2 id="3-SecurityFilterChain"><a href="#3-SecurityFilterChain" class="headerlink" title="3.SecurityFilterChain"></a>3.SecurityFilterChain</h2><p>是一个过滤器链，其中又包含多个过滤器对象。并被 <code>FilterChainProxy</code> 所使用。</p><p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20240225155634811.png" alt="image-20240225155634811"></p><p><strong>SecurityFilterChain由 http.build()创建出来</strong>。当然 webSecurity在构建 FilterChainProxy 过程中也会创建SecurityFilterChain。但这里主要是指我们自定义的配置类控制 HttpSecurity 创建 SecurityFilterChain。</p><p>我们可以对 <strong>HttpSecurity 调用 requestMatcher() 方法控制此过滤链匹配的路径</strong>，但<strong>默认是匹配所有路径</strong>。</p><blockquote><p>HttpSecurityConfiguration创建了默认的 HttpSecurity 组件，但并没有通过HttpSecurity创建SecurityFilterChain。</p><p>所以我们自己配置的组件控制了 SecurityFilterChain 的创建过程。</p></blockquote><h2 id="4-WebSecurityConfiguration和WebSecurity"><a href="#4-WebSecurityConfiguration和WebSecurity" class="headerlink" title="4.WebSecurityConfiguration和WebSecurity"></a>4.WebSecurityConfiguration和WebSecurity</h2><p>WebSecurityConfiguration 是 Spring Security的配置类。</p><ol><li><strong>注入了</strong>容器中<strong>所有的 SecurityFilterChain 组件</strong></li><li>使用ObjectPostProcessor组件<strong>创建了 webSecurity 组件</strong></li><li>使用 webSecurity组件和所有的 SecurityFilterChain 组件 <strong>创建了 FilterChainProxy</strong>。</li></ol><p><strong>WebSecurity组件实现了具体构建 FilterChainProxy的逻辑。</strong></p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)</span></span><br><span class="line"><span class="keyword">public</span> Filter <span class="title function_">springSecurityFilterChain</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">hasConfigurers</span> <span class="operator">=</span> <span class="built_in">this</span>.webSecurityConfigurers != <span class="literal">null</span> &amp;&amp; !<span class="built_in">this</span>.webSecurityConfigurers.isEmpty();</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">hasFilterChain</span> <span class="operator">=</span> !<span class="built_in">this</span>.securityFilterChains.isEmpty();</span><br><span class="line">   。。。</span><br><span class="line">   <span class="keyword">if</span> (!hasConfigurers &amp;&amp; !hasFilterChain) &#123;</span><br><span class="line">      <span class="type">WebSecurityConfigurerAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="built_in">this</span>.objectObjectPostProcessor</span><br><span class="line">            .postProcess(<span class="keyword">new</span> <span class="title class_">WebSecurityConfigurerAdapter</span>() &#123;</span><br><span class="line">            &#125;);</span><br><span class="line">      <span class="built_in">this</span>.webSecurity.apply(adapter);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//1.遍历所有的过滤器链 </span></span><br><span class="line">   <span class="keyword">for</span> (SecurityFilterChain securityFilterChain : <span class="built_in">this</span>.securityFilterChains) &#123;</span><br><span class="line">      <span class="comment">//2.将过滤器链添加到 webSecurity，准备重新整合构建</span></span><br><span class="line">      <span class="built_in">this</span>.webSecurity.addSecurityFilterChainBuilder(() -&gt; securityFilterChain);</span><br><span class="line">      <span class="comment">//遍历过滤器，将 FilterSecurityInterceptor 过滤器设置到 webSecurity属性中</span></span><br><span class="line">      <span class="keyword">for</span> (Filter filter : securityFilterChain.getFilters()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (filter <span class="keyword">instanceof</span> FilterSecurityInterceptor) &#123;</span><br><span class="line">            <span class="built_in">this</span>.webSecurity.securityInterceptor((FilterSecurityInterceptor) filter);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (WebSecurityCustomizer customizer : <span class="built_in">this</span>.webSecurityCustomizers) &#123;</span><br><span class="line">      customizer.customize(<span class="built_in">this</span>.webSecurity);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3.整合构建，最终会创建出 FilterChainProxy 对象。</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.webSecurity.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-HttpSecurityConfiguration和HttpSecurity"><a href="#5-HttpSecurityConfiguration和HttpSecurity" class="headerlink" title="5.HttpSecurityConfiguration和HttpSecurity"></a>5.HttpSecurityConfiguration和HttpSecurity</h2><p>HttpSecurityConfiguration是 Spring Security的配置类。主要就<strong>创建了 HttpSecurity 组件</strong>。内部<strong>对HttpSecurity进行了一些默认配置，配置了默认的过滤器链在构建时生效</strong>。</p><p><strong>HttpSecurity组件实现了具体构建 SecurityFilterChain/DefaultSecurityFilterChain 的逻辑。</strong>还具有许多方法可以灵活的配置过滤器和权限规则。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(HTTPSECURITY_BEAN_NAME)</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">HttpSecurity <span class="title function_">httpSecurity</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   。。。</span><br><span class="line">   <span class="comment">//1.创建了 HttpSecurity对象    </span></span><br><span class="line">   <span class="type">HttpSecurity</span> <span class="variable">http</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpSecurity</span>(<span class="built_in">this</span>.objectPostProcessor, authenticationBuilder, createSharedObjects());</span><br><span class="line">   <span class="comment">//2.配置了 HttpSecurity对象</span></span><br><span class="line">   http</span><br><span class="line">      .csrf(withDefaults()) <span class="comment">//csrf过滤器</span></span><br><span class="line">      .addFilter(<span class="keyword">new</span> <span class="title class_">WebAsyncManagerIntegrationFilter</span>()) <span class="comment">//WebAsyncManagerIntegrationFilter过滤器</span></span><br><span class="line">      .exceptionHandling(withDefaults()) <span class="comment">//ExceptionTranslationFilter</span></span><br><span class="line">      .headers(withDefaults()) <span class="comment">//HeaderWriterFilter</span></span><br><span class="line">      .sessionManagement(withDefaults()) <span class="comment">//SessionManagementFilter、ConcurrentSessionFilter</span></span><br><span class="line">      .securityContext(withDefaults()) <span class="comment">//SecurityContextPersistenceFilter</span></span><br><span class="line">      .requestCache(withDefaults()) <span class="comment">//RequestCacheAwareFilter</span></span><br><span class="line">      .anonymous(withDefaults()) <span class="comment">//AnonymousAuthenticationFilter</span></span><br><span class="line">      .servletApi(withDefaults()) <span class="comment">//SecurityContextHolderAwareRequestFilter</span></span><br><span class="line">      .apply(<span class="keyword">new</span> <span class="title class_">DefaultLoginPageConfigurer</span>&lt;&gt;()); </span><br><span class="line">   http.logout(withDefaults()); <span class="comment">//LogoutFilter</span></span><br><span class="line">   applyDefaultConfigurers(http);</span><br><span class="line">   <span class="keyword">return</span> http;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-SecurityAutoConfiguration"><a href="#6-SecurityAutoConfiguration" class="headerlink" title="6.SecurityAutoConfiguration"></a>6.SecurityAutoConfiguration</h2><p><strong>是 Spring Boot 的自动配置类</strong>。为我们引入了组件 <code>SpringBootWebSecurityConfiguration</code> 和 <code>SecurityDataConfiguration</code> ，还引入了 <code>DefaultAuthenticationEventPublisher</code> 认证事件发布组件。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfiguration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DefaultAuthenticationEventPublisher.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(SecurityProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; SpringBootWebSecurityConfiguration.class, SecurityDataConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean(AuthenticationEventPublisher.class)</span></span><br><span class="line">   <span class="keyword">public</span> DefaultAuthenticationEventPublisher <span class="title function_">authenticationEventPublisher</span><span class="params">(ApplicationEventPublisher publisher)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultAuthenticationEventPublisher</span>(publisher);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-SpringBootWebSecurityConfiguration"><a href="#7-SpringBootWebSecurityConfiguration" class="headerlink" title="7.SpringBootWebSecurityConfiguration"></a>7.SpringBootWebSecurityConfiguration</h2><p><strong>是 Spring Boot 的自动配置类</strong>。</p><ol><li>如果我们没有配置 SecurityFilterChain 组件，会为我们<strong>默认配置一个 <code>SecurityFilterChain</code> 组件</strong>，否则就不配置。</li><li><strong>配置一个 ErrorPageSecurityFilter 过滤器</strong>到 servlet filter 中。</li><li><strong>使用注解 @EnableWebSecurity</strong>。</li></ol><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnDefaultWebSecurity</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SecurityFilterChainConfiguration</span> &#123;</span><br><span class="line"><span class="comment">//默认提供的 SecurityFilterChain</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@Order(SecurityProperties.BASIC_AUTH_ORDER)</span></span><br><span class="line">   SecurityFilterChain <span class="title function_">defaultSecurityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      http.authorizeRequests().anyRequest().authenticated();</span><br><span class="line">      http.formLogin();</span><br><span class="line">      http.httpBasic();</span><br><span class="line">      <span class="keyword">return</span> http.build();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-SecurityFilterAutoConfiguration"><a href="#8-SecurityFilterAutoConfiguration" class="headerlink" title="8.SecurityFilterAutoConfiguration"></a>8.SecurityFilterAutoConfiguration</h2><p><strong>是 Spring Boot 的自动配置类</strong>。用于注册过滤链集合到 servlet filter中。</p><p>实际上为我们装配了一个组件 <code>DelegatingFilterProxyRegistrationBean</code> 来用于注册过滤器。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(name = DEFAULT_FILTER_NAME)</span></span><br><span class="line"><span class="keyword">public</span> DelegatingFilterProxyRegistrationBean <span class="title function_">securityFilterChainRegistration</span><span class="params">(</span></span><br><span class="line"><span class="params">      SecurityProperties securityProperties)</span> &#123;</span><br><span class="line">   <span class="type">DelegatingFilterProxyRegistrationBean</span> <span class="variable">registration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegatingFilterProxyRegistrationBean</span>(</span><br><span class="line">         DEFAULT_FILTER_NAME);</span><br><span class="line">   registration.setOrder(securityProperties.getFilter().getOrder());</span><br><span class="line">   registration.setDispatcherTypes(getDispatcherTypes(securityProperties));</span><br><span class="line">   <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、无配置引入"><a href="#四、无配置引入" class="headerlink" title="四、无配置引入"></a>四、无配置引入</h1><h2 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h2><ol><li>引入依赖，版本由spring boot版本管理。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.引入后就可以立即启动。</p><p>此时默认所有路径都需要认证，都会经过<code>UsernamePasswordAuthenticationFilter</code>过滤器，默认有登录页面。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>以上效果是<strong>Spring Boot自动装配</strong>导致的，自动装配的配置类为<code>org.springframework.boot.autoconfigure.security.servlet.SpringBootWebSecurityConfiguration</code>。默认情况下它会创建一个<code>SecurityFilterChain</code>过滤链组件。组件<code>SecurityFilterChain</code>依赖于<code>HttpSecurity</code>组件。</p><p>源码分析如下：</p><p><img src="/2024/02/25/Spring-Security%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/image-20240223160414470.png" alt="image-20240223160414470"></p><p>代码 <code>http.authorizeRequests().anyRequest().authenticated();</code> 配置了<strong>所有请求都需要认证</strong>。</p><p>代码 <code>http.formLogin();</code> 配置了将FormLoginConfigurer加入HttpSecurity，请求经过 <code>UsernamePasswordAuthenticationFilter</code> 过滤器来进行认证，同时由于未配置登录页路径会**使用默认登录页”/login”**。</p><p>代码 <code>http.httpBasic();</code> 配置了将HttpBasicConfigurer加入HttpSecurity，请求经过 <code>BasicAuthenticationFilter</code> 过滤器来进行<strong>HTTP Basic认证</strong>。</p><p>代码 <code>http.build();</code> 根据以上代码来<strong>装配spring security的过滤链并返回SecurityFilterChain组件</strong>。</p><p>默认情况下，Spring Boot <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/servlet/UserDetailsServiceAutoConfiguration.java">UserDetailsServiceAutoConfiguration</a> 自动化配置类，会创建一个<strong>内存级别</strong>的 <a href="https://github.com/spring-projects/spring-security/blob/master/core/src/main/java/org/springframework/security/provisioning/InMemoryUserDetailsManager.java">InMemoryUserDetailsManager</a> Bean 对象，提供认证的用户信息。</p><blockquote><p> 以上我们分析了默认的SecurityFilterChain组件，这是Spring Boot默认为我们装配的。实际上我们需要自己配置一个SecurityFilterChain 组件或者 WebSecurityConfigurerAdapter 组件来覆盖此默认装配的组件。</p></blockquote><hr><h1 id="五、配置引入"><a href="#五、配置引入" class="headerlink" title="五、配置引入"></a>五、配置引入</h1><h2 id="代码实践-1"><a href="#代码实践-1" class="headerlink" title="代码实践"></a>代码实践</h2><ol><li>引入依赖，版本由spring boot版本管理。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.配置组件。</p><p><strong>配置Spring Security需要的组件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityComponentConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义的认证失败处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationEntryPoint <span class="title function_">authenticationEntryPoint</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AuthenticationEntryPointImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义的权限不够处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AccessDeniedHandler <span class="title function_">accessDeniedHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AccessDeniedHandlerImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义的认证过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TokenAuthenticationFilter <span class="title function_">tokenAuthenticationFilter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TokenAuthenticationFilter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在自定我们自己的Spring Security过滤器时，最好<strong>不要将过滤器注入IOC容器中</strong>，如果注入后spring boot会再次将此过滤器注册到servelet容器中，导致过滤器执行两次，如果我们一定要注入到IOC容器中我们可以控制spring boot不要注册此过滤器到servlet容器，代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> FilterRegistrationBean&lt;TenantFilter&gt; <span class="title function_">tenantFilterRegistration</span><span class="params">(TenantFilter filter)</span> &#123;</span><br><span class="line">    FilterRegistrationBean&lt;TenantFilter&gt; registration = <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>&lt;&gt;(filter);</span><br><span class="line">    <span class="comment">//不要注册此过滤器到servlet容器！！！</span></span><br><span class="line">    registration.setEnabled(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置Spring Security自身过滤器组件、添加过滤器组件、自身url的访问控制</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AccessDeniedHandler accessDeniedHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationEntryPoint authenticationEntryPoint;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TokenAuthenticationFilter tokenAuthenticationFilter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity httpSecurity)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.配置过滤器</span></span><br><span class="line">        httpSecurity</span><br><span class="line">                <span class="comment">// 开启跨域</span></span><br><span class="line">                .cors().and()</span><br><span class="line">                <span class="comment">// CSRF 禁用，因为不使用 Session</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">// 配置会话。基于 token 机制，所以不需要 Session，且一个用户只能有一个会话</span></span><br><span class="line">                .sessionManagement().maximumSessions(<span class="number">1</span>).expiredUrl(<span class="string">&quot;/auth/logion&quot;</span>).and()</span><br><span class="line">                                    .sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()</span><br><span class="line">                <span class="comment">// 配置响应头header。</span></span><br><span class="line">                .headers().frameOptions().disable().and()</span><br><span class="line">                <span class="comment">// 配置异常过滤器</span></span><br><span class="line">                .exceptionHandling().authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">                                    .accessDeniedHandler(accessDeniedHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.添加过滤器</span></span><br><span class="line">        httpSecurity.addFilterBefore(tokenAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得 @PermitAll 带来的 URL 列表，免登录</span></span><br><span class="line">        Multimap&lt;HttpMethod, String&gt; permitAllUrls = getPermitAllUrlsFromAnnotations();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.配置基于url的访问控制</span></span><br><span class="line">        httpSecurity</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 静态资源，可匿名访问</span></span><br><span class="line">                .antMatchers(HttpMethod.GET, <span class="string">&quot;/*.html&quot;</span>, <span class="string">&quot;/**/*.html&quot;</span>, <span class="string">&quot;/**/*.css&quot;</span>, <span class="string">&quot;/**/*.js&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">// 设置 @PermitAll 无需认证</span></span><br><span class="line">                .antMatchers(HttpMethod.GET, permitAllUrls.get(HttpMethod.GET).toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>])).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.POST, permitAllUrls.get(HttpMethod.POST).toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>])).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.PUT, permitAllUrls.get(HttpMethod.PUT).toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>])).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.DELETE, permitAllUrls.get(HttpMethod.DELETE).toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>])).permitAll()</span><br><span class="line">                <span class="comment">// 设置aj验证码的cotroller请求无需认证</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/captcha/get&quot;</span>, <span class="string">&quot;/captcha/check&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">// 兜底规则，必须认证</span></span><br><span class="line">                .and().authorizeRequests()</span><br><span class="line">                        .anyRequest().authenticated();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> httpSecurity.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过<span class="doctag">@PermitAlll</span>注解获取被注解的url集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Multimap&lt;HttpMethod, String&gt; <span class="title function_">getPermitAllUrlsFromAnnotations</span><span class="params">()</span> &#123;</span><br><span class="line">        Multimap&lt;HttpMethod, String&gt; result = HashMultimap.create();</span><br><span class="line">        <span class="comment">// 获得接口对应的 HandlerMethod 集合</span></span><br><span class="line">        <span class="type">RequestMappingHandlerMapping</span> <span class="variable">requestMappingHandlerMapping</span> <span class="operator">=</span> (RequestMappingHandlerMapping)</span><br><span class="line">                applicationContext.getBean(<span class="string">&quot;requestMappingHandlerMapping&quot;</span>);</span><br><span class="line">        Map&lt;RequestMappingInfo, HandlerMethod&gt; handlerMethodMap = requestMappingHandlerMapping.getHandlerMethods();</span><br><span class="line">        <span class="comment">// 获得有 @PermitAll 注解的接口</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;RequestMappingInfo, HandlerMethod&gt; entry : handlerMethodMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (!handlerMethod.hasMethodAnnotation(PermitAll.class)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (entry.getKey().getPatternsCondition() == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;String&gt; urls = entry.getKey().getPatternsCondition().getPatterns();</span><br><span class="line">            <span class="comment">// 特殊：使用 @RequestMapping 注解，并且未写 method 属性，此时认为都需要免登录</span></span><br><span class="line">            Set&lt;RequestMethod&gt; methods = entry.getKey().getMethodsCondition().getMethods();</span><br><span class="line">            <span class="keyword">if</span> (CollUtil.isEmpty(methods)) &#123;</span><br><span class="line">                result.putAll(HttpMethod.GET, urls);</span><br><span class="line">                result.putAll(HttpMethod.POST, urls);</span><br><span class="line">                result.putAll(HttpMethod.PUT, urls);</span><br><span class="line">                result.putAll(HttpMethod.DELETE, urls);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据请求方法，添加到 result 结果</span></span><br><span class="line">            entry.getKey().getMethodsCondition().getMethods().forEach(requestMethod -&gt; &#123;</span><br><span class="line">                <span class="keyword">switch</span> (requestMethod) &#123;</span><br><span class="line">                    <span class="keyword">case</span> GET:</span><br><span class="line">                        result.putAll(HttpMethod.GET, urls);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> POST:</span><br><span class="line">                        result.putAll(HttpMethod.POST, urls);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> PUT:</span><br><span class="line">                        result.putAll(HttpMethod.PUT, urls);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> DELETE:</span><br><span class="line">                        result.putAll(HttpMethod.DELETE, urls);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、还未完成，持续更新"><a href="#六、还未完成，持续更新" class="headerlink" title="六、还未完成，持续更新"></a>六、还未完成，持续更新</h1>]]></content>
      
      
      <categories>
          
          <category> Spring Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于部署上线那些事</title>
      <link href="/2024/02/14/%E5%85%B3%E4%BA%8E%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
      <url>/2024/02/14/%E5%85%B3%E4%BA%8E%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="1准备服务器"><a href="#1准备服务器" class="headerlink" title="1准备服务器"></a>1准备服务器</h3><p>购买服务器</p><p>为服务器初始化软件：宝塔面板（方便管理服务器）、Mysql、java环境、docker等。</p><h3 id="2前端"><a href="#2前端" class="headerlink" title="2前端"></a>2前端</h3><p><code>上线前准备</code>：前端上线对接后端地址。修改前端请求的后端地址。（编译阶段就区分好了环境）</p><p>&emsp;&emsp;开发环境：前端请求的是 localhost:XXXX 或者说是测试用的接口地址</p><p>&emsp;&emsp;上线环境：前端请求的是 xxxx.com/api 之类的正式地址</p><p><code>上线步骤</code>：</p><ol><li>本地打包构建。</li><li>给服务器安装Nginx。用Nginx等web服务器来提供访问前端服务能力</li><li>把dist网页目录放到<strong>服务器</strong>上。</li></ol><blockquote><p>纯css、js、html项目无需打包构建，使用了框架的项目需要打包构建为css、js、html项目。使用了框架建议参考官方文档部署项目。</p></blockquote><p><code>快速上线</code>：可以依赖宝塔面板快速部署上线</p><p>1.菜单栏添加站点（前提是安装了nginx才会有此页面）。</p><p><img src="/img/API%E6%8E%A5%E5%8F%A3%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0.assets/image-20240212142046166.png" alt="image-20240212142046166"></p><p>2.初始化站点信息。</p><p><img src="/img/API%E6%8E%A5%E5%8F%A3%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0.assets/image-20240212142315114.png" alt="image-20240212142315114"></p><p>3.将前端编译好的文件放到指定文件夹下。</p><p>4.默认该ip:80可以访问前端服务了。</p><h3 id="3后端"><a href="#3后端" class="headerlink" title="3后端"></a>3后端</h3><p><strong>关键：网络必须要连通</strong><br>如果自己学习用：单个服务器部署这三个项目就足够<br>如果你是搞大事，多个服务器建议在同一内网，内网交互会更快、且更安全</p><p><code>上线准备</code>：后端上线对接中间件、数据库地址（运行阶段区分环境）</p><p>&emsp;&emsp;开发环境：后端请求的数据库地址是 localhost:3306 ，请求的注册中心、redis等中间组件地址都是 localhost</p><p>&emsp;&emsp;上线环境：后端请求的地址是 xxxx.com:3306 之类的正式地址</p><p><code>上线步骤</code>：</p><ol><li>本地编译构建。</li><li>把jar包放到服务器上。</li><li>手动运行jar包。</li></ol><p><code>快速上线</code>：可以依赖宝塔面板快速部署上线</p><ol><li>上传java的jar包到服务器。</li><li>在网站菜单栏添加java项目。</li></ol><p><img src="/img/API%E6%8E%A5%E5%8F%A3%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0.assets/image-20240212145655615.png" alt="image-20240212145655615"></p><h3 id="4Docker部署"><a href="#4Docker部署" class="headerlink" title="4Docker部署"></a>4Docker部署</h3><p>Dockerfile用于指定构建 Docker 镜像的方法。</p><p>Docker构建优化：减少尺寸、减少构建时间（比如多阶段构建）</p><p><code>前端部署步骤</code>：</p><ol><li>本地打包dist包</li><li>本地编写Dockerfile文件（参考本项目）</li><li>将前端代码文件上传到云服务器。或者dist文件夹、docker文件夹、Dockerfile文件上传。</li><li>运行 docker build -t [标签名:标签版本]构建镜像</li></ol><p><code>后端部署步骤</code>：</p><ol><li>本地打包jar包</li><li>本地编写Dockerfile文件</li><li>将jar包和Dockerfile文件上传到云服务器</li><li>运行 docker build -t [标签名:标签版本]构建镜像</li></ol><blockquote><p><code>容器化后存在的问题</code>：各个容器的id地址不同且重启容器后ip会变化。<strong>代码中的localhost微服务之间的请求就失效了！！！</strong></p></blockquote><h3 id="5Docker平台部署"><a href="#5Docker平台部署" class="headerlink" title="5Docker平台部署"></a>5Docker平台部署</h3><ol><li>云服务商的容器平台（腾讯云、阿里云）</li><li>面向某个领域的容器平台（前端 webify、后端微信云托管）</li></ol><h3 id="6域名解析"><a href="#6域名解析" class="headerlink" title="6域名解析"></a>6域名解析</h3><ol><li>购买域名</li><li>解析域名</li><li>备案域名</li><li>配置nginx路由</li></ol><h3 id="7跨域问题解决"><a href="#7跨域问题解决" class="headerlink" title="7跨域问题解决"></a>7跨域问题解决</h3><p><strong>浏览器</strong>为了用户的安全，仅允许向<strong>同域名、同端口</strong>的服务器发送请求。</p><p>如何解决跨域：</p><ol><li>把前后端 域名、端口改成相同的</li><li>让服务器告诉浏览器允许跨域（返回cross-origin-allow响应头）</li><li>Nginx网关配置允许跨域。修改nginx.conf配置文件加响应头</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /api/ &#123;</span><br><span class="line">    proxy_pass http:<span class="comment">//127.0.0.1:8080/api/;</span></span><br><span class="line">    add_header <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> $http_origin;</span><br><span class="line">    add_header <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="string">&#x27;true&#x27;</span>;</span><br><span class="line">    add_header Access-Control-Allow-Methods <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">    add_header Access-Control-Allow-Headers <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> ($request_method = <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">        add_header <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="string">&#x27;true&#x27;</span>;</span><br><span class="line">        add_header <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> $http_origin;</span><br><span class="line">        add_header <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">        add_header <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#x27;</span>;</span><br><span class="line">        add_header <span class="string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="number">1728000</span>;</span><br><span class="line">        add_header <span class="string">&#x27;Content-Type&#x27;</span> <span class="string">&#x27;text/plain; charset=utf-8&#x27;</span>;</span><br><span class="line">        add_header <span class="string">&#x27;Content-Length&#x27;</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">204</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>修改后端服务允许跨域<ol><li>配置 @CrossOrigin 注解</li><li><strong>添加 web 请求拦截器</strong></li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局跨域配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wzy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 覆盖所有请求</span></span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                <span class="comment">// 允许发送 Cookie</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">                <span class="comment">// 放行哪些域名（必须用 patterns，否则 * 会和 allowCredentials 冲突）</span></span><br><span class="line">                .allowedOriginPatterns(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .exposedHeaders(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>定义新的 CrossFilter Bean，参考：<a href="https://www.jianshu.com/p/b02099a435bd">https://www.jianshu.com/p/b02099a435bd</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 上线 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 部署 </tag>
            
            <tag> 上线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常及其解决方案汇总（持续更新~）</title>
      <link href="/2024/02/14/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0~%EF%BC%89/"/>
      <url>/2024/02/14/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0~%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h1><h3 id="1-service层编写原则"><a href="#1-service层编写原则" class="headerlink" title="1.service层编写原则"></a>1.service层编写原则</h3><blockquote><p> 小心service组件循环依赖问题！！！</p></blockquote><ol><li><strong>Controller调用Service层是：一对一接口调用</strong>，且Controller层不做任何业务处理，目的是为了后续拓展直接替换Controller为RPC框架而准备</li><li><strong>Service层避免互相调用</strong>：一般情况下事物配置在service层，为了避免事物嵌套或单个事物过大等问题的</li><li><strong>service层调用dao层</strong>：除了尽量控制事物大小，即控制Service调用dao层的复杂度，将单个事物经量控制在100ms之内</li></ol><hr><h1 id="springMVC"><a href="#springMVC" class="headerlink" title="springMVC"></a>springMVC</h1><h3 id="1-java-web项目-springmvc-xml-配置文件错误"><a href="#1-java-web项目-springmvc-xml-配置文件错误" class="headerlink" title="1.java web项目 springmvc.xml 配置文件错误"></a>1.java web项目 springmvc.xml 配置文件错误</h3><p>==问题提示：==java web项目 springmvc.xml 配置文件错误。抛出异常<code>Cannot resolve reference to bean ‘cacheManager‘ while setting bean property ‘cacheManager‘</code>。</p><p>==解决办法：==检查 springmvc.xml 配置文件的命名空间，将自动导入的cache改为mvc。</p><p><img src="/img/%E5%BC%82%E5%B8%B8%E7%BB%9F%E8%AE%A1.assets/image-20231007113928748.png" alt="image-20240214165413128"></p><hr><h1 id="Mybatis-plus"><a href="#Mybatis-plus" class="headerlink" title="Mybatis-plus"></a>Mybatis-plus</h1><h3 id="1-mybatis与mybatis-plus版本不兼容问题NoSuchMethodError"><a href="#1-mybatis与mybatis-plus版本不兼容问题NoSuchMethodError" class="headerlink" title="1.mybatis与mybatis-plus版本不兼容问题NoSuchMethodError"></a>1.mybatis与mybatis-plus版本不兼容问题NoSuchMethodError</h3><p>==问题提示：==java.lang.NoSuchMethodError: org.apache.ibatis.session.Configuration.setArgNameBasedConstructorAutoMapping(Z)V</p><p>==解决办法：==在mybatis-plus源码中找其依赖的mybatis版本！！！</p><h3 id="2-Mybatis-plus批量操作"><a href="#2-Mybatis-plus批量操作" class="headerlink" title="2.Mybatis-plus批量操作"></a>2.Mybatis-plus批量操作</h3><blockquote><p>不要使用Iservice提供的saveBatch，耗时最多循环插入都比它快。<a href="https://juejin.cn/post/7189163819825332284">各种批量插入方式效率分析</a></p></blockquote><p>默认BaseMapper没有insertBatch()方法，实现方式有：</p><ol><li>编写Mapper接口和Mapper.xml。自定义insertBatch()方法</li><li>使用mybatis-plus提供了<a href="https://gitee.com/baomidou/mybatis-plus-samples/tree/master/mybatis-plus-sample-sql-injector">InsertBatchSomeColumn</a>批量insert方法<ol><li>自定义sql注入类继承DefaultSqlInjector </li><li>mybatiplus配置类配置自定义sql注入新类的bean</li><li>创建MyBaseMapper接口继承BaseMapper接口，并添加抽象方法 <code>int insertBatchSomeColumn(List&lt;T&gt; entityList);</code></li><li>自定义的Mapper继承MyBaseMapper</li><li>service调用</li></ol></li><li>官网提供的<a href="https://baomidou.com/pages/33c2c2/">MybatisBatch</a>实现批量操作，支持insert、update、delete</li></ol><p>可以开启<strong>mysql的批处理</strong>支持<code>jdbc:mysql://localhost:3306/wzyapi?rewriteBatchedStatements=true</code>提高批处理速度。</p><p>还可以开启<strong>mybatis-plus的批处理模式</strong>。在application.yaml中配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">executor-type:</span> <span class="string">batch</span></span><br></pre></td></tr></table></figure><h3 id="3、mysql账号密码错误而导致的无法连接"><a href="#3、mysql账号密码错误而导致的无法连接" class="headerlink" title="3、mysql账号密码错误而导致的无法连接"></a>3、mysql账号密码错误而导致的无法连接</h3><p>==问题提示==：突然不能连接数据库了。云服务商改了mysql的账号密码。</p><p>==解决办法==：查看账号修改密码。并设置root用户 <code>&#39;root&#39;@&#39;%&#39;</code> 任意ip可访问。小心不是‘root‘@’0.0.0.0’！！！这样不生效！！！</p><hr><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><h3 id="1-npm认证过期，证书过期"><a href="#1-npm认证过期，证书过期" class="headerlink" title="1.npm认证过期，证书过期"></a>1.npm认证过期，证书过期</h3><p>==问题提示：==npm ERR! code CERT_HAS_EXPIRED 。npm认证过期，证书过期问题。</p><p>==解决办法：==CERT_HAS_EXPIRED是一个由<a href="https://so.csdn.net/so/search?q=Node.js&spm=1001.2101.3001.7020">Node.js</a>和npm抛出的错误，表示你正在尝试访问的服务器的SSL证书已经过期。</p><ol><li><p>清除npm缓存：<code>npm cache clean --force</code></p></li><li><p>取消ssl验证：<code>npm config set strict-ssl false</code></p></li><li><p>之后再<code>npm install</code> 你想安装的东西</p></li></ol><h3 id="2-echarts-for-react做图时，图数据不实时变化"><a href="#2-echarts-for-react做图时，图数据不实时变化" class="headerlink" title="2.echarts-for-react做图时，图数据不实时变化"></a>2.echarts-for-react做图时，图数据不实时变化</h3><blockquote><p>困扰1小时！！！</p></blockquote><p>==问题提示：==定义了一个<code>const option</code>变量传递给图，其中<code>option.tilte.text</code>是一个字面量。因为定义的为常量，所以后续js中改变option.title.text就会失效。</p><p>==解决办法：==定义<code>const option</code>变量时将<code>option.tilte.text</code>也定义为变量。通过setTiltle实时变化数据！！！</p><h3 id="3-HttpMessageNotReadableException"><a href="#3-HttpMessageNotReadableException" class="headerlink" title="3.HttpMessageNotReadableException"></a>3.HttpMessageNotReadableException</h3><p>==问题提示：==HttpMessageNotReadableException: JSON parse error: Cannot deserialize value of type <code>java.lang.String</code> from Object value (token <code>JsonToken.START_OBJECT</code>)</p><p>前端json对象（HttpMessage）无法反序列化为后端String对象。因为这样的话需要先反序列化，再序列化，但是默认HTTP请求处理只会反序列化。</p><p>==解决办法：==前端数据输入修改正常。</p><h3 id="4-Ant-Design图标"><a href="#4-Ant-Design图标" class="headerlink" title="4.Ant Design图标"></a>4.Ant Design图标</h3><p>三种表示图标的方法：</p><ol><li><p><code>&lt;MessageOutlined /&gt;</code></p></li><li><p><code>icon=&#123;MessageOutlined&#125;</code></p></li><li><p><code>icon=&quot;message&quot;</code></p></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取全局属性。用户信息</span></span><br><span class="line"><span class="keyword">const</span> &#123; initialState &#125; = <span class="title function_">useModel</span>(<span class="string">&#x27;@@initialState&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; loginUser &#125; = initialState || &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-ant-design-pro修改前端项目的路径后，运行后报错"><a href="#5-ant-design-pro修改前端项目的路径后，运行后报错" class="headerlink" title="5.ant-design-pro修改前端项目的路径后，运行后报错"></a>5.ant-design-pro修改前端项目的路径后，运行后报错</h3><p>==问题提示：== Can not resolve dependence ‘ant-design-pro/node_modules/@umijs/renderer-react’, please install it.</p><p>==解决办法：==删除新路径中的 如：<code>E:\dev\new-ant-design-pro\node_modules\</code> 的文件夹 <code>.cache</code>。 再重新运行项目</p><h3 id="6-前端在打包构建时报错冲突"><a href="#6-前端在打包构建时报错冲突" class="headerlink" title="6.前端在打包构建时报错冲突"></a>6.前端在打包构建时报错冲突</h3><p>==解决办法：==删除原来dist文件</p><h3 id="7-Ant-Design-Pro前端上线后出现404页面请求"><a href="#7-Ant-Design-Pro前端上线后出现404页面请求" class="headerlink" title="7.Ant Design Pro前端上线后出现404页面请求"></a>7.Ant Design Pro前端上线后出现404页面请求</h3><p>==解决办法：==将umi路由方式从默认的browser改为<a href="https://pro.ant.design/zh-CN/docs/deploy#%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E7%BB%93%E5%90%88">hash路由</a>。</p><h3 id="8-浏览器前端请求本质"><a href="#8-浏览器前端请求本质" class="headerlink" title="8.浏览器前端请求本质"></a>8.浏览器前端请求本质</h3><p>将nginx中的前端代码获取到浏览器中渲染。</p><p>umi框架在使用build时自动传入了NODE_ENV == prod</p><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h3 id="1-json字符串转具体泛型对象，例如BaseResopnse-lt-String-gt"><a href="#1-json字符串转具体泛型对象，例如BaseResopnse-lt-String-gt" class="headerlink" title="1.json字符串转具体泛型对象，例如BaseResopnse&lt;String&gt;"></a>1.json字符串转具体泛型对象，例如<code>BaseResopnse&lt;String&gt;</code></h3><blockquote><p>困扰1小时！！！</p></blockquote><p>==问题提示：==1.使用原始泛型类型为变量类型报警。2.<code>BaseResopnse</code>类型值不能赋值到<code>BaseResopnse&lt;String&gt;</code>变量上。</p><p><img src="/img/%E5%BC%82%E5%B8%B8%E7%BB%9F%E8%AE%A1.assets/image-20240206203540636.png" alt="image-20240206203540636"></p><p><img src="/img/%E5%BC%82%E5%B8%B8%E7%BB%9F%E8%AE%A1.assets/image-20240206203756240.png" alt="image-20240206203756240"></p><p>==解决办法：==使用方法<code>JSONUtil.toBean(result, new TypeReference&lt;BaseResponse&lt;String&gt;&gt;() &#123;&#125;,false)</code>。即可返回泛型类型的对象值。</p><h3 id="2-java-lang-LinkageError【devtools导致】"><a href="#2-java-lang-LinkageError【devtools导致】" class="headerlink" title="2.java.lang.LinkageError【devtools导致】"></a>2.java.lang.LinkageError【devtools导致】</h3><blockquote><p>困扰1小时！！！</p></blockquote><p>==问题提示：==两个类加载器<code>RestartClassLoader</code>和<code>Launcher$AppClassLoader</code>加载同一个方法签名冲突。devtools两个类加载器加载同一个类导致的LinkageError。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.LinkageError: loader constraint violation: </span><br><span class="line">when resolving method <span class="string">&quot;com.wzy.wzyapiclientsdk.client.WzyApiClient.getUserNameByPost(Lcom/wzy/wzyapiclientsdk/model/User;)Lcom/wzy/wzyapicommon/common/BaseResponse;&quot;</span> </span><br><span class="line">the class loader (instance of org/springframework/boot/devtools/restart/classloader/RestartClassLoader) of the current class, com/wzy/project/controller/InterfaceInfoController, </span><br><span class="line">and the class loader (instance of sun/misc/Launcher<span class="variable">$AppClassLoader</span>) <span class="keyword">for</span> the method<span class="string">&#x27;s defining class, com/wzy/wzyapiclientsdk/client/WzyApiClient, </span></span><br><span class="line"><span class="string">have different Class objects for the type com/wzy/wzyapicommon/common/BaseResponse used in the signature</span></span><br></pre></td></tr></table></figure><p>LinkageError: loader constraint violation: when resolving method the class loader of the current class,and the class loader for the method have different Class objects for the type used in the signature</p><p>==解决办法：==LinkageError出现的情况复杂，一般发生在被多个类加载器加载的类发生交互时出现。这里是由于springboot装配devtools后，类被加载两次导致。</p><p>devtools加载了两次后，导致有两个类型的BaseResponse，最终导致调用方法getUserNameByPost时类型转换异常。解决办法就是去掉devtools依赖。<a href="https://blog.csdn.net/tongyimplin/article/details/80983272">https://blog.csdn.net/tongyimplin/article/details/80983272</a></p><h3 id="3-java-反射调用函数问题（实际是HttpUtil客户端使用错误抛出的异常）"><a href="#3-java-反射调用函数问题（实际是HttpUtil客户端使用错误抛出的异常）" class="headerlink" title="3.java 反射调用函数问题（实际是HttpUtil客户端使用错误抛出的异常）"></a>3.java 反射调用函数问题（实际是HttpUtil客户端使用错误抛出的异常）</h3><p>==问题提示：==java.lang.reflect.InvocationTargetException调用失败</p><p>==解决办法：==此异常是被调用函数抛出的异常。需要检查被调用函数逻辑。注意使用Hutool发送请求时，不要设置<code>int[]</code>类型的参数，不要使用原始类似数组，否则会报异常，如果传入了原始类型数组，转换一下为包装类似数组。Hutool源码如下:</p><p><img src="/img/%E5%BC%82%E5%B8%B8%E7%BB%9F%E8%AE%A1.assets/image-20240209183009094.png" alt="image-20240209183009094"></p><blockquote><p> List.toArray(需要输入数组对象)。否则创建的是 Object[] 对象</p></blockquote><p>==JSONArray里面只包括JSONObject、JSONArray和原始数据类型！！！==JSON对象很方便转换解析为为Bean对象，而JSON数组不方便转换为Bean对象。</p><h3 id="4-云服务器上的mysql不允许连接"><a href="#4-云服务器上的mysql不允许连接" class="headerlink" title="4.云服务器上的mysql不允许连接"></a>4.云服务器上的mysql不允许连接</h3><p>==问题提示：==mysql不允许链接</p><p>==解决办法：==</p><ol><li>云服务器防火墙开通3306</li><li>mysql的root用户权限默认本地登录访问。改为远程登录访问。</li><li>mysql配置的bind-address改为 0.0.0.0</li></ol><h3 id="5-云服务器上Nacos后端无法连接"><a href="#5-云服务器上Nacos后端无法连接" class="headerlink" title="5.云服务器上Nacos后端无法连接"></a>5.云服务器上Nacos后端无法连接</h3><p>==问题提示：==NacosException: Client not connected, current status:STARTING</p><p>==解决办法：==nacos需要开放三个端口8848、9848、9849。</p><h3 id="6-IDEA中java代码打包问题"><a href="#6-IDEA中java代码打包问题" class="headerlink" title="6.IDEA中java代码打包问题"></a>6.IDEA中java代码打包问题</h3><p>==问题提示：==java打包后只有.jar文件。没有.jar.original文件。且打包后的文件内容格式混乱，打开后不是org/META_INF/BOOT_INF三个文件夹。</p><p>==解决办法：==</p><p>修改pom.xml文件将spring-boot-maven-plugin插件配置好。配置主类加executions标签、去掉skip标签。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--     war包打包插件       --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--jar包打包插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.wzy.wzyapiinterface.WzyapiInterfaceApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="7-上线错误缺失类com-google-protobuf-Message"><a href="#7-上线错误缺失类com-google-protobuf-Message" class="headerlink" title="7.上线错误缺失类com.google.protobuf.Message"></a>7.上线错误缺失类com.google.protobuf.Message</h3><p>==问题提示==：缺失类com.google.protobuf.Message（缺失protobuf-java的依赖）</p><p>==解决办法：==安装依赖包protobuf-java，重新打包。</p><h3 id="8、上线报错ConnectTimeoutException"><a href="#8、上线报错ConnectTimeoutException" class="headerlink" title="8、上线报错ConnectTimeoutException"></a>8、上线报错ConnectTimeoutException</h3><p>==问题提示==：网关报错io.netty.channel.ConnectTimeoutException: connection timed out: /111.231.72.191:8123</p><p>==解决办法==：网关请求不到此端口。云服务器防火墙开放端口8123</p><h3 id="9、SpringBoot读取依赖模块中application-yml配置失效问题"><a href="#9、SpringBoot读取依赖模块中application-yml配置失效问题" class="headerlink" title="9、SpringBoot读取依赖模块中application.yml配置失效问题"></a>9、SpringBoot读取依赖模块中application.yml配置失效问题</h3><p>==问题提示==：A项目依赖B.jar包，其中B.jar包装包含配置文件application.yaml，同时A项目中也包含配置文件application.yaml。运行A项目报错 <code>IllegalArgumentException: Could not resolve placeholder</code> 配置的属性。<a href="https://blog.lonelyman.site/archives/36">https://blog.lonelyman.site/archives/36</a></p><p>==解决办法==：springboot 如果自身有<code>application.yml</code>，就会覆盖依赖模块的同名配置文件。由于在<code>client-service</code>模块创建了<code>application.yml</code>，导致<code>common</code>模块的<code>application.yml</code>被覆盖。所以将配置转移到依赖模块中或者重命名配置文件名。</p><hr><h1 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h1><h3 id="1-一个项目启动多个实例"><a href="#1-一个项目启动多个实例" class="headerlink" title="1.一个项目启动多个实例"></a>1.一个项目启动多个实例</h3><p>==问题提示：==允许多个实例运行后，直接修改原配置文件。导致原java进程也改变了服务端口，原java进程是基于target文件夹未压缩的class文件运行的。</p><p>==解决办法：==</p><ol><li>设置允许多实例运行。</li></ol><p><img src="/img/%E5%BC%82%E5%B8%B8%E7%BB%9F%E8%AE%A1.assets/image-20240204233858018.png" alt="image-20240204233858018"></p><ol start="2"><li>在service窗口复制配置。</li></ol><p><img src="/img/%E5%BC%82%E5%B8%B8%E7%BB%9F%E8%AE%A1.assets/image-20240204233957103.png" alt="image-20240204233957103"></p><ol start="3"><li>在环境变量修改服务端口号和其它使用到的端口号。</li></ol><p><img src="/img/%E5%BC%82%E5%B8%B8%E7%BB%9F%E8%AE%A1.assets/image-20240204234148489.png" alt="image-20240204234148489"></p><ol start="4"><li>运行该配置。</li></ol><h3 id="2-xml文件未引入spring-boot项目"><a href="#2-xml文件未引入spring-boot项目" class="headerlink" title="2.xml文件未引入spring boot项目"></a>2.xml文件未引入spring boot项目</h3><p>==问题提示：==spring boot项目下编写xml文件到resources目录提示Application context not configured for this file</p><p><img src="/img/%E5%BC%82%E5%B8%B8%E7%BB%9F%E8%AE%A1.assets/image-20240205091824617.png" alt="image-20240205091824617"></p><p>==解决办法：==原因是idea识别到xml文件未引入项目。需要在spring boot启动类上加注解<code>@ImportResource(&#123;&quot;classpath:dubbo-consumer.xml&quot;&#125;)</code>用于引入在.xml文件中定义的beans。</p><hr><p>最近遇到的数据库被勒索😈😈😈</p><p><img src="/img/%E5%BC%82%E5%B8%B8%E7%BB%9F%E8%AE%A1.assets/image-20240214110013598.png" alt="image-20240214110013598"></p><p>笑嘻嘻，建议大家数据库密码还是要设置复制一些</p>]]></content>
      
      
      <categories>
          
          <category> 汇总 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇总 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux虚拟机的创建（基于VirtualBox）</title>
      <link href="/2023/01/06/Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%88%E5%9F%BA%E4%BA%8EVirtualBox%EF%BC%89/"/>
      <url>/2023/01/06/Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%88%E5%9F%BA%E4%BA%8EVirtualBox%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、安装VirtualBox"><a href="#一、安装VirtualBox" class="headerlink" title="一、安装VirtualBox"></a>一、安装VirtualBox</h2><p>1.下载VirtualBox</p><p>下载地址：<a href="https://download.virtualbox.org/virtualbox/6.0.10/VirtualBox-6.0.10-132072-Win.exe">https://download.virtualbox.org/virtualbox/6.0.10/VirtualBox-6.0.10-132072-Win.exe</a></p><p>2.开始安装</p><img src="\img\3\image-20230106175835756.png" alt="image-20230106175835756" style="zoom:50%;" /><p>3.更改安装路径，下一步。后续默认选项进行安装。</p><img src="\img\3\image-20230106180015348.png" alt="image-20230106180015348" style="zoom:50%;" /><img src="\img\3\image-20230106180112522.png" alt="image-20230106180112522" style="zoom:50%;" /><h2 id="二、利用Vagrant安装Centos的镜像快速创建虚拟机"><a href="#二、利用Vagrant安装Centos的镜像快速创建虚拟机" class="headerlink" title="二、利用Vagrant安装Centos的镜像快速创建虚拟机"></a>二、利用Vagrant安装Centos的镜像快速创建虚拟机</h2><p>1.安装Vagrant</p><p>安装包下载地址：<a href="https://releases.hashicorp.com/vagrant/2.2.5/vagrant_2.2.5_x86_64.msi">https://releases.hashicorp.com/vagrant/2.2.5/vagrant_2.2.5_x86_64.msi</a></p><p>按默认步骤安装即可，安装后需要重启电脑。</p><p>2.安装虚拟机镜像</p><p>打开CMD命令行，输入下方命令，即在当前目录创建了Vagrantfile文件。执行vagrant up后就完成了虚拟机的基本创建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vagrant init centos #初始化</span><br><span class="line"></span><br><span class="line">vagrant up #联网安装虚拟机镜像</span><br><span class="line"></span><br><span class="line">vagrant ssh #连接虚拟机</span><br></pre></td></tr></table></figure><img src="\img\3\image-20230106185103294.png" alt="image-20230106185103294" style="zoom:100%;" /><img src="\img\3\image-20230106185853296.png" alt="image-20230106185853296" style="zoom:60%;" /><h2 id="三、配置网络IP"><a href="#三、配置网络IP" class="headerlink" title="三、配置网络IP"></a>三、配置网络IP</h2><p>默认虚拟机的ip地址不是固定ip，开发不方便。</p><p>1.使用ipconfig查看virtualbox的网卡地址，我们设置的地址需要与此地址保证同一网段，如图应设为192.168.56.*。</p><img src="\img\3\image-20230106191841746.png" alt="image-20230106191841746" style="zoom:60%;" /><p>2.修改Vagrantfile文件配置ip地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.network &quot;private_network&quot;, ip: &quot;192.168.56.10&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux虚拟机的创建（基于VMware）</title>
      <link href="/2023/01/06/Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%88%E5%9F%BA%E4%BA%8EVMware%EF%BC%89/"/>
      <url>/2023/01/06/Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%88%E5%9F%BA%E4%BA%8EVMware%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、配置硬件"><a href="#一、配置硬件" class="headerlink" title="一、配置硬件"></a>一、配置硬件</h2><p>1.点击“创建新的虚拟机”，打开向导，点击自定义。</p><img src="\img\2\image-20230105232534485.png" alt="image-20230105232534485" style="zoom: 33%;" /><img src="\img\2\image-20230105232648819.png" alt="image-20230105232648819" style="zoom:50%;" /><img src="\img\2\image-20230105232852309.png" alt="image-20230105232852309" style="zoom:50%;" /><p>2.点击“稍后安装操作系统”，先配置硬件，再安装操作系统软件，点击下一步。选择预安装操作系统和对应的版本，点击下一步。</p><img src="\img\2\image-20230105233000827.png" alt="image-20230105233000827" style="zoom:50%;" /><img src="\img\2\image-20230105233138197.png" alt="image-20230105233138197" style="zoom:50%;" /><p>3.修改你的虚拟机名字，和虚拟机文件保存位置，点击下一步。</p><img src="\img\2\image-20230105233358467.png" alt="image-20230105233358467" style="zoom:50%;" /><p>4.设置CPU核数、内存、网络连接、硬盘、设置磁盘地址（最好与虚拟机文件地址一致），最后点击完成。</p><img src="\img\2\image-20230105233841558.png" alt="image-20230105233841558" style="zoom:50%;" /><img src="\img\2\image-20230105234003887.png" alt="image-20230105234003887" style="zoom:50%;" /><img src="\img\2\image-20230105234206932.png" alt="image-20230105234206932" style="zoom:50%;" /><img src="\img\2\image-20230105234308080.png" alt="image-20230105234308080" style="zoom:50%;" /><img src="\img\2\image-20230105234531880.png" alt="image-20230105234531880" style="zoom:50%;" /><img src="\img\2\image-20230105234651303.png" alt="image-20230105234651303" style="zoom:50%;" /><img src="\img\2\image-20230105234753243.png" alt="image-20230105234753243" style="zoom:50%;" /><h2 id="二、安装系统软件"><a href="#二、安装系统软件" class="headerlink" title="二、安装系统软件"></a>二、安装系统软件</h2><p>1.导入Linux的镜像ISO文件。</p><img src="\img\2\image-20230105235222902.png" alt="image-20230105235222902" style="zoom: 33%;" /><img src="\img\2\image-20230105235337839.png" alt="image-20230105235337839" style="zoom:50%;" /><p>2.点击开启虚拟机，开始系统的安装过程，这部分简单跳过，只展示出一些重点步骤的建议选项。</p><img src="\img\2\image-20230105235435033.png" alt="image-20230105235435033" style="zoom: 33%;" /><img src="\img\2\image-20230106000421051.png" alt="image-20230106000421051" style="zoom:50%;" /><p>3.配置分区，1g的/boot文件系统改为标准分区ext4,4g的/swap文件系统为swap，55g的/文件系统为标准分区ext4。</p><img src="\img\2\image-20230106000721768.png" alt="image-20230106000721768" style="zoom:50%;" /><img src="\img\2\image-20230106000815789.png" alt="image-20230106000815789" style="zoom:50%;" /><img src="\img\2\image-20230106001003169.png" alt="image-20230106001003169" style="zoom:50%;" /><img src="\img\2\image-20230106001541753.png" alt="image-20230106001541753" style="zoom:50%;" /><img src="\img\2\image-20230106001848334.png" alt="image-20230106001848334" style="zoom:50%;" /><h2 id="三、配置网络IP和主机名称和主机名称映射"><a href="#三、配置网络IP和主机名称和主机名称映射" class="headerlink" title="三、配置网络IP和主机名称和主机名称映射"></a>三、配置网络IP和主机名称和主机名称映射</h2><p>1.配置静态的IP地址和主机名称。注意IP地址需要配置VMware和windows的和linux的，参考<a href="https://www.bilibili.com/video/BV1Qp4y1n7EN/?p=20&amp;vd_source=b17973d85879e1da10ae411ab7cb16ee%E3%80%82">https://www.bilibili.com/video/BV1Qp4y1n7EN/?p=20&amp;vd_source=b17973d85879e1da10ae411ab7cb16ee。</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-ens33 #修改linux的静态ip配置 </span><br><span class="line"></span><br><span class="line">vim /etc/hostname #修改主机名称</span><br><span class="line"></span><br><span class="line">vim /etc/hosts #配置主机名称映射</span><br><span class="line"></span><br><span class="line">reboot #最后要重启生效</span><br></pre></td></tr></table></figure><p>/etc/sysconfig/network-scripts/ifcfg-ens33配置如下</p><img src="\img\2\image-20230106011126473.png" alt="image-20230106001848334" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《新业务政策和标准》12月</title>
      <link href="/2023/01/05/%E6%96%B0%E4%B8%9A%E5%8A%A1%E6%94%BF%E7%AD%96%E5%92%8C%E6%A0%87%E5%87%8612%E6%9C%88/"/>
      <url>/2023/01/05/%E6%96%B0%E4%B8%9A%E5%8A%A1%E6%94%BF%E7%AD%96%E5%92%8C%E6%A0%87%E5%87%8612%E6%9C%88/</url>
      
        <content type="html"><![CDATA[<h2 id="第一部分-国家法律法规"><a href="#第一部分-国家法律法规" class="headerlink" title="第一部分 国家法律法规"></a>第一部分 国家法律法规</h2><h3 id="中共中央、国务院印发《扩大内需战略规划纲要（2022－2035年）》（12月14日）"><a href="#中共中央、国务院印发《扩大内需战略规划纲要（2022－2035年）》（12月14日）" class="headerlink" title="中共中央、国务院印发《扩大内需战略规划纲要（2022－2035年）》（12月14日）"></a>中共中央、国务院印发《扩大内需战略规划纲要（2022－2035年）》（12月14日）</h3><p>  《纲要》提出，加大生态环保设施建设力度。全面提升生态环境基础设施水平，构建集污水、垃圾、固废、危废、医废处理处置设施和监测监管能力于一体的环境基础设施体系，形成由城市向建制镇和乡村延伸覆盖的环境基础设施网络。实施重要生态系统保护和修复重大工程。推动建立生态保护补偿制度。全面推进资源高效利用，建设促进提高清洁能源利用水平、降低二氧化碳排放的生态环保设施。</p><h3 id="生态环境部印发《企业温室气体排放核算与报告指南-发电设施》和《企业温室气体排放核查技术指南-发电设施》（12月21日）"><a href="#生态环境部印发《企业温室气体排放核算与报告指南-发电设施》和《企业温室气体排放核查技术指南-发电设施》（12月21日）" class="headerlink" title="生态环境部印发《企业温室气体排放核算与报告指南 发电设施》和《企业温室气体排放核查技术指南 发电设施》（12月21日）"></a>生态环境部印发《企业温室气体排放核算与报告指南 发电设施》和《企业温室气体排放核查技术指南 发电设施》（12月21日）</h3><p>  为进一步提升碳排放数据质量，完善全国碳排放权交易市场制度机制，增强技术规范的科学性、合理性和可操作性，12月21日，生态环境部印发《企业温室气体排放核算与报告指南 发电设施》《企业温室气体排放核查技术指南 发电设施》的通知。</p><h2 id="第二部分-地方法律法规"><a href="#第二部分-地方法律法规" class="headerlink" title="第二部分 地方法律法规"></a>第二部分 地方法律法规</h2><h3 id="贵州省人民政府印发《关于加快建立健全绿色低碳循环发展经济体系的实施意见》（11月30日）"><a href="#贵州省人民政府印发《关于加快建立健全绿色低碳循环发展经济体系的实施意见》（11月30日）" class="headerlink" title="贵州省人民政府印发《关于加快建立健全绿色低碳循环发展经济体系的实施意见》（11月30日）"></a>贵州省人民政府印发《关于加快建立健全绿色低碳循环发展经济体系的实施意见》（11月30日）</h3><p>  《意见》提出，推进医疗废物信息化管理，实现一级以上医疗机构医疗废物可追溯，并逐步向乡镇卫生院、社区卫生服务中心延伸。推进设市城市实现餐厨垃圾处理能力全覆盖。加快县域生活垃圾焚烧处理全覆盖，配套建设焚烧飞灰处理设施，全省基本实现原生生活垃圾“零填埋”。</p><h3 id="北京市城管委员会印发《北京市”十四五”时期环境卫生事业发展规划》（12月21日）"><a href="#北京市城管委员会印发《北京市”十四五”时期环境卫生事业发展规划》（12月21日）" class="headerlink" title="北京市城管委员会印发《北京市”十四五”时期环境卫生事业发展规划》（12月21日）"></a>北京市城管委员会印发《北京市”十四五”时期环境卫生事业发展规划》（12月21日）</h3><p>  《规划》提出，强化科技赋能。开展恶臭污染物治理、渗滤液及浓缩液处理、厨余垃圾就地处理、小型化垃圾焚烧处理和焚烧炉渣资源化利用等技术研发与集成应用。</p><p>  有序推进厨余垃圾处理设施建设。2025年底前建成顺义、平谷、密云等区厨余垃圾处理技改、应急、新（扩）建项目，力争全市处理能力达到9000吨/日以上，补齐处理能力短板。推动农村地区厨余垃圾与农林有机废弃物协同处理，减少垃圾出村。加强废弃油脂回收、处置规范化管理体系建设。</p><h3 id="北京市发展改革委发布《关于征集基础设施REITs试点储备项目有关工作的通知》（12月19日）"><a href="#北京市发展改革委发布《关于征集基础设施REITs试点储备项目有关工作的通知》（12月19日）" class="headerlink" title="北京市发展改革委发布《关于征集基础设施REITs试点储备项目有关工作的通知》（12月19日）"></a>北京市发展改革委发布《关于征集基础设施REITs试点储备项目有关工作的通知》（12月19日）</h3><p>  《通知》指出，试点行业范围包括能源基础设施。包括风电、光伏发电、水力发电、天然气发电、生物质发电、核电等清洁能源项目，特高压输电项目，增量配电网、微电网、充电基础设施项目，分布式冷热电项目。</p><p>  还包括生态环保基础设施。包括城镇污水垃圾处理及资源化利用环境基础设施、固废危废医废处理环境基础设施、大宗固体废弃物综合利用基础设施项目。</p><h3 id="上海市经济信息化委等四部门联合印发《上海市工业领域碳达峰实施方案》（12月9日）"><a href="#上海市经济信息化委等四部门联合印发《上海市工业领域碳达峰实施方案》（12月9日）" class="headerlink" title="上海市经济信息化委等四部门联合印发《上海市工业领域碳达峰实施方案》（12月9日）"></a>上海市经济信息化委等四部门联合印发《上海市工业领域碳达峰实施方案》（12月9日）</h3><p>  《方案》提出，推动碳捕集利用与封存(CCUS)应用场景向化工、钢铁等其他行业拓展，加快与储能、氢能等技术的集成发展。大力推进氢能应用研究，研发清洁、高效、经济的工业副产氢提纯制氢技术，突破高能效氢燃料电池系统、长寿命电堆、质子交换膜等关键技术。推动高压供氢加氢设备、70兆帕储氢瓶等多重储运技术的应用。开展兆瓦级风力、光伏等新能源电解水制氢集成及应用示范。</p><p>  强化行业和区域协同处置能力。推进工业窑炉、工业企业间点对点协同处置固废，开展燃煤电厂、生活垃圾焚烧设施对市政污泥、工业固废、建筑垃圾等的协同处置，试点示范有机污泥、餐厨垃圾等在生物质能上的应用。</p><h3 id="上海市生态环境局印发《上海市“无废城市”建设工作方案（征求意见稿）》（11月29日）"><a href="#上海市生态环境局印发《上海市“无废城市”建设工作方案（征求意见稿）》（11月29日）" class="headerlink" title="上海市生态环境局印发《上海市“无废城市”建设工作方案（征求意见稿）》（11月29日）"></a>上海市生态环境局印发《上海市“无废城市”建设工作方案（征求意见稿）》（11月29日）</h3><p>  《方案》提出，全面实现原生生活垃圾零填埋。按照资源化利用和无害化处置并举的原则，继续推进宝山、浦东海滨等生活垃圾焚烧项目和老港二期、宝山湿垃圾项目建设，在老港、闵行、嘉定、松江、青浦、奉贤、崇明等区域再新建一批湿垃圾集中处理设施。</p><p>  建立平战结合的医疗废物收运处置体系。完善医疗废物应急收运处置体系，将生活垃圾焚烧设施纳入本市医疗废物应急处置设施清单。</p><p>  落实燃煤电厂、生活垃圾焚烧设施协同处置市政污泥、工业固废、建筑垃圾残渣等。妥善处理处置污泥。结合污水厂新建、扩建工程，完成浦东、嘉定、青浦等区污泥干化焚烧设施建设，推进燃煤电厂和垃圾焚烧厂污泥掺烧，到2025年实现全市污水厂污泥零填埋。新建一批通沟污泥处理设施，新增处理能力共计约10.5万吨/年。</p><h3 id="西藏自治区人民政府办公厅印发《西藏自治区“十四五”时期“无废城市”建设工作方案》（12月2日）"><a href="#西藏自治区人民政府办公厅印发《西藏自治区“十四五”时期“无废城市”建设工作方案》（12月2日）" class="headerlink" title="西藏自治区人民政府办公厅印发《西藏自治区“十四五”时期“无废城市”建设工作方案》（12月2日）"></a>西藏自治区人民政府办公厅印发《西藏自治区“十四五”时期“无废城市”建设工作方案》（12月2日）</h3><p>  《方案》要求，各市要因地制宜推进简便易行的垃圾分类和资源化利用方法，加强易腐烂垃圾就地处理和资源化利用。探索开展农村生活垃圾分类和资源化利用示范县创建工作。探索建设小型化、分散化、无害化处理设施，推进农牧区生活垃圾就地就近处理。各相关市95%的行政村实现农村生活垃圾收运处置体系全覆盖。</p><p>  实施好自治区危险废物处置中心二期项目和地(市)级医疗废物处置中心提标改造项目建设,有效提升危险废物(医疗废物)处置能力。加快推动日喀则市、山南市所辖偏远县小型医疗废物处置设施建设,解决医疗废物运距远、处置不及时的问题。</p><h3 id="宁夏回族自治区第十二届人民代表大会常务委员会通过《宁夏回族自治区固体废物污染环境防治条例》（11月30日）"><a href="#宁夏回族自治区第十二届人民代表大会常务委员会通过《宁夏回族自治区固体废物污染环境防治条例》（11月30日）" class="headerlink" title="宁夏回族自治区第十二届人民代表大会常务委员会通过《宁夏回族自治区固体废物污染环境防治条例》（11月30日）"></a>宁夏回族自治区第十二届人民代表大会常务委员会通过《宁夏回族自治区固体废物污染环境防治条例》（11月30日）</h3><p>  《条例》指出，产生、收集厨余垃圾的单位和其他生产经营者应当将厨余垃圾交由具备相应资质条件的单位进行无害化处理。禁止将厨余垃圾资源化产品作为食品销售或者用于食品生产。</p><p>  县级以上人民政府应当建立重大传染病疫情医疗废物应急处置保障体系，将危险废物焚烧设施、生活垃圾焚烧设施等纳入应急处置保障体系，明确集中隔离场所、封闭管理区域涉疫情医疗废物和生活垃圾的收集、贮存、运输要求，保障重大传染病疫情医疗废物处置安全。</p><p>  县级以上人民政府应当制定工业固体废物污染环境防治工作规划，组织建设工业固体废物集中处置等设施，支持推广减少工业固体废物产生量和降低工业固体废物危害性的生产工艺和设备，推动工业固体废物污染环境防治工作。</p><p>  城镇污水处理设施维护运营单位或者污泥处理处置单位应当安全处理处置污泥，保证处理处置后的污泥符合国家标准，建立污泥管理台账，对产生的污泥以及处理处置后的污泥去向、用途、用量等进行跟踪、记录，并向城镇排水、生态环境主管部门报告。</p><h3 id="河南省生态环境厅发布《河南省固体废物污染环境防治条例（征求意见稿）》（12月1日）"><a href="#河南省生态环境厅发布《河南省固体废物污染环境防治条例（征求意见稿）》（12月1日）" class="headerlink" title="河南省生态环境厅发布《河南省固体废物污染环境防治条例（征求意见稿）》（12月1日）"></a>河南省生态环境厅发布《河南省固体废物污染环境防治条例（征求意见稿）》（12月1日）</h3><p>  《条例》指出，县级以上人民政府统筹负责本行政区域内医疗废物收集、贮存、运输、处置体系的建设工作，实现县级以上医疗废物全收集、全处理，并逐步延伸到村镇地区。人口密集的县（市）可建设县级医疗废物处置设施。鼓励边远地区医疗机构配置移动式或小型处理设备实现就地消毒处理。</p><p>  新建、改建和扩建城镇污水处理厂，应当规划、建设污泥处理处置设施，保证污水处理厂产生的污泥无害化处置。</p><h3 id="宁夏回族自治区生态环境厅发布《宁夏回族自治区可再生能源发展“十四五”规划》（12月5日）"><a href="#宁夏回族自治区生态环境厅发布《宁夏回族自治区可再生能源发展“十四五”规划》（12月5日）" class="headerlink" title="宁夏回族自治区生态环境厅发布《宁夏回族自治区可再生能源发展“十四五”规划》（12月5日）"></a>宁夏回族自治区生态环境厅发布《宁夏回族自治区可再生能源发展“十四五”规划》（12月5日）</h3><p>  《规划》提出，宁夏自治区将加快推进垃圾发电在地级市全覆盖。加快建设固原、石嘴山等生活垃圾焚烧发电项目，实现地级市全覆盖目标。结合社会人口经济发展和城镇化建设进程，适时启动银川扩建、同心等生活垃圾焚烧发电项目。到2025年，垃圾焚烧发电处理能力超过5000吨/天，装机规模达到10万千瓦。</p><p>  大力发展离网型新能源电解水制氢，打造宁东光伏产业园绿氢规模化生产基地。培育风光+氢储能一体化应用模式，积极创建宁东可再生能源制氢耦合煤化工产业示范区，通过绿氢耦合煤制油、煤制烯烃、煤制乙二醇、煤基多联产等项目，推动灰氢转绿、以氢换煤、绿氢消碳。到2025年，力争绿氢生产规模达到8万吨/年。</p><p>  推广生物质成型燃料供热应用。结合清洁取暖、农村散煤治理和燃煤锅炉拆除等工作，加快生物质成型燃料在工业供热和民用采暖等领域推广应用。</p><h3 id="江西省住房和城乡建设厅等六部门联合印发《关于进一步加强农村生活垃圾收运处置体系建设管理的实施意见》（11月28日）"><a href="#江西省住房和城乡建设厅等六部门联合印发《关于进一步加强农村生活垃圾收运处置体系建设管理的实施意见》（11月28日）" class="headerlink" title="江西省住房和城乡建设厅等六部门联合印发《关于进一步加强农村生活垃圾收运处置体系建设管理的实施意见》（11月28日）"></a>江西省住房和城乡建设厅等六部门联合印发《关于进一步加强农村生活垃圾收运处置体系建设管理的实施意见》（11月28日）</h3><p>  《意见》指出，各地要按照生活垃圾收运处置体系自然村(村民小组)全覆盖的要求，合理配置收运处置设施设备，实现自然村有收集点(站)、乡镇有转运能力、县城有无害化处理能力。逐步取缔露天收集池，更新老旧破损垃圾收集容器，推动处理设施设备升级换代，建设一批小型化、分散化、无害化的生活垃圾处理设施。</p><h3 id="云南省第十三届人民代表大会常务委员会通过《云南省固体废物污染环境防治条例》（11月30日）"><a href="#云南省第十三届人民代表大会常务委员会通过《云南省固体废物污染环境防治条例》（11月30日）" class="headerlink" title="云南省第十三届人民代表大会常务委员会通过《云南省固体废物污染环境防治条例》（11月30日）"></a>云南省第十三届人民代表大会常务委员会通过《云南省固体废物污染环境防治条例》（11月30日）</h3><p>  《条例》提出，医疗卫生机构应当依法分类收集本单位产生的医疗废物，交由医疗废物集中处置单位处置。医疗废物集中处置单位应当及时收集、运输和处置医疗废物。鼓励发展移动式医疗废物处置设施，为偏远地区提供处置服务。</p><p>  县级以上人民政府城镇排水主管部门应当将污泥处理设施纳入城镇排水与污水处理规划，推动同步建设污泥处理设施与污水处理设施，鼓励协同处理，不断提高污泥综合利用和无害化处理水平。</p><h3 id="湖南省工业和信息化厅印发《湖南省工业领域碳达峰实施方案》（12月21日）"><a href="#湖南省工业和信息化厅印发《湖南省工业领域碳达峰实施方案》（12月21日）" class="headerlink" title="湖南省工业和信息化厅印发《湖南省工业领域碳达峰实施方案》（12月21日）"></a>湖南省工业和信息化厅印发《湖南省工业领域碳达峰实施方案》（12月21日）</h3><p>  《方案》提出，建立数字化碳管理体系。加强信息技术在能源消费与碳排放等领域的开发应用，鼓励企业基于能源管控系统建立数字化碳管理平台，协同推进用能数据与碳排放数据的收集、分析和管理。探索建设碳达峰碳中和综合服务平台，建立产品全生命周期碳排放基础数据库，深化重点行业碳排放实时监测。</p><p>  有序推进重点行业企业碳排放报告与核查机制，引导重点企业对标建立碳排放报告和信息披露制度。积极开展重点行业建设项目碳排放环境影响评价。引导企业积极参与绿电交易，做好绿电交易与绿证交易、碳排放权交易的衔接。</p><h3 id="吉林省人民政府办公厅印发《关于进一步加强生活垃圾处理工作的指导意见》（12月30日）"><a href="#吉林省人民政府办公厅印发《关于进一步加强生活垃圾处理工作的指导意见》（12月30日）" class="headerlink" title="吉林省人民政府办公厅印发《关于进一步加强生活垃圾处理工作的指导意见》（12月30日）"></a>吉林省人民政府办公厅印发《关于进一步加强生活垃圾处理工作的指导意见》（12月30日）</h3><p>  《意见》提出，推进生活垃圾焚烧处理设施建设，到2023年底，基本实现原生生活垃圾“零填埋”。到2025年底，生活垃圾焚烧处理能力进一步提升，地级及以上城市基本具备厨余垃圾集中处理能力。</p><p>  推进厨余垃圾处理。实施生活垃圾分类试点的城市要加快出台相关法规制度，明确厨余垃圾处理要求，以集中处理为主，分散处理为辅，有序推进厨余垃圾处理设施建设。鼓励厨余垃圾处理设施与生活垃圾焚烧处理设施同步、就近建设。</p>]]></content>
      
      
      <categories>
          
          <category> 政策 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 政策 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客搭建（基于HEXO）</title>
      <link href="/2023/01/04/%E5%BF%AB%E9%80%9F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%88%E5%9F%BA%E4%BA%8EHEXO%EF%BC%89/"/>
      <url>/2023/01/04/%E5%BF%AB%E9%80%9F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%88%E5%9F%BA%E4%BA%8EHEXO%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="个人博客搭建（基于HEXO）"><a href="#个人博客搭建（基于HEXO）" class="headerlink" title="个人博客搭建（基于HEXO）"></a>个人博客搭建（基于HEXO）</h1><h2 id="一、安装环境"><a href="#一、安装环境" class="headerlink" title="一、安装环境"></a>一、安装环境</h2><h3 id="1-安装node-js"><a href="#1-安装node-js" class="headerlink" title="1.安装node.js"></a>1.安装node.js</h3><ul><li>下载node.js二进制安装包，这一步需要注意node.js与centos版本的匹配与兼容。</li></ul><img src="/img/1/image-20230104121014067.png" alt="image-20230104121014067" style="zoom:50%;" /><ul><li><p>下载后根据<a href="https://github.com/nodejs/help/wiki/Installation%E6%95%99%E7%A8%8B%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85%E3%80%82">https://github.com/nodejs/help/wiki/Installation教程进行安装。</a></p><ol><li>Unzip the binary archive to any directory you wanna install Node, I use <code>/usr/local/lib/nodejs</code></li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VERSION=v10.15.0</span><br><span class="line">DISTRO=linux-x64</span><br><span class="line">sudo mkdir -p /usr/local/lib/nodejs</span><br><span class="line">sudo tar -xJvf node-$VERSION-$DISTRO.tar.xz -C /usr/local/lib/nodejs </span><br></pre></td></tr></table></figure><ol start="2"><li>Set the environment variable <code>~/.profile</code>, add below to the end</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Nodejs</span><br><span class="line">VERSION=v10.15.0</span><br><span class="line">DISTRO=linux-x64</span><br><span class="line">export PATH=/usr/local/lib/nodejs/node-$VERSION-$DISTRO/bin:$PATH</span><br></pre></td></tr></table></figure><ol start="3"><li>Refresh profile</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. ~/.profile</span><br></pre></td></tr></table></figure><ol start="4"><li>Test installation using</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">$ npm version</span><br><span class="line">$ npx -v</span><br></pre></td></tr></table></figure><ul><li>安装cnpm</li></ul><p>由于npm很慢，我们安装cnpm并配置淘宝镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><ul><li>成功案例：博主使用centos7.5，node.js v16.9.0</li></ul><img src="/img/1/image-20230104121257507.png" alt="image-20230104121257507" style="zoom:50%;" /><ul><li>注意node.js版本限制，最好安装12.13.0以上的版本。</li></ul><img src="/img/1/image-20230104121449564.png" alt="image-20230104121449564" style="zoom:50%;" /><h3 id="2-安装HEXO"><a href="#2-安装HEXO" class="headerlink" title="2.安装HEXO"></a>2.安装HEXO</h3><ul><li>用cnpm包管理工具安装hexo</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><ul><li>验证安装完成hexo -v</li></ul><img src="/img/1/image-20230104123816448.png" alt="image-20230104123816448" style="zoom:50%;" /><h2 id="3-创建blog工程文件夹"><a href="#3-创建blog工程文件夹" class="headerlink" title="3.创建blog工程文件夹"></a>3.创建blog工程文件夹</h2>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
